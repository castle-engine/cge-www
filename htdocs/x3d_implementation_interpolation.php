<?php
  require_once 'x3d_implementation_common.php';
  require_once 'x3d_extensions_functions.php';
  x3d_status_header('Interpolation', 'interp',
    'This component defines nodes to interpolate between a given set
     of values. Interpolators are often used for animation,
     receiving time values from <code>TimeSensor</code> and sending interpolated
     values to visible nodes.');

  $toc = new TableOfContents(
    array(
      new TocItem('How to animate things using X3D', 'howto'),
        new TocItem('Basic animation concepts: connect 3 nodes', 'nodes_combo', 1),
          new TocItem('TimeSensor node', 'nodes_combo_1', 2),
          new TocItem('Interpolator node, e.g. PositionInterpolator', 'nodes_combo_2', 2),
          new TocItem('Node with the thing you want to animate, e.g. Transform', 'nodes_combo_3', 2),
        new TocItem('Building an animation in Object Pascal code', 'pascal', 1),
        new TocItem('Notes about looping animations', 'looping_notes', 1),
        new TocItem('How to implement skeletons, mesh deformations, skinned mesh animation...', 'animation_methods', 1),
      new TocItem('Supported nodes', 'support'),
    ));
?>

<p>Contents:
<?php echo $toc->html_toc(); ?>

<?php echo $toc->html_section(); ?>

<?php echo $toc->html_section(); ?>

<p>Animation in X3D usually requires connecting 3 nodes, as described below.

<?php echo $toc->html_section(); ?>

<p><a href="<?php echo x3d_spec_latest_url('time', 'TimeSensor'); ?>">TimeSensor</a>
node generates <i>output events</i> as time passes.
Most importantly, it generates <code>fraction_changed</code> <i>output event</i>,
that represents progress within the animation, in the [0..1] range.

<p>Note: the actual <i>duration of this animation, in seconds</i>, is specified
in the field <code>TimeSensor.cycleInterval</code>. Whatever it is,
the <code>TimeSensor.fraction_changed</code> is still generated in
the [0..1] range. This way you can easily make animation faster/slower
by only changing the <code>TimeSensor.cycleInterval</code> value.

<p>How to start the animation?
In <i>Castle Game Engine</i>, it's easiest to just use the
<?php echo cgeRef('TCastleSceneCore.PlayAnimation'); ?>
 method. It internally does everything necessary to reliably start the
indicated <code>TimeSensor</code> node.
Just be aware that there are other ways to start an animation,
X3D standard allows to make <code>TimeSensor</code> node active at open,
or activate it through various other means. But using
<?php echo cgeRef('TCastleSceneCore.PlayAnimation'); ?>
 is almost always simpler, <i>and</i> you get some cool extra options that
we will mention later.

<p>Consider this X3D file (in classic encoding -- you can save it as
<code>test.x3dv</code> file and open with <a href="view3dscene.php">view3dscene</a>
or any engine tool):

<?php echo vrmlx3d_highlight(
'#X3D V3.2 utf8
PROFILE Interchange

DEF MyAnimationName TimeSensor {
  cycleInterval 5.0
}'); ?>

<p>This animation does not do anything (<code>MyAnimationName</code>
output events are not connected to anything). But it can already be started
using <code>Scene.PlayAnimation('MyAnimationName', true)</code>
in the engine. The <code>Scene.AnimationDuration('MyAnimationName')</code>
will return 5.0.

<p>You can also play it in <a href="view3dscene.php">view3dscene</a>:
Open the created <code>test.x3dv</code> file an choose menu item
<i>Animation -&gt; Named Animations -&gt; MyAnimationName</i>.

<p>Note that we have <i>named</i> the <code>TimeSensor</code> node,
by prefixing it with <code>DEF MyAnimationName</code> statement.
This is the standard way in X3D to name nodes.
The <code>PlayAnimation</code> simply takes this name as a parameter.
<!-- This name is also useful for other purposes, e.g. <code>ROUTE</code> -->
<!-- statements will use it too. -->

<?php echo $toc->html_section(); ?>

<p>Next we need an interpolator node, like <a href="<?php echo x3d_spec_latest_url('interp', 'PositionInterpolator'); ?>">PositionInterpolator</a>.
Every interpolator processes <i>keys</i> in [0..1] range are produces
<i>key values</i>. All interpolators have an <i>input event</i>
called <code>set_fraction</code> that, as it's name suggests,
can be connected with the <code>TimeSensor.fraction_changed</code>
output event. In response to receiving the <code>set_fraction</code> input,
an interpolator generates an output event called <code>value_changed</code>.

<p>The <code>value_changed</code> is calculated by looking where
is the received fraction inside <code>key</code> field,
and calculating appropriate value by picking a range from <code>keyValue</code>
field.

<p>The type of values (there are placed in <code>keyValue</code>,
and generated by <code>value_changed</code>) depends on the interpolator
type. There are many interpolator nodes, most of them are part of the "Interpolation"
X3D component and are listed lower on this page
(and some more interpolators are added by the <a href="x3d_implementation_nurbs.php">NURBS component</a>
and <a href="x3d_implementation_interpolation_extensions.php">our extensions</a>).

<p>For example, in case of <code>PositionInterpolator</code>,
each "key value" is a 3D vector (which is called <code>SFVec3f</code>
in X3D, "SFVec3f" = <i>"Single Field with a Vector of 3 floats"</i>).

<p>This is how we would connect <code>PositionInterpolator</code>
to a <code>TimeSensor</code> to create a movement from (0,0,0)
to (10,0,0) in 3 seconds, and then a movement from (10,0,0) to (10,10,0)
in 1 second:

<?php echo vrmlx3d_highlight(
'#X3D V3.2 utf8
PROFILE Interchange

DEF MyAnimationName TimeSensor {
  cycleInterval 4.0
}
DEF MyInterpolator PositionInterpolator {
  key      [ 0    , 0.75  , 1 ]
  keyValue [ 0 0 0, 10 0 0, 10 10 0 ]
}
ROUTE MyAnimationName.fraction_changed TO MyInterpolator.set_fraction'); ?>

<p>Note that <i>nothing actually moves yet</i>,
as there is nothing visible in the scene yet.

<?php echo $toc->html_section(); ?>

<p>As a last step, we need to connect the output event of the interpolator,
like <code>PositionInterpolator.value_changed</code> to... something.
This is where the power of the X3D animation system is most prominent, as you can connect
"anything to anything" as long as the type matches.
So <code>PositionInterpolator.value_changed</code> can be connected
to <i>any input-output field that holds 3D vectors</i> (this is marked like
<code>SFVec3f [in,out]</code> in the X3D specification)
or <i>any input event that can receive 3D vectors</i> (this is marked like
<code>SFVec3f [in]</code> in the X3D specification).

<p>For example, note that the <code>translation</code> field of the
<a href="<?php echo x3d_spec_latest_url('group', 'Transform'); ?>">Transform</a>
node looks suitable. This way you can animate movement of anything visible.
Since <code>Transform</code>
node may contain other nodes, including visible <a href="<?php echo x3d_spec_latest_url('shape', 'Shape'); ?>">Shape</a> nodes,
or a nested <code>Transform</code> (that can also be animated),
you can build a lot of complicated animations with this approach.

<p>Here's a simple animation of a moving ball:

<?php echo vrmlx3d_highlight(
'#X3D V3.2 utf8
PROFILE Interchange

DEF MyAnimationName TimeSensor {
  cycleInterval 4.0
}
DEF MyInterpolator PositionInterpolator {
  key      [ 0    , 0.75  , 1 ]
  keyValue [ 0 0 0, 10 0 0, 10 10 0 ]
}
DEF MyTransform Transform {
  children Shape {
    geometry Sphere { }
    appearance Appearance {
      material Material {
        diffuseColor 1 1 0 # yellow
      }
    }
  }
}
ROUTE MyAnimationName.fraction_changed TO MyInterpolator.set_fraction
ROUTE MyInterpolator.value_changed TO MyTransform.translation'); ?>

<?php echo $toc->html_section(); ?>

<p>Everything described above can be loaded from an X3D file,
or it can be constructed by code. You can create X3D nodes and routes
completely programmatically, using Object Pascal.

<p>The example program below creates a sphere animation,
by programmatically creating the <code>TimeSensor</code> and all the other
X3D nodes we discussed above.
It is done completely in Pascal (instead of loading the scene from X3D file,
like <code>Scene.Load('example.x3dv')</code>), which allows you to extend
this example to do something much cooler (e.g. add it to a procedurally-generated
model).</p>

<?php echo pascal_highlight_file('code-samples/build_scene_interpolator.lpr'); ?>

<?php echo $toc->html_section(); ?>

<p>To make the animation behave nicely when looping, you will usually want
to make the first item on the <code>keyValue</code> list equal to the last.

<p>For example change this:

<?php echo vrmlx3d_highlight(
'DEF MyInterpolator PositionInterpolator {
  key      [ 0    , 0.75  , 1 ]
  keyValue [ 0 0 0, 10 0 0, 10 10 0 ]
}'); ?>

<p>into this:

<?php echo vrmlx3d_highlight(
'DEF MyInterpolator PositionInterpolator {
  key      [ 0    , 0.675 , 0.9    , 1 ]
  keyValue [ 0 0 0, 10 0 0, 10 10 0, 0 0 0 ]
}'); ?>

<p>To actually <i>run the animation as looping</i> in <i>Castle Game Engine</i>
just call <code>Scene.PlayAnimation('MyAnimationName', true)</code>.

<p>Note: if you read the X3D specification, you may notice a field
called <code>TimeSensor.loop</code>. <i>Do not touch this field</i>,
it will be automatically changed each time you use
the <code>PlayAnimation</code> method. If you generate the X3D files yourself,
leave <code>TimeSensor.loop</code> initially <code>FALSE</code> (this is the default),
otherwise the animation will be already playing when you load the file.

<p>The <?php echo cgeRef('TCastleSceneCore.PlayAnimation'); ?> method is very powerful.
For example you can optionally
play the animation backward, or with <a href="https://castle-engine.io/wp/2018/03/21/animation-blending/">blending</a>,
or get a notification when animation stops.

<?php echo $toc->html_section(); ?>

<p>Let us look at various popular animation methods, and how to do them in X3D:

<ol>
  <li><p>If you have <b>a skeleton with rigid parts attached to bones</b>,
    then you simply create a hierarchy of <code>Transform</code> nodes
    (<code>TTransformNode</code> in Pascal).
    Then you animate them as described above.

    <p>You can animate <code>Transform.translation</code> and
    <code>Transform.scale</code> with
    <?php echo x3d_node_link('PositionInterpolator'); ?>.
    And you can animate <code>Transform.rotation</code> with
    <?php echo x3d_node_link('OrientationInterpolator'); ?>.

    <p>This is also how we animate <a href="https://castle-engine.io/spine">Spine models (2D skeletons)</a>. You can check this by loading a Spine model, e.g. <a href="https://github.com/castle-engine/castle-engine/tree/master/examples/2d_dragon_spine_game/data/dragon">dragon.json from here</a>, into view3dscene, and saving it as X3D.

    <p>Optimization hint: if your models have a deep hierarchy of transformations, and a lot of these transformations simultaneously change, it's often beneficial to set global <code>OptimizeExtensiveTransformations</code> to <code>true</code>. See the <a href="manual_optimization.php">manual about optimization</a>. This is only temporary, of course &mdash; in the future we hope to make this optimization automatic. But for now, it sometimes helps (a lot), but sometimes can also cause a slowdown, so it's optional and should be enabled only after testing.

  <li><p>Another animation method is to <b>deform meshes by interpolating between a couple of mesh versions</b>. To do this, you use <?php echo x3d_node_link('CoordinateInterpolator'); ?> node in X3D. It works consistently with other interpolators. It generates a <i>set of 3D vectors</i> (<code>MFVec3f</code> field in X3D terms) that can be connected e.g. to <code>Coordinate.point</code> field. The <code>Coordinate</code> node may be in turn be placed inside the <code>IndexedFaceSet.coord</code>. See the <a href="<?php echo x3d_spec_latest_url('rendering', 'Coordinate'); ?>">Coordinate</a> and <a href="<?php echo x3d_spec_latest_url('geometry3D', 'IndexedFaceSet'); ?>">IndexedFaceSet</a> nodes specifications.

    <p>This is similar to how <i>"blend shapes"</i> in Blender work. We interpolate between some sets of coordinates. It's suitable e.g. for facial animations.

  <li><p>Another animation method is the <b>skinned mesh animation, where we deform meshes by animating bones, and then calculating how these bones pull the mesh</b>. This is different from using <?php echo x3d_node_link('CoordinateInterpolator'); ?>: now the animation engine (<i>Castle Game Engine</i> code) must be aware of bones, of how do they map onto the vertexes: which bone affects which vertex and with what strength.

    <p>The skinned mesh animation is part of the <a href="x3d_implementation_hanim.php">"H-Anim" X3D component</a>. The name of the component ("H-Anim", short for <i>"humanoid animation"</i>) is a little misleading, as it actually alllows to animate any meshes, not only humanoids. It allows to animate using the <i>"skinned mesh animation"</i> approach. We describe the relevant fields in the <a href="x3d_implementation_hanim.php">"H-Anim" documentation</a>.

    <!--p>(Note: "H-Anim" also adds alternative nodes to animate using rigid skeletons. So, instead of animating a hierarchy of <code>Transform</code>, you can animate a hierarchy of <code>Joint</code> nodes. In practice, it's exactly the same thing for our engine.-->

  <li><p><i>Future:</i> We also plan to add a <a href="roadmap#gltf_skinning_gpu">SkinnedAnimation</a> node that allows to perform skinned animation in a bit more straightforward way than H-Anim and matching closer the glTF skinned animation design, in particular providing <i>"Inverse Bind Matrices"</i>. Follow the <a href="roadmap#gltf_skinning_gpu">roadmap item about SkinnedAnimation</a> to learn more.

  <li><p><i>Deprecated:</i> Our engine also implements another animation method as part of <a href="castle_animation_frames.php">animating castle-anim-frames files</a>. In this case, we use a special <i>node interpolator</i> that performs a linear interpolation between whole graphs of X3D nodes. So it's not using <code>PositionInterpolator</code> or <code>CoordinateInterpolator</code> or H-Anim skinned mesh animation.

    <p>The approach of <i>node interpolator</i> is extremely flexible (able to animate anything that you can create in Blender, whether it's "structurally equal" or not). It is also extremely fast (as the frames are precalculated in memory, so you're actually just rendering static models). However, it may also be slow to load, and it can eat a significant amount of memory.

    <p>For the above reasons, we consider this technique deprecated. It is admittedly powerful, but also inherently memory consuming. We advise to not use this approach, better use standard <a href="gltf">glTF</a> or <A href="x3d">X3D</a> ways to animate.
</ol>

<p>Note that these animations techniques are not mutually exclusive. You can, to some extent, use them within a single scene:

<ul>
  <li><p>A single <code>TimeSensor</code> node can be connected to multiple interpolators, it can e.g. connect to many <code>PositionInterpolator</code> and <code>CoordinateInterpolator</code> nodes.

  <li><p>Running one <code>TimeSensor</code> node can also run other <code>TimeSensor</code> nodes. <!--So you can create a "chain" of <code>TimeSensor</code> nodes.--> To do this, you would route a couple of fields from one <code>TimeSensor</code> to another: <code>startTime</code>, <code>stopTime</code>. Once this is set up in X3D, from Pascal code, you only need to start the "main" <code>TimeSensor</code> by <code>Scene.PlayAnimation('MainTimeSensor', ...)</code>.

  <li><p>Also note that the <code>castle-anim-frames</code> file can be inserted into another model using the X3D <code>Inline</code> node. The <code>Inline</code> may be even under a transformation. You can still play the animations from the inlined <code>castle-anim-frames</code> (because internally we use X3D <code>EXPORT</code> mechanism). <a href="https://github.com/castle-engine/demo-models/blob/master/castle-anim-frames/simple/two_animations.x3dv">Here's an example how an X3D file uses Inline to insert castle-anim-frames inside.</a> So you can "compose" your files, e.g. store the human head as <code>castle-anim-frames</code>, and add it on top of a human body with <code>Inline</code>.
</ul>

<p>The important advice is that, no matter how complicated is your animation inside X3D graph, it's <i>worth to control each animation through a central <code>TimeSensor</code>, such that it can be controlled easily as a single animation</i>. This makes the <code>TCastleSceneCore.PlayAnimation</code> method useful for you to control your animations. This way the complexity of the animation system can be hidden by the engine. Even if the X3D graph is complicated, you just run a trivial <code>TCastleSceneCore.PlayAnimation</code> method.

<p>Note that some other higher-level engine routines have the same "concept" of animations as <?php echo cgeRef('TCastleSceneCore.PlayAnimation'); ?>. These include
<?php echo cgeRef('TCastleSceneCore.AnimationDuration'); ?>,
<?php echo cgeRef('TCastleSceneCore.ForceAnimationPose'); ?>,
<?php echo cgeRef('TCastleSceneCore.HasAnimation'); ?>.
All these engine methods are capable of handling all the animation types
described on this page.

<?php echo $toc->html_section(); ?>

<p>The supported X3D nodes from the "Interpolation" component are listed below.
Moreover, see also <?php echo a_href_page('Castle Game Engine (and view3dscene) extensions related to the interpolation','x3d_implementation_interpolation_extensions'); ?>.

<ul>
  <li><p><?php echo x3d_node_link('ColorInterpolator'); ?> - Animate color change.

    <p>The colors between keyframes are calculated by interpolation in the HSV space.</p>

  <li><p><?php echo x3d_node_link('PositionInterpolator'); ?> - Animate 3D vector (like position) change.
  <li><p><?php echo x3d_node_link('PositionInterpolator2D'); ?> - Animate 2D vector (like 2D position) change.
  <li><p><?php echo x3d_node_link('ScalarInterpolator'); ?> - Animate changing a single floating-point value.
  <li><p><?php echo x3d_node_link('OrientationInterpolator'); ?> - Animate a rotation.

    <p>The rotations between keyframes go through
    the shortest path on a conceptual unit sphere, with constant velocity.</p>

    <i>Warning: Never define two consecutive key frames such that the model would point in exactly the opposite directions</i>. In this case it is undefined how exactly the model with rotate, since there are many possible rotations that achieve the necessary transition. The X3D specification explicitly says that this is undefined (<i>"""The results are undefined if the two orientations are diagonally opposite."""</i>).

    <p>This is an often mistake when defining a rotation for model to spin in a loop. It is tempting to define it using 3 keyframes:

    <ol>
      <li><p>initial rotation,
      <li><p>rotation by 180 degrees (by pi, i.e. 3.14),
      <li><p>rotation by 360 degrees (2 * pi, 6.28, that brings model back to original orientation)
    </ol>

    <p>Like this:

<?php echo vrmlx3d_highlight(
'# THIS IS AN INCORRECT EXAMPLE, RESULTS ARE UNDEFINED!
OrientationInterpolator {
  key [
    0, 0.5, 1,
  ]
  keyValue [
    0 1 0 0,
    0 1 0 3.14,
    0 1 0 6.28,
  ]
}'); ?>

    <p>The above is not correct, i.e. it is not precisely defined. Instead of a spinning model, you may see a model that spins by 180 degrees in one direction, then spins by 180 degrees back (since this also satisifies the given key frames).

    <p>The solution is to use more key frames. Instead of 1 intermediate key frame (<code>[0, pi, 2*pi]</code>), use at least 2 intermediate key frames (<code>[0, 2/3*pi, 4/3*pi, 2*pi]</code>). Often 3 intermediate keyframes (<code>[0, pi/2, pi, 1.5*pi, 2*pi]</code>) are most comfortable to define.

  <li><p><?php echo x3d_node_link('CoordinateInterpolator'); ?> - Animate a set of 3D vectors (like coordinates of a mesh).
  <li><p><?php echo x3d_node_link('CoordinateInterpolator2D'); ?> - Animate a set of 2D vectors.
  <li><p><?php echo x3d_node_link('NormalInterpolator'); ?> - Animate a set of 3D directions.

    <p><i>TODO</i>: Interpolation of <code>NormalInterpolator</code> simply interpolates
    3D vectors (and normalizes afterwards), instead of
    a nice interpolation on the unit sphere.</p>
</ul>

<p><i>TODO</i>: Nodes from the X3D standard not implemented yet: EaseInEaseOut, Spline*, SquadOrientationInterpolator.</p>

<?php
  castle_footer();
?>
