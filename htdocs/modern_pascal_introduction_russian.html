<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.18">
<meta name="author" content="Michalis Kamburelis">
<title>Краткое введение в современный Object Pascal для программистов</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>
/*! Stylesheet for CodeRay to loosely match GitHub themes | MIT License */
pre.CodeRay{background:#f7f7f8}
.CodeRay .line-numbers{border-right:1px solid;opacity:.35;padding:0 .5em 0 0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
.CodeRay span.line-numbers{display:inline-block;margin-right:.75em}
.CodeRay .line-numbers strong{color:#000}
table.CodeRay{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.CodeRay td{vertical-align:top;line-height:inherit}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.code{padding:0 0 0 .75em}
.CodeRay .debug{color:#fff!important;background:navy!important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:navy}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:teal}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:teal}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:teal}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword{color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:teal}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
<style>.patreon-link {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size: 14px;
  line-height: 35px;
  padding-bottom: 10px;
  padding-left: 15px;
  padding-right: 15px;
  padding-top: 10px;
  text-decoration: none;
  text-align: left;
  float: right;
}
/*
a.patreon-link:hover,
a.patreon-link:focus {
  color: black;
  background: #EEE;
}
*/
</style></head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Краткое введение в современный Object Pascal для программистов</h1>
<div class="details">
<span id="author" class="author">Michalis Kamburelis</span><br>
</div>
<a href="https://patreon.com/castleengine" class="navbar-link patreon-link" style="display: inline-block; background-color: #FF424D; border-radius: 0; text-align: center;">
  <div style="color: #ffffff; padding-left: 1em; padding-right: 1em;">
    <span style="vertical-align: middle;">Support&nbsp;us&nbsp;on</span>&nbsp;<img src="patreon-wordmark.png" alt="Patreon Wordmark" style="display: inline-block; vertical-align: middle;" width="80" height="16">
  </div>
</a>
<div id="toc" class="toc2">
<div id="toctitle">Содержание</div>
<ul class="sectlevel1">
<li><a href="#_введение_для_чего_это_нужно">1. Введение: Для чего это нужно?</a></li>
<li><a href="#_основы">2. Основы</a>
<ul class="sectlevel2">
<li><a href="#_программа_hello_world">2.1. Программа "Hello world!"</a></li>
<li><a href="#_функции_процедуры_простейшие_типы">2.2. Функции, процедуры, простейшие типы</a></li>
<li><a href="#_условные_операторы_if">2.3. Условные операторы (if)</a></li>
<li><a href="#_логические_операторы_операторы_отношений_и_побитовые_поразрядные_операторы">2.4. Логические операторы, операторы отношений и побитовые (поразрядные) операторы</a></li>
<li><a href="#_проверка_одного_выражения_на_множественные_значения_оператор_case">2.5. Проверка одного выражения на множественные значения (оператор case)</a></li>
<li><a href="#_перечисляемый_и_порядковый_типы_наборы_и_массивы_постоянной_длины">2.6. Перечисляемый и порядковый типы, наборы и массивы постоянной длины</a></li>
<li><a href="#_циклы_for_while_repeat_for_in">2.7. Циклы (for, while, repeat, for .. in)</a></li>
<li><a href="#_вывод_информации_и_логов">2.8. Вывод информации и логов</a></li>
<li><a href="#_преобразование_данных_в_строчный_тип">2.9. Преобразование данных в строчный тип</a></li>
</ul>
</li>
<li><a href="#_модули_unit_ы">3. Модули (Unit-ы)</a>
<ul class="sectlevel2">
<li><a href="#_перекрёстные_ссылки_между_unit_ами">3.1. Перекрёстные ссылки между unit-ами</a></li>
<li><a href="#_определение_идентификаторов_с_указанием_имени_unit_а">3.2. Определение идентификаторов с указанием имени unit-а</a></li>
<li><a href="#_передача_идентификаторов_одного_unit_а_через_другой">3.3. Передача идентификаторов одного unit-а через другой</a></li>
</ul>
</li>
<li><a href="#_классы">4. Классы</a>
<ul class="sectlevel2">
<li><a href="#_основы_2">4.1. Основы</a></li>
<li><a href="#_наследование_inheritance_проверка_is_и_приведение_типов_as">4.2. Наследование (Inheritance), проверка (is), и приведение типов (as)</a></li>
<li><a href="#_свойства">4.3. Свойства</a>
<ul class="sectlevel3">
<li><a href="#_сериализация_serialization_свойств">4.3.1. Сериализация (Serialization) свойств</a></li>
</ul>
</li>
<li><a href="#_исключения">4.4. Исключения</a></li>
<li><a href="#_уровни_видимости">4.5. Уровни видимости</a></li>
<li><a href="#_предок_по_умолчанию">4.6. Предок по умолчанию</a></li>
</ul>
</li>
<li><a href="#_освобождение_памяти_классов">5. Освобождение памяти классов</a>
<ul class="sectlevel2">
<li><a href="#_всегда_необходимо_освобождать_экземпляры_класса">5.1. Всегда необходимо освобождать экземпляры класса</a></li>
<li><a href="#_каким_образом_освобождать_память">5.2. Каким образом освобождать память</a></li>
<li><a href="#_ручное_и_автоматическое_освобождение_памяти">5.3. Ручное и автоматическое освобождение памяти</a></li>
<li><a href="#_free_notification">5.4. Free notification</a></li>
</ul>
</li>
<li><a href="#_run_time_library">6. Run-time library</a>
<ul class="sectlevel2">
<li><a href="#_вводвывод_с_помощью_потоков">6.1. Ввод/вывод с помощью потоков</a></li>
<li><a href="#_списки">6.2. Списки</a></li>
<li><a href="#_клонирование_классов_tpersistent_assign">6.3. Клонирование классов: TPersistent.Assign</a></li>
</ul>
</li>
<li><a href="#_различные_полезные_возможности_языка">7. Различные полезные возможности языка</a>
<ul class="sectlevel2">
<li><a href="#_местные_вложенные_процедуры">7.1. Местные (вложенные) процедуры</a></li>
<li><a href="#Callbacks">7.2. Колбэки&#8201;&#8212;&#8201;они же события, они же указатели на функции, они же процедурные переменные</a></li>
<li><a href="#_generic_и">7.3. Generic-и</a></li>
<li><a href="#_overload">7.4. Overload</a></li>
<li><a href="#_предобработка_кода">7.5. Предобработка кода</a></li>
<li><a href="#_record">7.6. Record</a></li>
<li><a href="#_устаревшие_object">7.7. Устаревшие object</a></li>
<li><a href="#_pointer_ы">7.8. Pointer-ы</a></li>
<li><a href="#_перегрузка_операторов">7.9. Перегрузка операторов</a></li>
</ul>
</li>
<li><a href="#_дополнительные_возможности_классов">8. Дополнительные возможности классов</a>
<ul class="sectlevel2">
<li><a href="#_различие_private_и_strict_private">8.1. Различие private и strict private</a></li>
<li><a href="#_дополнительные_возможности_объявления_классов_и_локальные_классы">8.2. Дополнительные возможности объявления классов и локальные классы</a></li>
<li><a href="#_class_method">8.3. Class method</a></li>
<li><a href="#_ссылки_на_класс">8.4. Ссылки на класс</a></li>
<li><a href="#_class_helper">8.5. Class helper</a></li>
<li><a href="#_виртуальные_constructor_ы_destructor_ы">8.6. Виртуальные constructor-ы, destructor-ы</a></li>
<li><a href="#_ошибки_при_исполнении_constructor_а">8.7. Ошибки при исполнении constructor-а</a></li>
</ul>
</li>
<li><a href="#_интерфейсы">9. Интерфейсы</a>
<ul class="sectlevel2">
<li><a href="#_хорошие_corba_интерфейсы">9.1. Хорошие (CORBA) интерфейсы</a></li>
<li><a href="#_corba_и_com_интерфейсы">9.2. CORBA и COM интерфейсы</a></li>
<li><a href="#_guid_ы_интерфейсов">9.3. GUID-ы интерфейсов</a></li>
<li><a href="#_некрасивые_com_интерфейсы">9.4. Некрасивые (COM) интерфейсы</a></li>
<li><a href="#_использование_com_интерфейсов_с_отключённым_reference_counting">9.5. Использование COM интерфейсов с отключённым reference-counting</a></li>
<li><a href="#_приведение_типов_интерфейсов">9.6. Приведение типов интерфейсов</a></li>
</ul>
</li>
<li><a href="#_про_этот_документ">10. Про этот документ</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_введение_для_чего_это_нужно">1. Введение: Для чего это нужно?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В мире существует множество книг о Паскале, однако, многие из них говорят об "устаревшем" Паскале, без классов, модулей, generic-ов (дженериков) и многих других современных методов и приёмов программирования.</p>
</div>
<div class="paragraph">
<p>С целью заполнения этой бреши и было написано это краткое введение о том, что часто называется <strong>современным объектным Паскалем</strong>. Чаще его называют просто <em>"Паскаль"</em> или <em>"Наш Паскаль"</em>.
Впрочем, представляя язык, важно подчеркнуть, что это современный, объектно-ориентированный язык, который был <strong>существенно</strong> усовершенствован по сравнению со старым (Turbo) Pascal, который когда-то давно изучали в школах и институтах. Сегодня его вполне можно сравнивать с такими известными языками программирования, как C++, Java или C#.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Паскаль имеет все современные особенности, которые можно ожидать -- классы, модульную структуру, интерфейсы, generic-и&#8230;&#8203;</p>
</li>
<li>
<p>Паскаль компилируется в быстрый машинный код.</p>
</li>
<li>
<p>Паскаль является типобезопасным языком, что в некоторых случаях существенно упрощает отладку.</p>
</li>
<li>
<p>В основном Паскаль - высокоуровневый язызк, однако он имеет возможность использовать низкоуровневые подходы если это необходимо.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Он так же имеет превосходный кроссплатформенный портативный компилятор с открытым исходным кодом: <em>Free Pascal Compiler</em> (<a href="http://freepascal.org/" class="bare">http://freepascal.org/</a>). Для него существует несколько IDE (включающих в себя редактор, отладчик, библиотеки компонентов, дизайнер форм), одна из наиболее известных называется <em>Lazarus</em> (<a href="http://lazarus.freepascal.org/" class="bare">http://lazarus.freepascal.org/</a>). Автора данной книги является создателем <em>Castle Game Engine</em> (<a href="https://castle-engine.io/" class="bare">https://castle-engine.io/</a>) - который является мощным портативным двух- и трёхмерным игровым движком, использующим этот язык, для создания игр под многие платформы: Windows, Linux, MacOSX, Android, iOS, web плагины.</p>
</div>
<div class="paragraph">
<p>Данное краткое введение в первую очередь ориентировано на программистов, которые уже имеют некоторый опыт в других языках программирования. Здесь не будет раскрываться значение некоторых универсальных концепций, таких как <em>"что такое класс"</em>, лишь будет показано как они реализуются в современном Паскале.</p>
</div>
<div class="paragraph">
<p><em>Прим.перев. Здесь и далее мы будем использовать оригинальные английские понятия такие как unit, constructor, override, reference-counting в случаях, если они являются ключевыми словами языка либо не имеют общепринятых переводов на русский язык. Также часто предпочитается использовать оригинальное английское слово его транслитерации, как в случае с понятием "generic" выше.</em></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_основы">2. Основы</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_программа_hello_world">2.1. Программа "Hello world!"</h3>
<div class="paragraph">
<p>По доброй традиции знакомство с языком начинают с самой базовой и простой программы "Hello world". На Паскале она выглядит следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span> <span class="comment">// Эту строку необходимо использовать во всех современных программах</span>

<span class="keyword">program</span> MyProgram; <span class="comment">// Сохраните этот файл под названием myprogram.lpr</span>
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Hello world!</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это&#8201;&#8212;&#8201;полноценная программа, которую можно <em>скомпилировать</em> и <em>запустить</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Это можно сделать с помощью командной строки FPC, просто создав новый файл <code>myprogram.lpr</code> с кодом программы внутри и выполнив команду <code>fpc myprogram.lpr</code>.</p>
</li>
<li>
<p>Если используется <em>Lazarus</em>, то необходимо создать новый проект (в строке меню: <em>Project</em> &#8594; <em>New Project</em> &#8594; <em>Simple Program</em>). Сохраните его как <code>myprogram</code> и скопируйте в него этот исходный код. Компиляция выполняется используя пункт <em>Run</em> → <em>Compile</em> в меню.</p>
</li>
<li>
<p>Данная программа является консольной, то есть, в обоих случаях скомпилированный исполняемый файл нужно будет запустить из терминала командной строки, чтобы увидеть результат.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Остальная часть этой книги рассказывает о самом объектном Паскале, поэтому не ожидайте чего-либо большего, чем консольных приложений. Если хочется взглянуть на что-либо более "крутое", можно просто создать новый GUI проект в <em>Lazarus</em> (<em>Project</em> &#8594; <em>New Project</em> &#8594; <em>Application</em>).
Вуаля!&#8201;&#8212;&#8201;рабочее кроссплатформенное GUI приложение, с нативным видом, использующее удобные визуальные библиотеки. <em>Lazarus</em> и <em>Free Pascal Compiler</em> имеют множество готовых компонент для сетей, GUI, баз данных, чтения и записи различных форматов файлов (XML, json, изображения&#8230;&#8203;), управления потоками и всем, что только может понадобиться программисту. Ярким тому примером является <em>Castle Game Engine</em>, о котором упоминалось ранее :)</p>
</div>
</div>
<div class="sect2">
<h3 id="_функции_процедуры_простейшие_типы">2.2. Функции, процедуры, простейшие типы</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>

<span class="keyword">program</span> MyProgram;

<span class="keyword">procedure</span> MyProcedure(<span class="keyword">const</span> A: Integer);
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">A + 10 составляет: </span><span class="delimiter">'</span></span>, A + <span class="integer">10</span>);
<span class="keyword">end</span>;

<span class="keyword">function</span> MyFunction(<span class="keyword">const</span> S: <span class="keyword">string</span>): <span class="keyword">string</span>;
<span class="keyword">begin</span>
  Result := S + <span class="string"><span class="delimiter">'</span><span class="content">строки управляются автоматически</span><span class="delimiter">'</span></span>;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  X: Single;
<span class="keyword">begin</span>
  WriteLn(MyFunction(<span class="string"><span class="delimiter">'</span><span class="content">примечание: </span><span class="delimiter">'</span></span>));
  MyProcedure(<span class="integer">5</span>);

  <span class="comment">// деление с помощью оператора &quot;/&quot; всегда даёт результат с плавающей запятой</span>
  <span class="comment">// для целочисленного деления необходимо использовать &quot;div&quot;</span>
  X := <span class="integer">15</span> / <span class="integer">5</span>;
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">X составляет: </span><span class="delimiter">'</span></span>, X); <span class="comment">// отобразить в научном формате вида 3.0000000E+000</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">X составляет: </span><span class="delimiter">'</span></span>, X:<span class="integer">1</span>:<span class="integer">2</span>); <span class="comment">// отобразить 2 знака после запятой</span>
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы задать возвращаемое значение функции, необходимо присвоить какое-либо значение "волшебной" переменной <code>Result</code> в процессе выполнения функции. Её можно свободно читать и устанавливать новое значение так же просто как и любую локальную переменную.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">function</span> MyFunction(<span class="keyword">const</span> S: <span class="keyword">string</span>): <span class="keyword">string</span>;
<span class="keyword">begin</span>
  Result := S + <span class="string"><span class="delimiter">'</span><span class="content"> Добавим что-нибудь</span><span class="delimiter">'</span></span>;
  Result := Result + <span class="string"><span class="delimiter">'</span><span class="content"> и ещё что-нибудь!</span><span class="delimiter">'</span></span>;
  Result := Result + <span class="string"><span class="delimiter">'</span><span class="content"> И ещё немножко!</span><span class="delimiter">'</span></span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Можно рассматривать имя функции (<code>MyFunction</code> в примере выше) как переменную, которую можно использовать как самую обычную переменную. Но лично я бы не советовал так делать, поскольку это выглядит не очень "прозрачно", особенно в случае, если это значение используется с правой стороны выражения. Лучше всегда использовать <code>Result</code>, в случае, если необходимо использовать или устанавливать возвращаемое значение функции.</p>
</div>
<div class="paragraph">
<p>Естественно, при необходимости можно вызывать функцию рекурсивно. Но при этом в случае, если вызывается беспараметрическая функция, следует не забывать указать пустые скобки <code>()</code> (которые в обычных случаях в Паскале можно опускать) - иначе будет просто выполнен доступ к результату текущей функции. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">function</span> ReadIntegersUntilZero: <span class="keyword">string</span>;
<span class="keyword">var</span>
  I: Integer;
<span class="keyword">begin</span>
  Readln(I);
  Result := IntToStr(I);
  <span class="keyword">if</span> I &lt;&gt; <span class="integer">0</span> <span class="keyword">then</span>
    Result := Result + <span class="char"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span> + ReadIntegersUntilZero();
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функция <code>Exit</code> служит для завершения выполнения процедуры или функции до того, как она достигнет завершающего <code>end;</code>. Если <code>Exit</code> вызвать без параметров, она вернёт последнее значение, присвоенное <code>Result</code>. Так же можно использовать конструкцию <code>Exit(X)</code>, чтобы установить результат функции и завершить её исполнение <strong>немедленно</strong> — это эквивалентно конструкции <code>return X</code> в С-подобных языках.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">function</span> AddName(<span class="keyword">const</span> ExistingNames, NewName: <span class="keyword">string</span>): <span class="keyword">string</span>;
<span class="keyword">begin</span>
  <span class="keyword">if</span> ExistingNames = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span> <span class="keyword">then</span>
    Exit(NewName);
  Result := ExistingNames + <span class="string"><span class="delimiter">'</span><span class="content">, </span><span class="delimiter">'</span></span> + NewName;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание, что результат функции может быть "проигнорирован" (отброшен). Любую функцию можно вызвать как обычную процедуру. Делать так имеет смысл если функция выполняет некоторые <em>побочные операции</em> (например, изменяет глобальные переменные), а не просто вычисляет некоторый результат. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  Count: Integer;
  MyCount: Integer;

<span class="keyword">function</span> CountMe: Integer;
<span class="keyword">begin</span>
  Inc(Count);
  Result := Count;
<span class="keyword">end</span>;

<span class="keyword">begin</span>
  Count := <span class="integer">10</span>;
  CountMe; <span class="comment">// результат функции будет отброшен, однако функция выполняется, Count станет равен 11.</span>
  MyCount := CountMe; <span class="comment">// запоминаем результат выполнения функции будет, Count теперь 12.</span>
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_условные_операторы_if">2.3. Условные операторы (if)</h3>
<div class="paragraph">
<p>Конструкции <code>if .. then</code> или <code>if .. then .. else</code> запускают определённый код, когда выполняется указанное условие. В отличии от C-подобных языков, в Паскале нет строгого требования ставить условие в скобки.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  A: Integer;
  B: boolean;
<span class="keyword">begin</span>
  <span class="keyword">if</span> A &gt; <span class="integer">0</span> <span class="keyword">then</span>
    DoSomething;

  <span class="keyword">if</span> A &gt; <span class="integer">0</span> <span class="keyword">then</span>
  <span class="keyword">begin</span>
    DoSomething;
    AndDoSomethingMore;
  <span class="keyword">end</span>;

  <span class="keyword">if</span> A &gt; <span class="integer">10</span> <span class="keyword">then</span>
    DoSomething
  <span class="keyword">else</span>
    DoSomethingElse;

  <span class="comment">// идентично предыдущему примеру</span>
  B := A &gt; <span class="integer">10</span>;
  <span class="keyword">if</span> B <span class="keyword">then</span>
    DoSomething
  <span class="keyword">else</span>
    DoSomethingElse;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Оператор <code>else</code> всегда относится только к последнему условию <code>if</code>. Поэтому можно вполне рассчитывать на однозначность выполнения такого кода:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> A &lt;&gt; <span class="integer">0</span> <span class="keyword">then</span>
  <span class="keyword">if</span> B &lt;&gt; <span class="integer">0</span> <span class="keyword">then</span>
    AIsNonzeroAndBToo
  <span class="keyword">else</span>
    AIsNonzeroButBIsZero;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Впрочем, заключение вложенного <code>if</code> внутри блока <code>begin &#8230;&#8203; end;</code> является лучшим вариантом, чем предыдущий пример, поскольку он более читабельный, даже если нарушены отступы или большой объём кода и комментариев затрудняет понимание. Таким образом, всегда очевидно к какому <code>if</code> относится данный <code>else</code> - относительно A или относительно B - и, соответственно, куда меньше шансов допустить ошибку при написании кода или при его правках.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> A &lt;&gt; <span class="integer">0</span> <span class="keyword">then</span>
<span class="keyword">begin</span>
  <span class="keyword">if</span> B &lt;&gt; <span class="integer">0</span> <span class="keyword">then</span>
    AIsNonzeroAndBToo
  <span class="keyword">else</span>
    AIsNonzeroButBIsZero;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_логические_операторы_операторы_отношений_и_побитовые_поразрядные_операторы">2.4. Логические операторы, операторы отношений и побитовые (поразрядные) операторы</h3>
<div class="paragraph">
<p><em>Логические операторы</em> представлены в Паскале операторами <code>and</code>, <code>or</code>, <code>not</code>, <code>xor</code>. Их значение в большинстве случаев очевидно для людей, знакомых с компьютерной грамотой. Разве что, за исключением оператора <code>xor</code>, который в русской литературе обычно называется <em>"исключающее или"</em>. Эти операторы принимают <em>булевские аргументы (boolean)</em>, и возвращаемое значение имеет тот же тип <em>boolean</em>. Они также могут работать как <em>побитовые операторы</em>, в случае, если оба аргумента целого типа (integer, byte или подобные), в этом случае они также возвращают значение идентичного целого типа.</p>
</div>
<div class="paragraph">
<p><em>Операторы отношения (сравнения)</em> - представлены следующими комбинациями символов: <code>=</code>, <code>&lt;&gt;</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, значение которых вполне очевидно. Следует отметить, что в отличии от синтаксиса С-подобных языков, в Паскале оператор сравнения выглядит как один знак "равно" <code>A = B</code> (в отличии от С, где используется код <code>A == B</code>). Специальным <em>оператором присваивания</em> в Паскале является <code>:=</code>.</p>
</div>
<div class="paragraph">
<p><em>Логический (или побитовый) оператор имеет более высокий приоритет, чем операторы отношения</em>. Поэтому, может понадобиться использовать круглые скобки вокруг сравниваемых выражений для указания правильного порядка выполнения операторов.</p>
</div>
<div class="paragraph">
<p>Следующий пример вызовет ошибку компиляции:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  A, B: Integer;
<span class="keyword">begin</span>
  <span class="keyword">if</span> A = <span class="integer">0</span> <span class="keyword">and</span> B &lt;&gt; <span class="integer">0</span> <span class="keyword">then</span> ... <span class="comment">// так делать НЕЛЬЗЯ</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Ошибка связана с тем, что компилятор в первую очередь пытается выполнить побитовый оператор <code>and</code> в середине выражения. В результате получается <code>(0 and B)</code> - побитная операция, возвращающая целочисленную величину. Далее компилятор выполняет оператор "равно" и получает булевскую величину <code>A = (0 and B)</code>. И в конце концов появляется ошибка <em>type mismatch</em>, в результате попытки сравнения булевской величины <code>A = (0 and B)</code> с целочисленной величиной <code>0</code>.</p>
</div>
<div class="paragraph">
<p>Правильно записывать это условие в следующем виде:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  A, B: Integer;
<span class="keyword">begin</span>
  <span class="keyword">if</span> (A = <span class="integer">0</span>) <span class="keyword">and</span> (B &lt;&gt; <span class="integer">0</span>) <span class="keyword">then</span> ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Паскаль использует <em>"короткую оценку (short-circuit evaluation)"</em> - мощную оптимизацию, позволяющую не вычислять выражение целиком, если какая-либо его часть полностью определяет результат. Рассмотрим пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> MyFunction(X) <span class="keyword">and</span> MyOtherFunction(Y) <span class="keyword">then</span>...</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Значение функции <code>MyFunction(X)</code> всегда рассчитывается первым.</p>
</li>
<li>
<p>И если <code>MyFunction(X)</code> вернёт значение <code>false</code>, это означает, что мы уже знаем результат всего выражения - какое бы ни было второе значение, при выполнении <code>false and что-нибудь</code> мы всегда получим <code>false</code>. Таким образом <code>MyOtherFunction(Y)</code> вообще не будет выполняться.</p>
</li>
<li>
<p>Идентичная ситуация и с выражением <code>or</code>. В данном случае, если мы наперёд знаем, что результат будет <code>true</code> потому что первый аргумент имеет значение <code>true</code>, второй аргумент не влияет на результат и не будет рассчитываться.</p>
</li>
<li>
<p>Это особенно полезно если нужно записать выражение типа:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> (A &lt;&gt; <span class="keyword">nil</span>) <span class="keyword">and</span> A.IsValid <span class="keyword">then</span>...</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае не возникнет ошибки даже в случае если <code>A</code> имеет значение <code>nil</code>. Ключевое слово <code>nil</code> это указатель, который в численном представлении указывает на "нулевой" адрес. Во многих языках программирования он называется <em>нулевым указателем</em> (<em>null pointer</em>).</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_проверка_одного_выражения_на_множественные_значения_оператор_case">2.5. Проверка одного выражения на множественные значения (оператор case)</h3>
<div class="paragraph">
<p>Если в зависимости от разных значений определённого выражения должны быть выполнены разные действия, тогда может оказаться удобной конструкция <code>case .. of .. end</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">case</span> SomeValue <span class="keyword">of</span>
  <span class="integer">0</span>: DoSomething;
  <span class="integer">1</span>: DoSomethingElse;
  <span class="integer">2</span>: <span class="keyword">begin</span>
       IfItsTwoThenDoThis;
       AndAlsoDoThis;
     <span class="keyword">end</span>;
  <span class="integer">3</span>..<span class="integer">10</span>: DoSomethingInCaseItsInThisRange;
  <span class="integer">11</span>, <span class="integer">21</span>, <span class="integer">31</span>: AndDoSomethingForTheseSpecialValues;
  <span class="keyword">else</span> DoSomethingInCaseOfUnexpectedValue;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Условие <code>else</code> опционально (и соответствует <code>default</code> в C-подобных языках). В случае, если текущее значение анализируемого выражения не совпадает ни с одним из описанных случаев и нет условия <code>else</code>, то программа просто пропустит всю конструкцию <code>case</code> и будет выполняться далее.</p>
</div>
<div class="paragraph">
<p>Программисты С-подобных языков могут сравнить <code>case</code> с весьма подобной конструкцией <code>switch</code> в этих языках. Стоит отметить, что <code>case</code> в Паскале защищён от случайного выполнения следующей инструкции, т.е. нет необходимости уделять внимание тому, чтобы размещать инструкцию <code>break</code> в конце каждого блока. После выполнения ветви условия программа автоматически закончит обработку конструкции <code>case</code> и продолжит работу далее.</p>
</div>
</div>
<div class="sect2">
<h3 id="_перечисляемый_и_порядковый_типы_наборы_и_массивы_постоянной_длины">2.6. Перечисляемый и порядковый типы, наборы и массивы постоянной длины</h3>
<div class="paragraph">
<p>Перечисляемый тип (enumerated) в Паскале является очень удобным и прозрачным. Возможно, Вам он понравится и Вы будете использовать его чаще чем перечисляемые типы в других языках :)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TAnimalKind = (akDuck, akCat, akDog);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Общепринято, что префикс перечисляемого типа состоит из двух букв сокращения имени типа, следовательно <code>ak</code> = сокращение для <em>"Animal Kind"</em>. Это полезное соглашение, так как имена перечисляемых типов находятся в глобальном пространстве переменных unit-а. Таким образом, с помощью префикса <code>ak</code> автоматически уменьшаются шансы на случайный конфликт с другими идентификаторами.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
Конфликты в именах не приводят к неработоспособности программы. Вполне допустимо в различных unit-ах определять одинаковые идентификаторы. Однако, желательно избегать подобных конфликтов везде, где это возможно, чтобы код был прост для понимания и анализа.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
Можно избежать попадания имён перечисляемых типов в глобальное пространство с помощью директивы компилятора <code>{$scopedenums on}</code>. В таком варианте будет необходимо обращаться к ним через имя типа следующим образом: <code>TAnimalKind.akDuck</code>. В результате отпадает необходимость в префиксе <code>ak</code>, и можно просто оставить исходные названия <code>Duck, Cat, Dog</code>. Такое исполнение подобно тому, как работают перечисляемые списки в C#.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><em>Прозрачность</em> перечисляемого типа означает, что он не совместим напрямую с целочисленными величинами. Тем не менее, если такая совместимость необходима, можно использовать <code>Ord(MyAnimalKind)</code>, чтобы вручную привести список к целочисленному типу. Обратная операция будет выглядеть как приведение типа <code>TAnimalKind(MyInteger)</code> и превратит целое число в соответствующий перечисляемый тип. В последнем случае необходимо также быть уверенным, что <code>MyInteger</code> является частью диапазона от <code>0</code> до <code>Ord(High(TAnimalKind)))</code>.</p>
</div>
<div class="paragraph">
<p>Перечисляемые типы могут быть также использованы в качестве индексов массивов фиксированной длины:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TArrayOfTenStrings = <span class="keyword">array</span> [<span class="integer">0</span>..<span class="integer">9</span>] <span class="keyword">of</span> <span class="keyword">string</span>;
  TArrayOfTenStrings1Based = <span class="keyword">array</span> [<span class="integer">1</span>..<span class="integer">10</span>] <span class="keyword">of</span> <span class="keyword">string</span>;

  TMyNumber = <span class="integer">0</span>..<span class="integer">9</span>;
  TAlsoArrayOfTenStrings = <span class="keyword">array</span> [TMyNumber] <span class="keyword">of</span> <span class="keyword">string</span>;

  TAnimalKind = (akDuck, akCat, akDog);
  TAnimalNames = <span class="keyword">array</span> [TAnimalKind] <span class="keyword">of</span> <span class="keyword">string</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Они также могут использоваться для создания наборов (они же set-ы, они же внутренние битовые поля):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TAnimalKind = (akDuck, akCat, akDog);
  TAnimals = <span class="keyword">set</span> <span class="keyword">of</span> TAnimalKind;
<span class="keyword">var</span>
  A: TAnimals;
<span class="keyword">begin</span>
  A := [];
  A := [akDuck, akCat];
  A := A + [akDog];
  A := A * [akCat, akDog];
  Include(A, akDuck);
  Exclude(A, akDuck);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_циклы_for_while_repeat_for_in">2.7. Циклы (for, while, repeat, for .. in)</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="preprocessor">{$R+}</span> <span class="comment">// включаем проверку на диапазон величин, очень полезно для отладки</span>
<span class="keyword">var</span>
  MyArray: <span class="keyword">array</span> [<span class="integer">0</span>..<span class="integer">9</span>] <span class="keyword">of</span> Integer;
  I: Integer;
<span class="keyword">begin</span>
  <span class="comment">// инициализация</span>
  <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> <span class="integer">9</span> <span class="keyword">do</span>
    MyArray[I] := I * I;

  <span class="comment">// отображение</span>
  <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> <span class="integer">9</span> <span class="keyword">do</span>
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Квадрат составляет </span><span class="delimiter">'</span></span>, MyArray[I]);

  <span class="comment">// делает то же самое, что и предыдущий вариант</span>
  <span class="keyword">for</span> I := Low(MyArray) <span class="keyword">to</span> High(MyArray) <span class="keyword">do</span>
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Квадрат составляет </span><span class="delimiter">'</span></span>, MyArray[I]);

  <span class="comment">// делает то же самое</span>
  I := <span class="integer">0</span>;
  <span class="keyword">while</span> I &lt; <span class="integer">10</span> <span class="keyword">do</span>
  <span class="keyword">begin</span>
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Квадрат составляет </span><span class="delimiter">'</span></span>, MyArray[I]);
    I := I + <span class="integer">1</span>; <span class="comment">// это идентично &quot;I += 1&quot; или &quot;Inc(I)&quot;</span>
  <span class="keyword">end</span>;

  <span class="comment">// делает то же самое</span>
  I := <span class="integer">0</span>;
  <span class="keyword">repeat</span>
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Квадрат составляет </span><span class="delimiter">'</span></span>, MyArray[I]);
    Inc(I);
  <span class="keyword">until</span> I = <span class="integer">10</span>;

  <span class="comment">// делает то же самое</span>
  <span class="comment">// обратите внимание, тут переменная I перечисляет значения элементов массива, а не его индексы</span>
  <span class="keyword">for</span> I <span class="keyword">in</span> MyArray <span class="keyword">do</span>
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Квадрат составляет </span><span class="delimiter">'</span></span>, I);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Примечания:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Может показаться, что различие между циклами <code>while</code> и <code>repeat</code> лишь "косметические" с единственным отличием, что условие записано "с точностью до наоборот": в случае <code>while .. do</code> выполнение <em>продолжается</em>, пока условие <em>истинно</em>, а при <code>repeat .. until</code> - выполнение <em>прекращается</em>, когда условие <em>истинно</em>. Впрочем, есть ещё одно важное отличие: в случае <code>repeat</code>, условие проверяется не <em>в начале</em>, а <em>в конце</em> цикла. Поэтому содержимое цикла <code>repeat</code> всегда выполняется как минимум один раз.</p>
</li>
<li>
<p>Конструкция <code>for I := .. to .. do &#8230;&#8203;</code> похожа на C-подобный цикл <code>for</code>. Тем не менее, она более ограничена, поскольку невозможно указать произвольное действие/условие чтобы контролировать итерации цикла. В Паскале <code>for</code> используется строго для итерации через последовательные числа (или другие порядковые типы). Единственной уступкой является возможность использования <code>downto</code> вместо <code>to</code>, чтобы производить счёт в обратном порядке.</p>
<div class="paragraph">
<p>С другой стороны, это существенно облегчает понимание кода, и лучше для оптимизации в его исполнении. Например, <em>значения верхней и нижней границы вычисляются лишь один раз</em>, до начала исполнения цикла.</p>
</div>
<div class="paragraph">
<p>Следует также обратить внимание, что переменная, которая использовалась для цикла (в примере выше - <code>I</code>) становится неопределённой после окончания цикла кроме случая досрочного выхода из цикла с помощью команд <code>Break</code> или <code>Exit</code>.
Цикл <code>for I in .. do ..</code> такой же как конструкция foreach в многих других языках и хорошо понимает организацию всех встроенных типов:</p>
</div>
</li>
<li>
<p>Он может перебирать все значения массива (см. пример выше).</p>
</li>
<li>
<p>Он может перебирать все возможные значения перечисляемого типа:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  AK: TAnimalKind;
<span class="keyword">begin</span>
  <span class="keyword">for</span> AK <span class="keyword">in</span> TAnimalKind <span class="keyword">do</span>...</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Он может перебирать все элементы набора:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  Animals: TAnimals;
  AK: TAnimalKind;
<span class="keyword">begin</span>
  Animals := [akDog, akCat];
  <span class="keyword">for</span> AK <span class="keyword">in</span> Animals <span class="keyword">do</span> ...</code></pre>
</div>
</div>
</li>
<li>
<p>И так же работает на всех пользовательских типах, включая generic-и, например, <code>TObjectList</code> или <code>TFPGObjectList</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils, FGL;

<span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
    I, Square: Integer;
  <span class="keyword">end</span>;
  TMyClassList = specialize TFPGObjectList&lt;TMyClass&gt;;

<span class="keyword">var</span>
  List: TMyClassList;
  C: TMyClass;
  I: Integer;
<span class="keyword">begin</span>
  List := TMyClassList.Create(true); <span class="comment">// значение true означает, что List владеет всеми дочерними объектами</span>
  <span class="keyword">try</span>
    <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> <span class="integer">9</span> <span class="keyword">do</span>
    <span class="keyword">begin</span>
      C := TMyClass.Create;
      C.I := I;
      C.Square := I * I;
      List.Add(C);
    <span class="keyword">end</span>;

    <span class="keyword">for</span> C <span class="keyword">in</span> List <span class="keyword">do</span>
      WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Квадрат </span><span class="delimiter">'</span></span>, C.I, <span class="string"><span class="delimiter">'</span><span class="content"> составляет </span><span class="delimiter">'</span></span>, C.Square);
  <span class="keyword">finally</span>
    FreeAndNil(List);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Мы ещё не рассматривали концепцию классов, поэтому последний пример может показаться неочевидным. Но мы обязательно рассмотрим этот вопрос чуть позже :)</p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_вывод_информации_и_логов">2.8. Вывод информации и логов</h3>
<div class="paragraph">
<p>Для простого вывода строки в Паскале используется процедура <code>Write</code> или <code>WriteLn</code>. Во втором случае в конце автоматически добавляется символ переноса строки.</p>
</div>
<div class="paragraph">
<p>Это "волшебная" процедура в Паскале, Она принимает переменное число аргументов, которые могут иметь практически любой тип. Они все будут автоматически сконвертированы в строчный тип при выводе. Кроме того, можно добавить специальный синтаксис для указания каким образом отформатировать число.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Hello world!</span><span class="delimiter">'</span></span>);
WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Можно вывести целое число: </span><span class="delimiter">'</span></span>, <span class="integer">3</span> * <span class="integer">4</span>);
WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Отформатировать его: </span><span class="delimiter">'</span></span>, <span class="integer">666</span>:<span class="integer">10</span>);
WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">А также вывести число с плавающей запятой: </span><span class="delimiter">'</span></span>, Pi:<span class="integer">1</span>:<span class="integer">4</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы явным образом добавить перенос строки можно использовать константу <code>LineEnding</code> (из библиотеки FPC RTL). (<em>Castle Game Engine</em> имеет также более краткий вариант <code>NL</code>). В отличии от HTML и других подобных синтаксисов разметок в Паскале обратная косая (<code>\</code>) не позволяет вставлять специальные символы в строке, например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Первая строка.\nВторая стока.</span><span class="delimiter">'</span></span>); <span class="comment">// НЕВЕРНЫЙ пример</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>не вставит перенос строки, а просто выдаст все символы этой строки в одной строчке. Правильно делать следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Первая строка.</span><span class="delimiter">'</span></span> + LineEnding + <span class="string"><span class="delimiter">'</span><span class="content">Вторая строка.</span><span class="delimiter">'</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>или так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Первая строка.</span><span class="delimiter">'</span></span>);
WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Вторая строка.</span><span class="delimiter">'</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Стоит отметить, что функции <code>Write</code>/<code>WriteLn</code> будут работать только в <em>консольных</em> приложениях. Для этого необходимо указывать <code>{$apptype CONSOLE}</code> (<strong>но не</strong> <code>{$apptype GUI}</code>) в главном файле программы. На некоторых ОС консоль явно или скрыто присутствует всегда (Unix) и эта директива не используется. А в некоторых системах попытка выполнения <code>Write</code>/<code>WriteLn</code> из GUI приложения приведёт к ошибке (например, в Windows).</p>
</div>
<div class="paragraph">
<p>В <strong>Castle Game Engine</strong> не советуется использовать <code>WriteLn</code>, поскольку для этого есть специальная функция <code>WriteLnLog</code> или <code>WriteLnWarning</code> для вывода логов и отладочной информации. Их результат всегда будет направлен в полезном направлении: для Unix-подобных систем это будет стандартный вывод в консоль. Для Windows GUI приложений это будет лог-файл. В Android вывод будет направлен в <em>Android logging facility</em> (инструмент логов Андроида), который можно просматривать с помощью команды <code>adb logcat</code>. Использовать <code>WriteLn</code> есть смысл лишь в ограниченном наборе случаев, например, для консольных приложений (исполняемых из командной строки) в которых можно быть точно уверенным, что <em>стандартный вывод</em> определён. Например, так можно делать в конвертере или генераторе трёхмерных моделей, который предназначен для запуска из командной строки.</p>
</div>
</div>
<div class="sect2">
<h3 id="_преобразование_данных_в_строчный_тип">2.9. Преобразование данных в строчный тип</h3>
<div class="paragraph">
<p>Для преобразования произвольного количества аргументов в строку (вместо того, чтобы напрямую выводить их в терминал консоли) есть несколько возможных подходов.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Некоторые конкретные типы можно преобразовать в строку используя специальные функции, такие как <code>IntToStr</code> и <code>FloatToStr</code>. В дальнейшем суммировать (concatenation) строки в Паскале можно просто используя знак сложения. Таким образом можно создавать составные строки: <code>'Моё целое число ' + IntToStr(MyInt) + ', а значение числа пи составляет ' + FloatToStr(Pi)</code>.</p>
<div class="ulist">
<ul>
<li>
<p><em>Преимущество</em>: это очень удобно. Существует множество готовых функций типа <code>XxxToStr</code> и им подобных (например, <code>FormatFloat</code>), для множества различных типов данных.</p>
</li>
<li>
<p><em>Второе преимущество</em>: они почти всегда имеют обратную функцию. Чтобы преобразовать строку (например, введённую пользователем) в целое или дробное число можно использовать <code>StrToInt</code>, <code>StrToFloat</code> и подобные (например, <code>StrToIntDef</code>).</p>
</li>
<li>
<p><em>Недостаток</em>: длинная сумма множества <code>XxxToStr</code> и строк выглядит некрасиво.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Функция <code>Format</code> используется в виде <code>Format('%d %f %s', [MyInt, MyFloat, MyString])</code>. Она подобна функции <code>sprintf</code> в C-подобных языках. Она вставляет аргументы в соответствующие placeholder-ы согласно заданному образцу. Эти placeholder-ы могут использовать специальный синтаксис, влияющий на форматирование, например <code>%.4f</code> это дробный формат с 4 знаками после запятой.</p>
<div class="ulist">
<ul>
<li>
<p><em>Преимущество</em>: отделение <em>строки</em> от <em>аргументов</em> выглядит чисто и красиво. Легко изменить текст строки, не изменяя аргументов, например, если необходимо выполнить перевод.</p>
</li>
<li>
<p><em>Второе преимущество</em>: не используются "волшебные" свойства компилятора. Можно использовать идентичный синтаксис для передачи произвольного количества аргументов произвольного типа в пользовательских процедурах (для этого определите принимаемый параметр как <code>array of const</code>). Затем можно передать эти аргументы функции <code>Format</code>, или разобрать на список параметров и делать с ним всё, что угодно.</p>
</li>
<li>
<p><em>Недостаток</em>: компилятор не проверяет, соответствует ли строка-образец аргументам. Используя неверный тип placeholder-а приведёт к ошибке <code>EConvertError</code>, впрочем, гораздо более понятной, чем segmentation fault (наиболее часто SIGSEGV).</p>
</li>
</ul>
</div>
</li>
<li>
<p>В Паскале также существует функция <code>WriteStr(TargetString, &#8230;&#8203;)</code> во многом подобна базовой функции <code>Write(&#8230;&#8203;)</code>, с одним отличием - результат сохраняется в <code>TargetString</code>.</p>
<div class="ulist">
<ul>
<li>
<p><em>Преимущество</em>: эта функция имеет все возможности функции <code>Write</code>, в том числе и специальный "волшебный" синтаксис для форматирования, как например <code>Pi:1:4</code>.</p>
</li>
<li>
<p><em>Недостаток</em>: такой специальный синтаксис для форматирования является "волшебным", т.е. он написан специально для конкретной процедуры. Часто это приводит к проблемам, например, невозможно создать свою функцию <code>MyStringFormatter(&#8230;&#8203;)</code> которая бы принимала такой синтаксис, как <code>Pi:1:4</code>. Именно по этому, а также из-за того, что эта функция долгое время не была доступна в основных компиляторах, такая конструкция не очень популярна.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_модули_unit_ы">3. Модули (Unit-ы)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unit-ы позволяют группировать общие функции и объекты (любые элементы языка, которые могут быть объявлены), для использования другими unit-ами и программами. Они эквивалентны <em>модулям</em> и <em>пакетам</em> в других языках. Они имеют секцию <code>interface</code>, где объявляются доступные для других unit-ов и программ переменные, функции и т.п., и секцию <code>implementation</code>, где описано, как они работают. Unit <code>MyUnit</code> можно сохранить под именем <code>myunit.pas</code> (название должно состоять из строчных букв с расширением <code>.pas</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> MyUnit;
<span class="keyword">interface</span>

<span class="keyword">procedure</span> MyProcedure(<span class="keyword">const</span> A: Integer);
<span class="keyword">function</span> MyFunction(<span class="keyword">const</span> S: <span class="keyword">string</span>): <span class="keyword">string</span>;

<span class="keyword">implementation</span>

<span class="keyword">procedure</span> MyProcedure(<span class="keyword">const</span> A: Integer);
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">A + 10 составляет: </span><span class="delimiter">'</span></span>, A + <span class="integer">10</span>);
<span class="keyword">end</span>;

<span class="keyword">function</span> MyFunction(<span class="keyword">const</span> S: <span class="keyword">string</span>): <span class="keyword">string</span>;
<span class="keyword">begin</span>
  Result := S + <span class="string"><span class="delimiter">'</span><span class="content">строки управляются автоматически</span><span class="delimiter">'</span></span>;
<span class="keyword">end</span>;

<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Файл основной программы чаще всего сохраняется в виде файлов типа <code>myprogram.lpr</code> (<code>lpr</code> = Lazarus program file; в Delphi используются <code>.dpr</code>). Следует отметить, что возможны и другие расширения, например, некоторые проекты используют расширение <code>.pas</code> для основного файла программы. Для unit-ов изредка используются расширение <code>.pp</code>. Лично же я предпочитаю использовать стандартные <code>.pas</code> для unit-ов и <code>.lpr</code> для FPC/Lazarus программ.</p>
</div>
<div class="paragraph">
<p>Программа может подключать unit с помощью ключевого слова <code>uses</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>

<span class="keyword">program</span> MyProgram;

<span class="keyword">uses</span> MyUnit;

<span class="keyword">begin</span>
  WriteLn(MyFunction(<span class="string"><span class="delimiter">'</span><span class="content">Примечание: </span><span class="delimiter">'</span></span>));
  MyProcedure(<span class="integer">5</span>);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unit может также содержать секции <code>initialization</code> и <code>finalization</code>. В них размещается код, который выполняется при запуске и завершении выполнения программы, соответственно.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> initialization_finalization;
<span class="keyword">interface</span>

<span class="keyword">implementation</span>

<span class="keyword">initialization</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Hello world!</span><span class="delimiter">'</span></span>);
<span class="keyword">finalization</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Goodbye world!</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_перекрёстные_ссылки_между_unit_ами">3.1. Перекрёстные ссылки между unit-ами</h3>
<div class="paragraph">
<p>Не только основная программа, но и unit-ы также могут ссылаться на другие unit-ы. Другой unit может войти в секцию interface или только в implementation. Первый вариант позволяет создавать новые определения (процедуры, типы&#8230;&#8203;), используя или наследуя информацию из другого unit-а. Во втором варианте возможности более ограничены - если использовать unit в секции implementation, то применить его идентификаторы возможно лишь в рамках implementation данного unit-а.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> AnotherUnit;
<span class="keyword">interface</span>

<span class="keyword">uses</span>
  Classes;

<span class="comment">{ Тип класса &quot;TComponent&quot; определён в unit-е Classes.
  По этому необходимо использовать uses Classes, как видно выше. }</span>
<span class="keyword">procedure</span> DoSomethingWithComponent(<span class="keyword">var</span> C: TComponent);

<span class="keyword">implementation</span>

<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">procedure</span> DoSomethingWithComponent(<span class="keyword">var</span> C: TComponent);
<span class="keyword">begin</span>
  <span class="comment">{ Процедура FreeAndNil определена в unit-е SysUtils.
    Поскольку мы лишь ссылаемся на её имя в разделе implementation,
    вполне допустимо использовать SysUtils в секции &quot;implementation&quot;. }</span>
  FreeAndNil(C);
<span class="keyword">end</span>;

<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Запрещено применять <em>кольцевую взаимозависимость (cyclic reference)</em> в разделе interface. Т.е. два unit-а не могут использовать друг друга в разделе interface.
Причина такого ограничения заключается в том, что для того, чтобы "понять" секцию interface unit-а, компилятор анализирует и "понимает" все unit-ы, перечисленные в uses в секции interface.
В Паскале это правило придерживается строго, что позволяет достичь высокой скорости компиляции и полностью автоматическое определение компилятором <em>что именно необходимо перекомпилировать</em>. В Паскале нет необходимости создания сложных <code>Makefile</code> для выполнения простой задачи компиляции, а также нет нужды <em>перекомпилировать всё</em> лишь для того, чтобы удостовериться, что все зависимости правильно обновились.</p>
</div>
<div class="paragraph">
<p>Вполне возможно создавать кольцевые зависимости между unit-ами когда один из них "используется" только в implementation. Поэтому нормально для <code>A</code> использовать <code>B</code> в interface, и затем unit <code>B</code> использует <code>A</code> в implementation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_определение_идентификаторов_с_указанием_имени_unit_а">3.2. Определение идентификаторов с указанием имени unit-а</h3>
<div class="paragraph">
<p>Различные unit-ы могут определять одинаковые идентификаторы. Чтобы поддерживать код простым для чтения и правки, обычно следует избегать таких совпадений, но не всегда это возможно. В таких случаях, последний unit в списке <code>uses</code> "перетягивает одеяло на себя", т.е. идентификаторы определённые в нём скрывают одноимённые идентификаторы введённые другими unit-ами ранее.</p>
</div>
<div class="paragraph">
<p>Однако, возможно недвусмысленно определить unit предоставляющий идентификатор, с помощью конструкции <code>MyUnit.MyIdentifier</code>. Это стандартное решение ситуации, когда используемый идентификатор из <code>MyUnit</code> скрыт идентификатором из другого unit-а. Для достижения этой же цели можно просто перестроить порядок unit-ов в списке uses, однако это повлияет на все идентификаторы, что не всегда желательно.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">program</span> showcolor;

<span class="comment">// unit-ы Graphics и GoogleMapsEngine определяют свои типы, которые называются одинаково - TColor.</span>
<span class="keyword">uses</span> Graphics, GoogleMapsEngine;

<span class="keyword">var</span>
  <span class="comment">{ Это сработает не так, как ожидается, поскольку TColor
    определяется последним unit-ом в списке - GoogleMapsEngine. }</span>
  <span class="comment">// Color: TColor;</span>
  <span class="comment">{ А так будет правильно. }</span>
  Color: Graphics.TColor;
<span class="keyword">begin</span>
  Color := clYellow;
  WriteLn(Red(Color), <span class="char"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span>, Green(Color), <span class="char"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span>, Blue(Color));
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>В случае unit-ов следует также помнить, что они могут иметь два списка <code>uses</code>: один - в секции <code>interface</code>, другой - в <code>implementation</code>. Основное правило в этом случае звучит как: "<em>позднейшие unit-ы скрывают все что было до этого</em>" и применяется последовательно, что в свою очередь означает, что <em>unit-ы использованные в секции implementation</em> могут скрывать идентификаторы из <em>unit-ов использованных в секции interface</em>. Кроме того, не стоит забывать, что в процессе обработки секции interface данного unit-а компилятором, влияют лишь unit-ы использованные в секции interface. Это может сбить с толку в ситуациях, когда два на вид одинаковых объявления обрабатываются компилятором по-разному:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> UnitUsingColors;

<span class="comment">// НЕВЕРНЫЙ пример</span>

<span class="keyword">interface</span>

<span class="keyword">uses</span> Graphics;

<span class="keyword">procedure</span> ShowColor(<span class="keyword">const</span> Color: TColor);

<span class="keyword">implementation</span>

<span class="keyword">uses</span> GoogleMapsEngine;

<span class="keyword">procedure</span> ShowColor(<span class="keyword">const</span> Color: TColor);
<span class="keyword">begin</span>
  <span class="comment">// WriteLn(ColorToString(Color));</span>
<span class="keyword">end</span>;

<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unit <code>Graphics</code> (из набора библиотек Lazarus LCL) определяет тип <code>TColor</code>. Но компилятор указывает на ошибку в этом unit-е, указывая на то, что заявленная в секции Interface процедура <code>ShowColor</code> не описана. Проблема в том, что unit <code>GoogleMapsEngine</code> также определяет тип <code>TColor</code>, который используется только в секции <code>implementation</code>, следовательно он <em>перекрывает</em> определение <code>TColor</code> в секции <code>implementation</code>. Т.е. компилятор видит это буквально как:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> UnitUsingColors;

<span class="comment">// НЕВЕРНЫЙ пример</span>
<span class="comment">// демонстрирующий, как предыдущий пример &quot;видит&quot; компилятор</span>

<span class="keyword">interface</span>

<span class="keyword">uses</span> Graphics;

<span class="keyword">procedure</span> ShowColor(<span class="keyword">const</span> Color: Graphics.TColor);

<span class="keyword">implementation</span>

<span class="keyword">uses</span> GoogleMapsEngine;

<span class="keyword">procedure</span> ShowColor(<span class="keyword">const</span> Color: GoogleMapsEngine.TColor);
<span class="keyword">begin</span>
  <span class="comment">// WriteLn(ColorToString(Color));</span>
<span class="keyword">end</span>;

<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае решение тривиальное: необходимо просто изменить <code>implementation</code>, чтобы явно использовать <code>TColor</code> из unit-а <code>Graphics</code>. Это также можно исправить, переместив <code>GoogleMapsEngine</code> в секцию interface до unit-а <code>Graphics</code>. Впрочем, это может привести к другим последствиям внутри unit-а <code>UnitUsingColors</code>, так как коснётся всех его определений.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> UnitUsingColors;

<span class="keyword">interface</span>

<span class="keyword">uses</span> Graphics;

<span class="keyword">procedure</span> ShowColor(<span class="keyword">const</span> Color: TColor);

<span class="keyword">implementation</span>

<span class="keyword">uses</span> GoogleMapsEngine;

<span class="keyword">procedure</span> ShowColor(<span class="keyword">const</span> Color: Graphics.TColor);
<span class="keyword">begin</span>
  <span class="comment">// WriteLn(ColorToString(Color));</span>
<span class="keyword">end</span>;

<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_передача_идентификаторов_одного_unit_а_через_другой">3.3. Передача идентификаторов одного unit-а через другой</h3>
<div class="paragraph">
<p>Иногда возникает необходимость взять идентификатор из одного unit-а и передать его через другой unit. Т.е. в результате использование нового unit-а должно сделать доступным старый идентификатор в пространстве имён.</p>
</div>
<div class="paragraph">
<p>В некоторых случаях это делается из-за необходимости сохранить обратную совместимость с предыдущими версиями unit-а. А иногда таким образом удобно "скрыть" какой-либо unit для внутреннего пользования.</p>
</div>
<div class="paragraph">
<p>Это может быть осуществлено с помощью повторного объявления идентификатора в новом unit-е.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> MyUnit;

<span class="keyword">interface</span>

<span class="keyword">uses</span> Graphics;

<span class="keyword">type</span>
  <span class="comment">{ Используем TColor из unit-а Graphics для определения TMyColor. }</span>
  TMyColor = TColor;

  <span class="comment">{ Как вариант, можно переопределить его под тем же именем.
    В таком варианте необходимо будет явно указать наименование unit-а,
    иначе получится несогласованное определение &quot;TColor = TColor&quot;. }</span>
  TColor = Graphics.TColor;

<span class="keyword">const</span>
  <span class="comment">{ С константами это тоже работает. }</span>
  clYellow = Graphics.clYellow;
  clBlue = Graphics.clBlue;

<span class="keyword">implementation</span>

<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Стоит отметить, что данный трюк не пройдёт с глобальными процедурами, функциями и переменными. В таком случае возникнет необходимость объявить постоянный указатель на процедуру в другом unit-е (см. <a href="#Callbacks">Колбэки&#8201;&#8212;&#8201;они же события, они же указатели на функции, они же процедурные переменные</a>), но такой код выглядит не совсем чисто.</p>
</div>
<div class="paragraph">
<p>Более оптимальным решением является создание тривиальной "функции-обёртки", которая под видом простого вызова функции из внешнего unit-а, просто передаёт ему параметры и возвращает принимаемые значения обратно.</p>
</div>
<div class="paragraph">
<p>Чтобы проделать то же с глобальными параметрами иногда используются глобальные (на уровне unit-а) свойства, см. <a href="#_свойства">Свойства</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_классы">4. Классы</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_основы_2">4.1. Основы</h3>
<div class="paragraph">
<p>В Паскале для объектно-ориентированного программирования чаще всего используются классы (classes). На базовом уровне класс просто является "контейнером", который может вмещать в себя:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>поля (field)</em> (иными словами <em>"переменная внутри класса"</em>),</p>
</li>
<li>
<p><em>методы (method)</em> (иными словами <em>"процедура или функция внутри класса"</em>),</p>
</li>
<li>
<p><em>свойства (property)</em> (удобный синтаксис для конструкции подобной полю, однако в действительности являющейся парой методов, используемых для <em>чтения (getter)</em> и <em>записи (setter)</em> чего-либо; детальнее см. <a href="#Properties">[Properties]</a>).</p>
</li>
<li>
<p>Вообще говоря, в классах можно разместить очень много различных вещей, см. <a href="#_дополнительные_возможности_объявления_классов_и_локальные_классы">Дополнительные возможности объявления классов и локальные классы</a>, но об этом пойдёт речь чуть позже.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
    MyInt: Integer; <span class="comment">// это &quot;поле&quot;</span>
    <span class="keyword">property</span> MyIntProperty: Integer <span class="directive">read</span> MyInt <span class="directive">write</span> MyInt; <span class="comment">// это &quot;свойство&quot;</span>
    <span class="keyword">procedure</span> MyMethod; <span class="comment">// это &quot;метод&quot;</span>
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.MyMethod;
<span class="keyword">begin</span>
  WriteLn(MyInt + <span class="integer">10</span>);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_наследование_inheritance_проверка_is_и_приведение_типов_as">4.2. Наследование (Inheritance), проверка (is), и приведение типов (as)</h3>
<div class="paragraph">
<p>Паскаль поддерживает наследование и виртуальные методы объектно-ориентированного программирования.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">program</span> MyProgram;

<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
    MyInt: Integer;
    <span class="keyword">procedure</span> MyVirtualMethod; <span class="directive">virtual</span>;
  <span class="keyword">end</span>;

  TMyClassDescendant = <span class="keyword">class</span>(TMyClass)
    <span class="keyword">procedure</span> MyVirtualMethod; <span class="directive">override</span>;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.MyVirtualMethod;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass отображает MyInt + 10: </span><span class="delimiter">'</span></span>, MyInt + <span class="integer">10</span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClassDescendant.MyVirtualMethod;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClassDescendant отображает MyInt + 20: </span><span class="delimiter">'</span></span>, MyInt + <span class="integer">20</span>);
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C: TMyClass;
<span class="keyword">begin</span>
  C := TMyClass.Create;
  <span class="keyword">try</span>
    C.MyVirtualMethod;
  <span class="keyword">finally</span>
    FreeAndNil(C);
  <span class="keyword">end</span>;

  C := TMyClassDescendant.Create;
  <span class="keyword">try</span>
    C.MyVirtualMethod;
  <span class="keyword">finally</span>
    FreeAndNil(C);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>По умолчанию методы не являются виртуальными и для объявления их виртуальными необходимо использовать ключевое слово <code>virtual</code>. Перекрытие или замещение виртуального метода осуществляется с помощью ключевого слова <code>override</code>, иначе компилятор выдаст ошибку. Чтобы скрыть метод без перекрытия используется ключевое слово <code>reintroduce</code>, впрочем, без особых на то причин, так делать не стоит.</p>
</div>
<div class="paragraph">
<p>Чтобы узнать, является ли некоторый класс из семейства классов конкретным его наследником можно использовать оператор <code>is</code>. Для выполнения приведения типа класса к конкретному классу следует использовать оператор <code>as</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">program</span> is_as;

<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
    <span class="keyword">procedure</span> MyMethod;
  <span class="keyword">end</span>;

  TMyClassDescendant = <span class="keyword">class</span>(TMyClass)
    <span class="keyword">procedure</span> MyMethodInDescendant;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.MyMethod;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Это MyMethod</span><span class="delimiter">'</span></span>)
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClassDescendant.MyMethodInDescendant;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Это MyMethodInDescendant</span><span class="delimiter">'</span></span>)
<span class="keyword">end</span>;

<span class="keyword">var</span>
  Descendant: TMyClassDescendant;
  C: TMyClass;
<span class="keyword">begin</span>
  Descendant := TMyClassDescendant.Create;
  <span class="keyword">try</span>
    Descendant.MyMethod;
    Descendant.MyMethodInDescendant;

    <span class="comment">{ производные классы сохраняют все функции родительского класса
      TMyClass, по этому можно таким образом создавать ссылку }</span>
    C := Descendant;
    C.MyMethod;

    <span class="comment">{ так не сработает, поскольку в TMyClass не определён этот метод }</span>
    <span class="comment">//C.MyMethodInDescendant;</span>
    <span class="comment">{ правильно записать следующим образом: }</span>
    <span class="keyword">if</span> C <span class="keyword">is</span> TMyClassDescendant <span class="keyword">then</span>
      (C <span class="keyword">as</span> TMyClassDescendant).MyMethodInDescendant;

  <span class="keyword">finally</span>
    FreeAndNil(Descendant);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вместо приведения типа в виде <code>X as TMyClass</code>, можно использовать приведение типа <em>без проверки</em> с помощью выражения <code>TMyClass(X)</code>. Такой код будет работать чуть-чуть быстрее, но может привести к неопределённому поведению в случае если <code>X</code> не является наследником <code>TMyClass</code>. По этому конструкцию <code>TMyClass(X)</code> лучше не применять кроме тех случаев, когда абсолютно очевидно, что <code>X</code> действительно является наследником <code>TMyClass</code>, например, если до этого тип класса был проверен с помощью оператора <code>is</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> A <span class="keyword">is</span> TMyClass <span class="keyword">then</span>
  (A <span class="keyword">as</span> TMyClass).CallSomeMethodOfMyClass;
<span class="comment">// вариант ниже - работает незначительно быстрее</span>
<span class="keyword">if</span> A <span class="keyword">is</span> TMyClass <span class="keyword">then</span>
  TMyClass(A).CallSomeMethodOfMyClass;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_свойства">4.3. Свойства</h3>
<div class="paragraph">
<p>Свойства (Properties) являются <em>"синтаксическим сахаром"</em> (<em>прим. перев. syntax sugar - жаргон, означающий синтаксические возможности, применение которых не влияет на поведение программы, но делает использование языка более удобным для программиста</em>) который можно использовать с целью:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Сделать что-то внешнее похожее на поле (может быть прочитано и установлено), но реализовано вызовом функций <em>считывания значения (getter)</em> и <em>установки значения (setter)</em>. Самое стандартное применение такого подхода - автоматическое выполннение дополнительных действий каждый раз, когда некоторое значение изменяется.</p>
</li>
<li>
<p>Сделать что-то внешне похожее на поле, но доступное только для чтения - нечто, похожее на константу или функцию без параметров.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TWebPage = <span class="keyword">class</span>
  <span class="directive">private</span>
    FURL: <span class="keyword">string</span>;
    FColor: TColor;
    <span class="keyword">function</span> SetColor(<span class="keyword">const</span> Value: TColor);
  <span class="directive">public</span>
    <span class="comment">{ Значение URL невозможно установить напрямую.
      Следует вызвать метод вроде Load('http://www.freepascal.org/'),
      для загрузки страницы и установки значения этого свойства. }</span>
    <span class="keyword">property</span> URL: <span class="keyword">string</span> <span class="directive">read</span> FURL;
    <span class="keyword">procedure</span> Load(<span class="keyword">const</span> AnURL: <span class="keyword">string</span>);
    <span class="keyword">property</span> Color: TColor <span class="directive">read</span> FColor <span class="directive">write</span> SetColor;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TWebPage.Load(<span class="keyword">const</span> AnURL: <span class="keyword">string</span>);
<span class="keyword">begin</span>
  FURL := AnURL;
  NetworkingComponent.LoadWebPage(AnURL);
<span class="keyword">end</span>;

<span class="keyword">function</span> TWebPage.SetColor(<span class="keyword">const</span> Value: TColor);
<span class="keyword">begin</span>
  <span class="keyword">if</span> FColor &lt;&gt; Value <span class="keyword">then</span>
  <span class="keyword">begin</span>
    FColor := Value;
    <span class="comment">{ Например, требовать обновления класса, каждый раз,
      когда изменяется значение его цвета:
    Repaint;
    { Ещё пример: обеспечить чтобы нечто изменялось синхронно
      с установкой цвета, например }</span>
    RenderingComponent.Color := Value;
  <span class="keyword">end</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Стоит обратить внимание, что вместо того, чтобы указать метод для чтения или записи, можно напрямую указать читаемое/записываемое поле (которое обычно является private и весьма часто имеет название идентичное property с дополнительным префиксом f (от field - поле)) чтобы непосредственно получать или устанавливать значение. В примере выше, свойство <code>Color</code> использует <em>setter</em>-метод <code>SetColor</code>. Однако, для получения значения свойство <code>Color</code> напрямую ссылается на private поле <code>FColor</code>. Прямая ссылка на конкретное поле, очевидно, быстрее, чем написание дополнительных методов getter или setter - как с точки зрения разработки, так и с точки зрения скорости исполнения программы.</p>
</div>
<div class="paragraph">
<p>При объявлении свойства указывается:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Может ли оно быть прочитано, и как (с помощью прямого чтения поля, или с использованием метода <code>getter</code>).</p>
</li>
<li>
<p>Может ли оно быть установлено, и как (с помощью прямой записи поля, или вызовом метода <code>setter</code>).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Компилятор следит за тем, чтобы типы и параметры соответствующих полей и методов совпадали с типом свойства с которым они работают. Например, чтобы прочитать свойство <code>Integer</code> следует или предоставить поле <code>Integer</code>, или беспараметрический метод (функцию), который возвращает <code>Integer</code>.</p>
</div>
<div class="paragraph">
<p>С технической точки зрения, методы "getter" и "setter" - обычные методы и они могут делать абсолютно что угодно (включая массу дополнительных функций). Всё же правилом хорошего тона является создание таких свойств, которые ведут себя более-менее подобно обычному полю:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Функция <em>getter</em> не должна иметь невидимых побочных эффектов (например, она не должна читать некоторый ввод из файла / с клавиатуры). Её значение должно быть детерминистическим (без рандомизации или псевдо-рандомизации :)) - чтение свойства должно всегда иметь смысл и возвращать одинаковый результат, если между операциями чтения ничего не изменилось.</p>
<div class="paragraph">
<p>Следует отметить, что вполне нормально если выполнение <em>getter</em> имеет некие <em>невидимые</em> последствия, например, сохранение в кеше результатов какого-либо вычисления для ускорения выполнения кода при следующем вызове. По факту, это одна из очень полезных возможностей функции "getter".</p>
</div>
</li>
<li>
<p>Функция <em>setter</em> должна всегда устанавливать значение таким образом, чтобы <em>getter</em> вернул его же обратно. Не стоит автоматически отбрасывать неверные значения "setter", а в случае, когда это необходимо, следует вызвать exception. Также не желательно конвертировать или масштабировать запрашиваемое значение. Главная идея заключается в том, чтобы после установки <code>MyClass.MyProperty := 123;</code> можно было с уверенностью сказать, что <code>MyClass.MyProperty = 123</code>.</p>
</li>
<li>
<p><em>Свойства, доступные только для чтения</em> часто используют для создания неких полей доступных из внешнего кода только для чтения. Снова таки, хорошая практика - делать их поведение похожим на константу, по крайней мере для данного экземпляра класса в его текущем состоянии. Значение такого свойства не должно меняться неожиданно. <em>Если необходимо возвращать что-то случайное, лучше сделать функцию, а не свойство.</em></p>
</li>
<li>
<p>Поле, к которому обращаются свойства почти всегда находится в разделе <em>private</em>, поскольку главная идея свойств - служить обёрткой и методом доступа к нему.</p>
</li>
<li>
<p>Технически, возможно создать свойства, которые только устанавливают значение, но не читают его. Впрочем, хороших примеров такой реализации лично мне ещё не встречалось :)</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
Свойства так же могут быть определены вне класса, на уровне unit-а. Они служат аналогичной цели: они внешне выглядят как глобальные переменные, но доступ к ним вызывает соответствующие функции <em>getter</em> и <em>setter</em>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_сериализация_serialization_свойств">4.3.1. Сериализация (Serialization) свойств</h4>
<div class="paragraph">
<p>Свойства, имеющие уровень <em>Published</em> являются основой для сериализации (<em>serialization</em>) (также называемой <em>передачей компонент в потоке</em> (<em>streaming components</em>)) в Паскале. Слово "Serialization" происходит от слова "Series" - "ряд", т.е. сериализация подаёт свойства объекта в виде некоторого линейного ряда данных, такого как например, запись в памяти или в файле.</p>
</div>
<div class="paragraph">
<p>Собственно, именно сериализация и происходит в момент, когда Lazarus читает или записывает состояние компонент из/в файл <code>xxx.lfm</code>. В Delphi эквивалентный файл имеет расширение <code>.dfm</code>. Этот механизм можно использовать и в своих целях, с помощью процедур таких как <code>ReadComponentFromTextStream</code> из unit-а <code>LResources</code>. Также можно использовать другие алгоритмы сериализации, например unit <code>FpJsonRtti</code> представляет возможность сериализации в популярном формате JSON.</p>
</div>
<div class="paragraph">
<p>В <strong>Castle Game Engine</strong> можно использовать unit <code>CastleComponentSerialize</code> (созданный на основе <code>FpJsonRtti</code>) для сериализации иерархии наших собственных компонент, таких как user-interface и transformation.</p>
</div>
<div class="paragraph">
<p>При каждом свойстве можно указать дополнительные параметры, которые будут полезны при использовании любого алгоритма сериализации:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Можно указать значение свойства "по умолчанию" с помощью ключевого слова <code>default</code>. Обратите внимание, что всё равно следует инициализировать свойство с помощью значения по умолчанию - это не происходит автоматически. Значение <code>default</code> это лишь указание алгоритму сериализации: <em>"когда закончится выполнение constructor-а, то данное свойство имеет это значение"</em>.</p>
</li>
<li>
<p>Сохранять ли это свойство вообще - с помощью ключевого слова <code>stored</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_исключения">4.4. Исключения</h3>
<div class="paragraph">
<p>В паскале можно вызывать и использовать исключения. Их можно "ловить" с помощью конструкции <code>try &#8230;&#8203; except &#8230;&#8203; end</code>, также можно применять секцию "выполнить в конце" <code>try &#8230;&#8203; finally &#8230;&#8203; end</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>

<span class="keyword">program</span> MyProgram;

<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
    <span class="keyword">procedure</span> MyMethod;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.MyMethod;
<span class="keyword">begin</span>
  <span class="keyword">if</span> Random &gt; <span class="float">0.5</span> <span class="keyword">then</span>
    <span class="keyword">raise</span> Exception.Create(<span class="string"><span class="delimiter">'</span><span class="content">Вызываем exception!</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C: TMyClass;
<span class="keyword">begin</span>
  Randomize;
  C := TMyClass.Create;
  <span class="keyword">try</span>
    C.MyMethod;
  <span class="keyword">finally</span>
    FreeAndNil(C)
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание, что раздел <code>finally</code> будет выполнен даже в случае, если выполнение будет прекращено командой <code>Exit</code> (из функции, процедуры или метода), операторами <code>Break</code> или <code>Continue</code> (внутри тела цикла).</p>
</div>
</div>
<div class="sect2">
<h3 id="_уровни_видимости">4.5. Уровни видимости</h3>
<div class="paragraph">
<p>Как и в большинстве других объектно-ориентированных языков, в Паскале имеются визуальные спецификаторы для ограничения "видимости" полей / методов / свойств.</p>
</div>
<div class="paragraph">
<p>Основные уровни видимости являются следующими:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>public</code></dt>
<dd>
<p>предоставлен доступ из любого участка кода, включая код в других unit-ах.</p>
</dd>
<dt class="hdlist1"><code>private</code></dt>
<dd>
<p>доступен только в этом классе.</p>
</dd>
<dt class="hdlist1"><code>protected</code></dt>
<dd>
<p>доступен только в этом классе и всех его наследниках.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Краткое описание <code>private</code> и <code>protected</code>, данное выше, не полностью верно. Код в <em>текущем unit-е</em> может преодолевать эти границы, и получать доступ к секции <code>private</code> и <code>protected</code>. Иногда это полезная особенность, позволяющая реализовывать тесно связанные классы. В остальных же случаях следует использовать <code>strict private</code> или <code>strict protected</code> для организации полной недоступности данных методов, полей или свойств извне класса. Детальнее этот вопрос рассматривается в разделе <a href="#_различие_private_и_strict_private">Различие private и strict private</a>.</p>
</div>
<div class="paragraph">
<p>По умолчанию, если видимость не указана явно, то она соответствует <code>public</code>. исключение составляют классы, которые объявляются при включённой директиве <code>{$M+}</code>, либо наследники классов, которые были скомпилированы при <code>{$M+}</code>, что включает в себя всех потомков <code>TPersistent</code>, включая потомков <code>TComponent</code>, который сам является потомком <code>TPersistent</code>. Для таких классов по умолчанию видимость принимается <code>published</code>, которая подобна <code>public</code>, однако позволяет работать с ними с помощью потоковой (stream) системы.</p>
</div>
<div class="paragraph">
<p>Однако, не каждому типу поля или свойства позволено быть в секции published - не каждый тип может быть конвертирован в поток (stream), и лишь классы, состоящие из простых полей, могут передаваться потоком. Если нет необходимости создавать потоки, но нужно просто сделать что-то доступное для всех пользователей, то следует использовать <code>public</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_предок_по_умолчанию">4.6. Предок по умолчанию</h3>
<div class="paragraph">
<p>Если явно не объявить родительский класс, то по умолчанию каждый <code>class</code> наследует <code>TObject</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_освобождение_памяти_классов">5. Освобождение памяти классов</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_всегда_необходимо_освобождать_экземпляры_класса">5.1. Всегда необходимо освобождать экземпляры класса</h3>
<div class="paragraph">
<p>Чтобы избежать утечек памяти, все экземпляры класса должны быть освобождены вручную. Хорошей практикой является использование опции компилятора FPC -gl -gh, чтобы обнаруживать утечки памяти (более подробно см. <a href="https://castle-engine.io/manual_optimization.php#section_memory" class="bare">https://castle-engine.io/manual_optimization.php#section_memory</a>).</p>
</div>
<div class="paragraph">
<p>Следует обратить внимание, что это не касается вызванных исключений (raised exceptions). Не смотря на то, что при вызове исключения действительно создаётся класс (и это вполне обычный класс, для этих целей также можно создавать и свои классы), такой экземпляр класса освобождается автоматически.</p>
</div>
</div>
<div class="sect2">
<h3 id="_каким_образом_освобождать_память">5.2. Каким образом освобождать память</h3>
<div class="paragraph">
<p>Самым удобным методом освобождения класса является операция <code>FreeAndNil(A)</code> из unit-а <code>SysUtils</code> вызванная для данного экземпляра класса. Она проверяет, не имеет ли <code>A</code> значение <code>nil</code>, и если нет&#8201;&#8212;&#8201;вызывает его деструктор (destructor), и устанавливает значение <code>A</code> в <code>nil</code>. Таким образом повторный вызов данной процедуры не приведёт к ошибке.</p>
</div>
<div class="paragraph">
<p>Приблизительно это соответствует следующему:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> A &lt;&gt; <span class="keyword">nil</span> <span class="keyword">then</span>
<span class="keyword">begin</span>
  A.Destroy;
  A := <span class="keyword">nil</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Впрочем, эта аналогия немного упрощена, поскольку процедура <code>FreeAndNil</code> совершает ещё одно полезное действие, сразу устанавливая <code>A</code> значение <code>nil</code> <strong>до того</strong> как будет вызван destructor данного класса. Это позволяет избежать целой группы ошибок благодаря тому, что "внешний" код не сможет случайно получить доступ к не до конца уничтоженному экземпляру класса.</p>
</div>
<div class="paragraph">
<p>Иногда можно заметить, что применяется метод <code>A.Free</code> который соответствует следующему коду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> A &lt;&gt; <span class="keyword">nil</span> <span class="keyword">then</span>
  A.Destroy;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Т.е. освобождает класс <code>A</code>, если он не равен <code>nil</code>.</p>
</div>
<div class="paragraph">
<p>Стоит отметить, что в нормальных условиях никогда не стоит вызывать метод класса, ссылка на который может оказаться <code>nil</code>. По этому <code>A.Free</code> может выглядеть подозрительно на первый взгляд, поскольку <code>A</code> вполне может иметь значение <code>nil</code>. Однако, метод <code>Free</code> является исключением из этого правила. Это выглядит немного "грязновато"&#8201;&#8212;&#8201;а именно, выполняется проверка <code>Self &lt;&gt; nil</code>. Такой фокус работает только для не-виртуальных методов (т.е. в случае, если не вызываются виртуальные методы и не требуется доступ к полям класса).</p>
</div>
<div class="paragraph">
<p>По этому лучше всегда использовать <code>FreeAndNil(A)</code>, без исключений, и никогда не использовать метод <code>Free</code> или напрямую деструктор <code>Destroy</code>. Такой концепции придерживается <em>Castle Game Engine</em>. Это позволяет быть уверенным, что все ссылки <em>либо равны <code>nil</code>, либо указывают на существующий рабочий экземпляр класса</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ручное_и_автоматическое_освобождение_памяти">5.3. Ручное и автоматическое освобождение памяти</h3>
<div class="paragraph">
<p>Во многих ситуациях, освобождение экземпляра класса не является чем-то сложным. Просто пишется destructor, как пара соответствующему constructor-у, и освобождает все классы, память для которых была выделена в constructor-е (а, точнее, в продолжении всего времени существования класса). Важно следить за тем, чтобы освобождать каждый класс лишь <strong>один раз</strong>. Хорошей практикой будет всегда присваивать освобождённой ссылке значение <code>nil</code>, а наиболее удобно сделать это, вызвав команду <code>FreeAndNil(A)</code>.</p>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">uses</span> SysUtils;

<span class="keyword">type</span>
  TGun = <span class="keyword">class</span>
  <span class="keyword">end</span>;

  TPlayer = <span class="keyword">class</span>
    Gun1, Gun2: TGun;
    <span class="keyword">constructor</span> Create;
    <span class="keyword">destructor</span> Destroy; <span class="directive">override</span>;
  <span class="keyword">end</span>;

<span class="keyword">constructor</span> TPlayer.Create;
<span class="keyword">begin</span>
  <span class="keyword">inherited</span>;
  Gun1 := TGun.Create;
  Gun2 := TGun.Create;
<span class="keyword">end</span>;

<span class="keyword">destructor</span> TPlayer.Destroy;
<span class="keyword">begin</span>
  FreeAndNil(Gun1);
  FreeAndNil(Gun2);
  <span class="keyword">inherited</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы избежать необходимости каждый раз явным образом освобождать экземпляр класса, можно использовать полезную особенность <code>TComponent</code>, которая называется <em>"owner"</em> (владение дочерним классом). Класс у которого есть <em>owner</em> (владелец) будет автоматически освобождён его <em>owner-ом</em>. Механизм очень гибкий и никогда не освобождает классы, которые уже освобождены, т.е. всё будет работать правильно в случае, если класс был освобождён ранее. Таким образом предыдущий пример можно переписать следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">uses</span> SysUtils, Classes;

<span class="keyword">type</span>
  TGun = <span class="keyword">class</span>(TComponent)
  <span class="keyword">end</span>;

  TPlayer = <span class="keyword">class</span>(TComponent)
    Gun1, Gun2: TGun;
    <span class="keyword">constructor</span> Create(AOwner: TComponent); <span class="directive">override</span>;
  <span class="keyword">end</span>;

<span class="keyword">constructor</span> TPlayer.Create(AOwner: TComponent);
<span class="keyword">begin</span>
  <span class="keyword">inherited</span>;
  Gun1 := TGun.Create(Self);
  Gun2 := TGun.Create(Self);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следует обратить внимание, что также необходимо override виртуальный constructor от <code>TComponent</code>. Это, в свою очередь, означает, что нельзя изменять параметры constructor-а. Впрочем, всё-таки это возможно&#8201;&#8212;&#8201;объявив новый constructor с ключевым словом <code>reintroduce</code>. Однако здесь стоит быть осторожным, так как некоторый функционал, например, streaming, всё равно будет использовать виртуальный constructor, по этому следует удостовериться, что во всех возможных случаях всё будет работать корректно.</p>
</div>
<div class="paragraph">
<p>Обратите внимание, что всегда можно использовать <code>nil</code> в качестве owner-а. Таким образом для данного компонента не будет owner-класса и класс не будет освобождён автоматически. Это может оказаться полезным, если необходимо использовать класс на основе <code>TComponent</code>, сохранив при этом возможность освобождать его вручную. Таким образом просто создавать наследника компонента следующим образом: <code>ManualGun := TGun.Create(nil);</code>.</p>
</div>
<div class="paragraph">
<p>Ещё один удобный механизм автоматического освобождения памяти&#8201;&#8212;&#8201;функционал <code>OwnsObjects</code> (который по умолчанию равен <code>true</code>) классов-списков, таких, как <code>TFPGObjectList</code> или <code>TObjectList</code>. Т.е. можно сделать следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">uses</span> SysUtils, Classes, FGL;

<span class="keyword">type</span>
  TGun = <span class="keyword">class</span>
  <span class="keyword">end</span>;

  TGunList = specialize TFPGObjectList&lt;TGun&gt;;

  TPlayer = <span class="keyword">class</span>
    Guns: TGunList;
    Gun1, Gun2: TGun;
    <span class="keyword">constructor</span> Create;
    <span class="keyword">destructor</span> Destroy; <span class="directive">override</span>;
  <span class="keyword">end</span>;

<span class="keyword">constructor</span> TPlayer.Create;
<span class="keyword">begin</span>
  <span class="keyword">inherited</span>;
  <span class="comment">// Вообще говоря, параметр OwnsObjects и так true по умолчанию</span>
  Guns := TGunList.Create(true);
  Gun1 := TGun.Create;
  Guns.Add(Gun1);
  Gun2 := TGun.Create;
  Guns.Add(Gun2);
<span class="keyword">end</span>;

<span class="keyword">destructor</span> TPlayer.Destroy;
<span class="keyword">begin</span>
  <span class="comment">{ Здесь достаточно освободить сам список.
    Он сам автоматически освободит всё содержимое. }</span>
  FreeAndNil(Guns);

  <span class="comment">{ Таким образом нет нужды освобождать Gun1, Gun2 отдельно. Правда, хорошей
    практикой будет теперь установить значение &quot;nil&quot; соответствующим значениям
    ссылок на них, поскольку мы знаем, что они освобождены.
    В этом простом классе с простым destructor-ом, очевидно,
    что к ним не произойдёт доступа, однако в случае сложных destructor-ов
    это может оказаться полезно.

    Альтернативно, можно избежать объявления Gun1 и Gun2 отдельно
    и использовать напрямую Guns[0] и Guns[1] в коде.
    Можно также создать метод Gun1, который возвращает ссылку на Guns[0]. }</span>
  Gun1 := <span class="keyword">nil</span>;
  Gun2 := <span class="keyword">nil</span>;
  <span class="keyword">inherited</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Заметим, что механизм owner-ов классов-списков простой (без дополнительных проверок) и, в случае освобождения содержащегося в списке экземпляра класса сторонним кодом, впоследствии возникнет ошибка. Чтобы исключить что-либо из списка без освобождения используется метод <code>Extract</code>, однако это также означает, что в дальнейшем элемент придётся освободить вручную.</p>
</div>
<div class="paragraph">
<p>Например, в <strong>Castle Game Engine</strong> все наследники класса <code>TX3DNode</code> автоматически управляют памятью при добавлении другой <code>TX3DNode</code> в список children. Корневая X3DNode называется <code>TX3DRootNode</code> и, в свою очередь, обычно имеет своим owner-ом класс <code>TCastleSceneCore</code>. Другие классы также имеют простой механизм owner-а&#8201;&#8212;&#8201;обычно это обозначено параметром или свойством под названием вида <code>OwnsXxx</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_free_notification">5.4. Free notification</h3>
<div class="paragraph">
<p>Если на экземпляр класса создано несколько ссылок, это эквивалентно тому, что две ссылки указывают на одну и ту же область памяти. Если освободить одну из них, вторая окажется <em>"болтающимся" pointer-ом</em>. Нельзя пытаться получить доступ к области памяти, которая была освобождена. Это может привести к runtime ошибке, либо может быть получено неопределённое значение ("мусор")&#8201;&#8212;&#8201;в случае, если эта область памяти уже была повторно выделена для других элементов внутри текущей программы.</p>
</div>
<div class="paragraph">
<p>В таком случае не достаточно просто вызывать <code>FreeAndNil</code> поскольку эта функция установит <code>nil</code> лишь для переданной ей ссылки&#8201;&#8212;&#8201;автоматического метода для подобных задач не существует. Рассмотрим следующий пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  Obj1, Obj2: TObject;
<span class="keyword">begin</span>
  Obj1 := TObject.Create;
  Obj2 := Obj1;
  FreeAndNil(Obj1);

  <span class="comment">// что произойдёт, если попытаться получить доступ к классу Obj1 или Obj2?</span>
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>В конце данного блока ссылка <code>Obj1</code> является <code>nil</code>. Если необходимо получить доступ к ней в коде программы, для надёжности следует использовать проверку <code>if Obj1 &lt;&gt; nil then &#8230;&#8203;</code> чтобы случайно не вызвать метод уже освобождённого экземпляра класса, например:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> Obj1 &lt;&gt; <span class="keyword">nil</span> <span class="keyword">then</span>
  WriteLn(Obj1.ClassName);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Попытка доступа к ссылке <code>nil</code> на экземпляр класса приведёт к предсказуемой и понятной ошибке. Таким образом, даже если код не будет проверять <code>Obj1 &lt;&gt; nil</code>, и попытается вслепую получить доступ к <code>Obj1</code>, возникнет достаточно ясное сообщение об ошибке.</p>
</div>
<div class="paragraph">
<p>То же самое происходит и при попытке вызова виртуального, или не-виртуального метода который пытается получить доступ к полю освобождённого экземпляра класса.</p>
</div>
</li>
<li>
<p>Ситуация с <code>Obj2</code>&#8201;&#8212;&#8201;куда сложнее. Её значение не <code>nil</code>, однако оно уже ошибочно. Попытка доступа к не-<code>nil</code> ссылки на несуществующий экземпляр класса приводит к непредсказуемому результату&#8201;&#8212;&#8201;это может быть и ошибка access violation, а может и просто какое-то случайное значение.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>К решению такой проблемы есть несколько путей:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Первое решение - внимательно читать документацию к классу. Не предполагать ничего о длительности жизни ссылки, если она создана чужим кодом. Если в классе <code>TCar</code> есть поле <code>wheel</code>, указывающее на экземпляр класса типа <code>TWheel</code>, то есть <em>правило</em> что ссылка на <code>wheel</code> верна, пока существует класс <code>car</code>, и сам <code>car</code> освободит все его <code>wheel</code> используя свой destructor. Но это правило не всегда возможно выполнить. В более сложных случаях, в документации следует сделать упоминание о том, что и как происходит со ссылками.</p>
</li>
<li>
<p>В примере выше, сразу после освобождения экземпляра класса <code>Obj1</code>, можно просто вручную установить <code>Obj2</code> значение <code>nil</code>. В данном конкретном примере тривиально.</p>
</li>
<li>
<p>Однако, наиболее перспективным решением будет применение специального механизма класса <code>TComponent</code> под названием "free notification" (извещение об освобождении). Таким образом один компонент может получить извещение в случае освобождения одной из компонент, и далее установить ссылку на неё в <code>nil</code>.</p>
<div class="paragraph">
<p>Таким образом можно получить <em>слабую ссылку</em>. Использовать эту механику можно в различных задачах, например, позволить коду извне изменять ссылки, в том числе, возможность освобождать память в любой момент.</p>
</div>
<div class="paragraph">
<p>Для этого оба класса должны наследовать <code>TComponent</code>. Обычно это сводится к использованию <code>FreeNotification</code> , <code>RemoveFreeNotification</code>, и override <code>Notification</code>.</p>
</div>
<div class="paragraph">
<p>Следующий пример демонстрирует как использовать этот подход вместе с constructor-ом / destructor-ом и setter-ом. Иногда можно всё сделать намного проще, но здесь демонстрируется полномасштабная версия, которая будет верной в любом случае.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TControl = <span class="keyword">class</span>(TComponent)
  <span class="keyword">end</span>;

  TContainer = <span class="keyword">class</span>(TComponent)
  <span class="directive">private</span>
    FSomeSpecialControl: TControl;
    <span class="keyword">procedure</span> SetSomeSpecialControl(<span class="keyword">const</span> Value: TControl);
  <span class="directive">protected</span>
    <span class="keyword">procedure</span> Notification(AComponent: TComponent; Operation: TOperation); <span class="directive">override</span>;
  <span class="directive">public</span>
    <span class="keyword">destructor</span> Destroy; <span class="directive">override</span>;
    <span class="keyword">property</span> SomeSpecialControl: TControl
      <span class="directive">read</span> FSomeSpecialControl <span class="directive">write</span> SetSomeSpecialControl;
  <span class="keyword">end</span>;

<span class="keyword">implementation</span>

<span class="keyword">procedure</span> TContainer.Notification(AComponent: TComponent; Operation: TOperation);
<span class="keyword">begin</span>
  <span class="keyword">inherited</span>;
  <span class="keyword">if</span> (Operation = opRemove) <span class="keyword">and</span> (AComponent = FSomeSpecialControl) <span class="keyword">then</span>
    <span class="comment">{ установить значение nil для SetSomeSpecialControl чтобы всё аккуратно подчистить }</span>
    SomeSpecialControl := <span class="keyword">nil</span>;
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TContainer.SetSomeSpecialControl(<span class="keyword">const</span> Value: TControl);
<span class="keyword">begin</span>
  <span class="keyword">if</span> FSomeSpecialControl &lt;&gt; Value <span class="keyword">then</span>
  <span class="keyword">begin</span>
    <span class="keyword">if</span> FSomeSpecialControl &lt;&gt; <span class="keyword">nil</span> <span class="keyword">then</span>
      FSomeSpecialControl.RemoveFreeNotification(Self);
    FSomeSpecialControl := Value;
    <span class="keyword">if</span> FSomeSpecialControl &lt;&gt; <span class="keyword">nil</span> <span class="keyword">then</span>
      FSomeSpecialControl.FreeNotification(Self);
  <span class="keyword">end</span>;
<span class="keyword">end</span>;

<span class="keyword">destructor</span> TContainer.Destroy;
<span class="keyword">begin</span>
  <span class="comment">{ Установить значение nil для SetSomeSpecialControl, чтобы запустить notification про освобождение памяти }</span>
  SomeSpecialControl := <span class="keyword">nil</span>;
  <span class="keyword">inherited</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_run_time_library">6. Run-time library</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_вводвывод_с_помощью_потоков">6.1. Ввод/вывод с помощью потоков</h3>
<div class="paragraph">
<p>Для ввода / вывода в современных программах на Паскале используется класс <code>TStream</code>. У него также есть множество полезных производных классов, таких как <code>TFileStream</code>, <code>TMemoryStream</code>, <code>TStringStream</code> и т.п.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils, Classes;

<span class="keyword">var</span>
  S: TStream;
  InputInt, OutputInt: Integer;
<span class="keyword">begin</span>
  InputInt := <span class="integer">666</span>;

  S := TFileStream.Create(<span class="string"><span class="delimiter">'</span><span class="content">my_binary_file.data</span><span class="delimiter">'</span></span>, fmCreate);
  <span class="keyword">try</span>
    S.WriteBuffer(InputInt, SizeOf(InputInt));
  <span class="keyword">finally</span>
    FreeAndNil(S);
  <span class="keyword">end</span>;

  S := TFileStream.Create(<span class="string"><span class="delimiter">'</span><span class="content">my_binary_file.data</span><span class="delimiter">'</span></span>, fmOpenRead);
  <span class="keyword">try</span>
    S.ReadBuffer(OutputInt, SizeOf(OutputInt));
  <span class="keyword">finally</span>
    FreeAndNil(S);
  <span class="keyword">end</span>;

  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Из файла прочитано целое число: </span><span class="delimiter">'</span></span>, OutputInt);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>В <strong>Castle Game Engine</strong> следует использовать функцию <code>Download</code> для создания потока, который загружает данные с любого заданного URL. Это могут быть обычные файлы, ресурсы, хранящиеся на HTTP и HTTPS, Android assets и много других. Более того, для однозначного кросс-платформенного указания на папку игровых данных (хранящихся в папке <code>data</code>) следует использовать функцию <code>ApplicationData</code> или особый тип URL <code>castle-data:/xxx</code> URL. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">EnableNetwork := true;
S := Download(<span class="string"><span class="delimiter">'</span><span class="content">https://castle-engine.io/latest.zip</span><span class="delimiter">'</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">S := Download(<span class="string"><span class="delimiter">'</span><span class="content">file:///home/michalis/my_binary_file.data</span><span class="delimiter">'</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">S := Download(ApplicationData(<span class="string"><span class="delimiter">'</span><span class="content">gui/my_image.png</span><span class="delimiter">'</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы прочитать обычный текстовый файл лучше использовать класс <code>TTextReader</code> из <code>CastleClassUtils</code>. Он предоставляет построчный API, как надстройку над <code>TStream</code>. URL можно задать через конструктор класса <code>TTextReader</code>, либо можно передать ему готовый <code>TStream</code> вручную.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">Text := TTextReader.Create(ApplicationData(<span class="string"><span class="delimiter">'</span><span class="content">my_data.txt</span><span class="delimiter">'</span></span>));
<span class="keyword">while</span> <span class="keyword">not</span> Text.Eof <span class="keyword">do</span>
  WriteLnLog(<span class="string"><span class="delimiter">'</span><span class="content">NextLine</span><span class="delimiter">'</span></span>, Text.ReadLine);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_списки">6.2. Списки</h3>
<div class="paragraph">
<p>Для создания различных списков переменной длинны, лично я советую использовать generic классы из unit-а <code>FGL</code>. Можно использовать <code>TFPGList</code> для простых типов данных (включая record-ы или устаревшие object-ы), и <code>TFPGObjectList</code> для списка экземпляров классов. В <strong>Castle Game Engine:</strong> можно также использовать <code>TGenericStructList</code> из <code>CastleGenericLists</code> для создания списков record-ов или устаревших object-ов. Это позволяет обойти проблему невозможности override их операторов в старых версиях FPC.</p>
</div>
<div class="paragraph">
<p>Применение таких списков является хорошей идеей по нескольким причинам: они типо-безопасны и их API имеет много полезных функций, таких как поиск, сортировка, итерация и т.п. Вообще говоря, не стоит использовать <em>динамические массивы</em> (<code>array of X</code>, <code>SetLength(X, &#8230;&#8203;)</code>) поскольку их API очень неудобный - можно применить лишь <code>SetLength</code>. Также не желательно использовать <code>TList</code> или <code>TObjectList</code> поскольку это потребует преобразование типа из общего <code>TObject</code> в конкретный тип класса при каждом обращении.</p>
</div>
</div>
<div class="sect2">
<h3 id="_клонирование_классов_tpersistent_assign">6.3. Клонирование классов: TPersistent.Assign</h3>
<div class="paragraph">
<p>Стандартным подходом для создания копии экземпляра класса является наследование этим классом <code>TPersistent</code> с последующим override его метода <code>Assign</code>. Здесь нет ничего сложного, просто нужно в методе <code>Assign</code> прописать копирование полей, которые Вам необходимы.</p>
</div>
<div class="paragraph">
<p>Однако, здесь понадобится достаточно аккуратный подход в имплементации метода <code>Assign</code>, поскольку копирование может происходить не только из данного класса, а и из производных от него.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils, Classes;

<span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>(TPersistent)
  <span class="directive">public</span>
    MyInt: Integer;
    <span class="keyword">procedure</span> Assign(Source: TPersistent); <span class="directive">override</span>;
  <span class="keyword">end</span>;

  TMyClassDescendant = <span class="keyword">class</span>(TMyClass)
  <span class="directive">public</span>
    MyString: <span class="keyword">string</span>;
    <span class="keyword">procedure</span> Assign(Source: TPersistent); <span class="directive">override</span>;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.Assign(Source: TPersistent);
<span class="keyword">var</span>
  SourceMyClass: TMyClass;
<span class="keyword">begin</span>
  <span class="keyword">if</span> Source <span class="keyword">is</span> TMyClass <span class="keyword">then</span>
  <span class="keyword">begin</span>
    SourceMyClass := TMyClass(Source);
    MyInt := SourceMyClass.MyInt;
    <span class="comment">// Xxx := SourceMyClass.Xxx; // добавить необходимые поля здесь</span>
  <span class="keyword">end</span> <span class="keyword">else</span>
    <span class="comment">{ Вызываем inherited ТОЛЬКО если не получается вручную обработать Source }</span>
    <span class="keyword">inherited</span> Assign(Source);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClassDescendant.Assign(Source: TPersistent);
<span class="keyword">var</span>
  SourceMyClassDescendant: TMyClassDescendant;
<span class="keyword">begin</span>
  <span class="keyword">if</span> Source <span class="keyword">is</span> TMyClassDescendant <span class="keyword">then</span>
  <span class="keyword">begin</span>
    SourceMyClassDescendant := TMyClassDescendant(Source);
    MyString := SourceMyClassDescendant.MyString;
    <span class="comment">// Xxx := SourceMyClassDescendant.Xxx; // добавить необходимые поля здесь</span>
  <span class="keyword">end</span>;

  <span class="comment">{ ВСЕГДА вызываем inherited, чтобы TMyClass.Assign сама обработала
    все остающиеся поля. }</span>
  <span class="keyword">inherited</span> Assign(Source);
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C1, C2: TMyClass;
  CD1, CD2: TMyClassDescendant;
<span class="keyword">begin</span>
  <span class="comment">// тестируем TMyClass.Assign</span>
  C1 := TMyClass.Create;
  C2 := TMyClass.Create;
  <span class="keyword">try</span>
    C1.MyInt := <span class="integer">666</span>;
    C2.Assign(C1);
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">C2 состояние: </span><span class="delimiter">'</span></span>, C2.MyInt);
  <span class="keyword">finally</span>
    FreeAndNil(C1);
    FreeAndNil(C2);
  <span class="keyword">end</span>;

  <span class="comment">// тестируем TMyClassDescendant.Assign</span>
  CD1 := TMyClassDescendant.Create;
  CD2 := TMyClassDescendant.Create;
  <span class="keyword">try</span>
    CD1.MyInt := <span class="integer">44</span>;
    CD1.MyString := <span class="string"><span class="delimiter">'</span><span class="content">что-нибудь</span><span class="delimiter">'</span></span>;
    CD2.Assign(CD1);
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">CD2 состояние: </span><span class="delimiter">'</span></span>, CD2.MyInt, <span class="char"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span>, CD2.MyString);
  <span class="keyword">finally</span>
    FreeAndNil(CD1);
    FreeAndNil(CD2);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Иногда более удобно написать альтернативный override метода <code>AssignTo</code> в копируемом классе, а не делать override метода <code>Assign</code> в классе, в который выполняется копирование.</p>
</div>
<div class="paragraph">
<p>Следует быть осторожным с <code>inherited</code> при написании <code>Assign</code>. <em>Inherited</em> из <code>TPersistent.Assign</code> должен вызываться исключительно в случаях, если Вы не можете самостоятельно выполнить копирование в своём коде (это позволит использовать метод <code>AssignTo</code> и создавать сообщения об ошибках, в случае, если копирование не может быть выполнено). С другой стороны, если данный класс является производным от класса, в котором уже есть метод <code>Assign</code>, то в данном случае <em>следует обязательно вызывать inherited</em> из <code>TMyClass.Assign</code>. См. пример выше.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
Обратите внимание, что наследуя класс <code>TPersistent</code> по умолчанию видимость полей становится <code>published</code>, чтобы дать возможность переводить в поток (streaming) производные от <code>TPersistent</code> классы. Однако, не все типы полей и свойств разрешены в секции <code>published</code>. Если возникают связанные с этим ошибки и нет необходимости передавать эти данные в поток, просто вручную измените уровень видимости на <code>public</code>. Детальнее см. раздел <a href="#_уровни_видимости">Уровни видимости</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_различные_полезные_возможности_языка">7. Различные полезные возможности языка</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_местные_вложенные_процедуры">7.1. Местные (вложенные) процедуры</h3>
<div class="paragraph">
<p>Внутри большой <em>процедуры</em> (это может быть функция, процедура, метод и т.п.) можно определить вложенную (местную) под-процедуру.</p>
</div>
<div class="paragraph">
<p>Таким образом такая локальная под-процедура имеет полный доступ (чтение и запись) всех параметров процедуры, в которой она находится, <em>если они были объявлены раньше, чем эта процедура</em>. Это очень удобно, позволяя разделять длинные процедуры на несколько небольших частей без необходимости передавать множество информации в виде параметров. Однако, не следует злоупотреблять этой возможностью. В случае, если местная (вложенная) процедура использует и, тем более, изменяет много переменных процедуры, в которой она находится, такой код становится сложным для понимания.</p>
</div>
<div class="paragraph">
<p>Данные два примера абсолютно эквивалентны:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">function</span> SumOfSquares(<span class="keyword">const</span> N: Integer): Integer;

  <span class="keyword">function</span> Square(<span class="keyword">const</span> Value: Integer): Integer;
  <span class="keyword">begin</span>
    Result := Value * Value;
  <span class="keyword">end</span>;

<span class="keyword">var</span>
  I: Integer;
<span class="keyword">begin</span>
  Result := <span class="integer">0</span>;
  <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> N <span class="keyword">do</span>
    Result := Result + Square(I);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>И второй вариант, в котором <code>Square</code> получает прямой доступ к переменной <code>I</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">function</span> SumOfSquares(<span class="keyword">const</span> N: Integer): Integer;
<span class="keyword">var</span>
  I: Integer;

  <span class="keyword">function</span> Square: Integer;
  <span class="keyword">begin</span>
    Result := I * I;
  <span class="keyword">end</span>;

<span class="keyword">begin</span>
  Result := <span class="integer">0</span>;
  <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> N <span class="keyword">do</span>
    Result := Result + Square;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Местные процедуры могут быть многократно вложенными&#8201;&#8212;&#8201;что означает, что внутри локальной процедуры можно определить местную локальную под-процедуру и т.д. Однако, не желательно этим увлекаться, поскольку в результате код может стать совершенно нечитабельным.</p>
</div>
</div>
<div class="sect2">
<h3 id="Callbacks">7.2. Колбэки&#8201;&#8212;&#8201;они же события, они же указатели на функции, они же процедурные переменные</h3>
<div class="paragraph">
<p>Они позволяют вызвать функцию не прямым указанием её названия, а посредством переменной. Эта переменная может быть назначена во время исполнения кода для указания на любую функцию <em>с указанными типами параметров и возвращаемых величин</em>.</p>
</div>
<div class="paragraph">
<p>Колбэки могут быть:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Обычными, что означает, что они могут указывать на любую нормальную функцию (т.е. не на метод или локальную функцию)</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>

<span class="keyword">function</span> Add(<span class="keyword">const</span> A, B: Integer): Integer;
<span class="keyword">begin</span>
  Result := A + B;
<span class="keyword">end</span>;

<span class="keyword">function</span> Multiply(<span class="keyword">const</span> A, B: Integer): Integer;
<span class="keyword">begin</span>
  Result := A * B;
<span class="keyword">end</span>;

<span class="keyword">type</span>
  TMyFunction = <span class="keyword">function</span> (<span class="keyword">const</span> A, B: Integer): Integer;

<span class="keyword">function</span> ProcessTheList(<span class="keyword">const</span> F: TMyFunction): Integer;
<span class="keyword">var</span>
  I: Integer;
<span class="keyword">begin</span>
  Result := <span class="integer">1</span>;
  <span class="keyword">for</span> I := <span class="integer">2</span> <span class="keyword">to</span> <span class="integer">10</span> <span class="keyword">do</span>
    Result := F(Result, I);
<span class="keyword">end</span>;

<span class="keyword">var</span>
  SomeFunction: TMyFunction;
<span class="keyword">begin</span>
  SomeFunction := @Add;
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">1 + 2 + 3 ... + 10 = </span><span class="delimiter">'</span></span>, ProcessTheList(SomeFunction));

  SomeFunction := @Multiply;
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">1 * 2 * 3 ... * 10 = </span><span class="delimiter">'</span></span>, ProcessTheList(SomeFunction));
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</li>
<li>
<p>Указывающими на метод: для этого в конце добавляется <code>of object</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  TMyMethod = <span class="keyword">procedure</span> (<span class="keyword">const</span> A: Integer) <span class="keyword">of</span> <span class="keyword">object</span>;

  TMyClass = <span class="keyword">class</span>
    CurrentValue: Integer;
    <span class="keyword">procedure</span> Add(<span class="keyword">const</span> A: Integer);
    <span class="keyword">procedure</span> Multiply(<span class="keyword">const</span> A: Integer);
    <span class="keyword">procedure</span> ProcessTheList(<span class="keyword">const</span> M: TMyMethod);
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.Add(<span class="keyword">const</span> A: Integer);
<span class="keyword">begin</span>
  CurrentValue := CurrentValue + A;
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.Multiply(<span class="keyword">const</span> A: Integer);
<span class="keyword">begin</span>
  CurrentValue := CurrentValue * A;
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.ProcessTheList(<span class="keyword">const</span> M: TMyMethod);
<span class="keyword">var</span>
  I: Integer;
<span class="keyword">begin</span>
  CurrentValue := <span class="integer">1</span>;
  <span class="keyword">for</span> I := <span class="integer">2</span> <span class="keyword">to</span> <span class="integer">10</span> <span class="keyword">do</span>
    M(I);
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C: TMyClass;
<span class="keyword">begin</span>
  C := TMyClass.Create;
  <span class="keyword">try</span>
    C.ProcessTheList(@C.Add);
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">1 + 2 + 3 ... + 10 = </span><span class="delimiter">'</span></span>, C.CurrentValue);

    C.ProcessTheList(@C.Multiply);
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">1 * 2 * 3 ... * 10 = </span><span class="delimiter">'</span></span>, C.CurrentValue);
  <span class="keyword">finally</span>
    FreeAndNil(C);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следует заметить, что <em>невозможно</em> передать обычные процедуры или функции как методы. Они несовместимы. Если Вам необходимо использовать колбэк <code>of object</code>, но не хотите создавать экземпляр-пустышку для класса, есть возможность передавать <a href="#_class_method">Class method</a> в качестве метода.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMyMethod = <span class="keyword">function</span> (<span class="keyword">const</span> A, B: Integer): Integer <span class="keyword">of</span> <span class="keyword">object</span>;

  TMyClass = <span class="keyword">class</span>
    <span class="keyword">class</span> <span class="keyword">function</span> Add(<span class="keyword">const</span> A, B: Integer): Integer
    <span class="keyword">class</span> <span class="keyword">function</span> Multiply(<span class="keyword">const</span> A, B: Integer): Integer
  <span class="keyword">end</span>;

<span class="keyword">var</span>
  M: TMyMethod;
<span class="keyword">begin</span>
  M := @TMyClass(<span class="keyword">nil</span>).Add;
  M := @TMyClass(<span class="keyword">nil</span>).Multiply;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>К сожалению, в данном случае приходится писать громоздкую конструкцию <code>@TMyClass(nil).Add</code>, а не просто <code>@TMyClass.Add</code>.</p>
</div>
</li>
<li>
<p>Может указывать на локальную процедуру: для этого её нужно объявить с <code>is nested</code> в конце, а также установить директиву <code>{$modeswitch nestedprocvars}</code> для данного участка кода. Детальнее см. <a href="#_местные_вложенные_процедуры">Местные (вложенные) процедуры</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_generic_и">7.3. Generic-и</h3>
<div class="paragraph">
<p>Generic-и - это очень мощная функция современных языков. Определение чего-либо (обычно - класса) может быть конкретизировано другим типом. Наиболее естественным примером является необходимость создать контейнер (список, словарь, дерево, граф&#8230;&#8203;): можно определить <em>список типа T</em>, а потом <em>specialize</em> (конкретизировать) его чтобы сразу получить <em>список из integer</em>, <em>список из string</em>, <em>список из TMyRecord</em> и т.д.</p>
</div>
<div class="paragraph">
<p>Generic-и в Паскале реализованы весьма подобно generic-ам в C++. Это означает, что они "конкретизируются" когда происходит specialize, что <em>немного</em> похоже на поведение макросов (однако, когда тип "конкретизирован", используются только эти конкретные определения, и таким образом невозможно "добавить" какое-либо неожиданное поведение в generic после его "конкретизации"). Преимуществом их является высокая скорость выполнения (оптимизированная для каждого конкретного типа) и поддержка типов любого размера. Можно использовать примитивные типы (integer, float) а также record, class и т.п. при specialize данного generic-а.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  generic TMyCalculator&lt;T&gt; = <span class="keyword">class</span>
    Value: T;
    <span class="keyword">procedure</span> Add(<span class="keyword">const</span> A: T);
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyCalculator.Add(<span class="keyword">const</span> A: T);
<span class="keyword">begin</span>
  Value := Value + A;
<span class="keyword">end</span>;

<span class="keyword">type</span>
  TMyFloatCalculator = specialize TMyCalculator&lt;Single&gt;;
  TMyStringCalculator = specialize TMyCalculator&lt;<span class="keyword">string</span>&gt;;

<span class="keyword">var</span>
  FloatCalc: TMyFloatCalculator;
  StringCalc: TMyStringCalculator;
<span class="keyword">begin</span>
  FloatCalc := TMyFloatCalculator.Create;
  <span class="keyword">try</span>
    FloatCalc.Add(<span class="float">3.14</span>);
    FloatCalc.Add(<span class="integer">1</span>);
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Сложение величин типа Float: </span><span class="delimiter">'</span></span>, FloatCalc.Value:<span class="integer">1</span>:<span class="integer">2</span>);
  <span class="keyword">finally</span>
    FreeAndNil(FloatCalc);
  <span class="keyword">end</span>;

  StringCalc := TMyStringCalculator.Create;
  <span class="keyword">try</span>
    StringCalc.Add(<span class="string"><span class="delimiter">'</span><span class="content">что-нибудь</span><span class="delimiter">'</span></span>);
    StringCalc.Add(<span class="string"><span class="delimiter">'</span><span class="content"> ещё</span><span class="delimiter">'</span></span>);
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Сложение величин типа String: </span><span class="delimiter">'</span></span>, StringCalc.Value);
  <span class="keyword">finally</span>
    FreeAndNil(StringCalc);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Возможности generic-ов не ограничиваются классами, можно создать generic функции и процедуры:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span> SysUtils;

<span class="comment">{ Примечание: этот пример требует FPC 3.1.1 и не скомпилируется в FPC 3.0.0 или более ранних версиях. }</span>

generic <span class="keyword">function</span> Min&lt;T&gt;(<span class="keyword">const</span> A, B: T): T;
<span class="keyword">begin</span>
  <span class="keyword">if</span> A &lt; B <span class="keyword">then</span>
    Result := A
  <span class="keyword">else</span>
    Result := B;
<span class="keyword">end</span>;

<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Min (1, 0): </span><span class="delimiter">'</span></span>, specialize Min&lt;Integer&gt;(<span class="integer">1</span>, <span class="integer">0</span>));
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Min (3.14, 5): </span><span class="delimiter">'</span></span>, specialize Min&lt;Single&gt;(<span class="float">3.14</span>, <span class="integer">5</span>):<span class="integer">1</span>:<span class="integer">2</span>);
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Min (</span><span class="char">''</span><span class="content">a</span><span class="char">''</span><span class="content">, </span><span class="char">''</span><span class="content">b</span><span class="char">''</span><span class="content">): </span><span class="delimiter">'</span></span>, specialize Min&lt;<span class="keyword">string</span>&gt;(<span class="char"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>, <span class="char"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>));
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_overload">7.4. Overload</h3>
<div class="paragraph">
<p>Методы (а также, глобальные функции и процедуры) с одинаковым именем могут существовать при условии, что они принимают разные параметры. На основании передаваемых процедуре параметров компилятор определяет, какую именно из этих функций использовать в данном случае.</p>
</div>
<div class="paragraph">
<p>По умолчанию overload использует стиль FPC. Это означает, что абсолютно все имена в пространстве имён (в классе или unit-е) равны, и скрывает все остальные методы в пространстве имён с более низким приоритетом. Например, если создать класс с методом <code>Foo(Integer)</code> и <code>Foo(string)</code>, и при этом класс наследует класс в котором уже есть <code>Foo(Float)</code>, то метод <code>Foo(Float)</code> невозможно будет вызвать напрямую, только с помощью приведения типа данного класса к родительскому классу. Чтобы избежать такого поведения, при объявлении процедур и функций следует использовать ключевое слово <code>overload</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_предобработка_кода">7.5. Предобработка кода</h3>
<div class="paragraph">
<p>Можно использовать простые директивы предобработки кода с целью:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>компиляции на основании различных условий (например, если код зависит от платформы, или других заданных вручную параметров),</p>
</li>
<li>
<p>чтобы включить один файл внутри другого,</p>
</li>
<li>
<p>для вызова беспараметрических макросов.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Обратите внимание, макросы с параметрами запрещены. В общем, следует избегать предобработки кода кроме случаев, когда она действительно необходима. Предобработка происходит перед парсингом, что значит, что она вполне может "ломать" обычный синтаксис языка Паскаль. Это мощно, но немного "грязно".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> PreprocessorStuff;
<span class="keyword">interface</span>

<span class="preprocessor">{$ifdef FPC}</span>
<span class="comment">{ всё что идёт внутри данного условия ifdef определено только для FPC, а не других компиляторов (например, Delphi). }</span>
<span class="keyword">procedure</span> Foo;
<span class="preprocessor">{$endif}</span>

<span class="comment">{ Определить константу NewLine. Это пример того, как &quot;нормальный&quot;
  синтаксис Паскаля &quot;поломан&quot; директивами предобработки.
  Если компилировать на Unix-системах (включая Linux, Android, Mac OS X),
  компилятор увидит следующее:

    const NewLine = #10;

  Если компилировать на Windows, компилятор увидит так:

    const NewLine = #13#10;

  Однако, на других операционных системах, код не скомпилируется,
  поскольку компилятор увидит следующее:

    const NewLine = ;

  Вообще, это *хорошо* что в данном случае возникает ошибка -- если возникнет
  необходимость портировать программу на другую операционную систему,
  которая не является ни Unix, ни Windows, то компилятор &quot;напомнит&quot;, что
  необходимо выбрать правильное значение NewLine для такой системы. }</span>

<span class="keyword">const</span>
  NewLine =
    <span class="preprocessor">{$ifdef UNIX}</span> <span class="char">#10</span> <span class="preprocessor">{$endif}</span>
    <span class="preprocessor">{$ifdef MSWINDOWS}</span> <span class="char">#13</span><span class="char">#10</span> <span class="preprocessor">{$endif}</span> ;

<span class="preprocessor">{$define MY_SYMBOL}</span>

<span class="preprocessor">{$ifdef MY_SYMBOL}</span>
<span class="keyword">procedure</span> Bar;
<span class="preprocessor">{$endif}</span>

<span class="preprocessor">{$define CallingConventionMacro := unknown}</span>
<span class="preprocessor">{$ifdef UNIX}</span>
  <span class="preprocessor">{$define CallingConventionMacro := cdecl}</span>
<span class="preprocessor">{$endif}</span>
<span class="preprocessor">{$ifdef MSWINDOWS}</span>
  <span class="preprocessor">{$define CallingConventionMacro := stdcall}</span>
<span class="preprocessor">{$endif}</span>
<span class="keyword">procedure</span> RealProcedureName; CallingConventionMacro; <span class="directive">external</span> <span class="string"><span class="delimiter">'</span><span class="content">some_external_library</span><span class="delimiter">'</span></span>;

<span class="keyword">implementation</span>

<span class="preprocessor">{$include some_file.inc}</span>
<span class="comment">// $I это удобное сокращение от $include, они идентичны</span>
<span class="preprocessor">{$I some_other_file.inc}</span>

<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Включаемые файлы обычно имеют расширение <code>.inc</code>, и используются для следующих двух целей:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Включаемый файл может содержать лишь другие директивы компилятора, которые "конфигурируют" исходный код программы. Например, можно создать файл <code>myconfig.inc</code> со следующим содержанием:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span>
<span class="preprocessor">{$H+}</span>
<span class="preprocessor">{$J-}</span>
<span class="preprocessor">{$modeswitch advancedrecords}</span>
<span class="preprocessor">{$ifndef VER3}</span>
  <span class="preprocessor">{$error Этот код может быть скомпилирован только в версии FPC не ниже 3.x.}</span>
<span class="preprocessor">{$endif}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь можно включить этот файл <code>{$I myconfig.inc}</code> в каждом unit-е исходного кода.</p>
</div>
</li>
<li>
<p>Второй важный пример использования - разделить unit на несколько файлов, и при этом всё же оставить его одним unit-ом (с учётом всех особенностей Паскаля). Не стоит злоупотреблять таким подходом. В первую очередь стоит думать о том, как разделить программу на несколько unit-ов, а не разделять её на множество include файлов. Однако, в общем, это довольно полезная и удобная техника.</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Такой подход позволяет избежать огромного количества unit-ов, и при этом исходные файлы не окажутся слишком длинными. Например, куда удобнее иметь один файл с <em>"часто используемыми GUI элементами"</em>, чем создавать <em>отдельные unit-ы для каждого GUI элемента"</em>, поскольку второй вариант сделает обычную "uses" неоправданно длинной (поскольку в GUI-приложении будут использоваться множество GUI элементов). Однако, размещение всех этих классов в одном файле <code>myunit.pas</code> приведёт к его большому размеру, что в свою очередь затруднит навигацию по файлу. Таким образом, разбить этот файл на несколько include файлов будет разумным.</p>
</li>
<li>
<p>Такой подход также позволяет легко создавать кросс-платформенный unit с уникальными частями для каждой платформы, что, например, может выглядеть следующим образом:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$ifdef UNIX}</span> <span class="preprocessor">{$I my_unix_implementation.inc}</span> <span class="preprocessor">{$endif}</span>
<span class="preprocessor">{$ifdef MSWINDOWS}</span> <span class="preprocessor">{$I my_windows_implementation.inc}</span> <span class="preprocessor">{$endif}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Иногда это более удобно, чем писать длинный код со множеством <code>{$ifdef UNIX}</code>, <code>{$ifdef MSWINDOWS}</code> вперемешку с нормальным кодом (определение переменных, описание процедур). Повышается и читабельность кода. Эту технику можно применять более агрессивно, используя опцию командной строки <code>-Fi</code> при вызове FPC, чтобы включить целые папки только для конкретных платформ. Таким образом можно организовать множество версий include файлов типа <code>{$I my platform_specific_implementation.inc}</code>. При этом компилятор автоматически найдёт правильную версию.</p>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_record">7.6. Record</h3>
<div class="paragraph">
<p><em>Record</em> является своеобразным контейнером для других переменных. Она является очень, очень упрощённым <em>классом</em>: в record-ах нет наследования, нет виртуальных методов. Они несколько подобны <em>structure</em> в C-подобных языках.</p>
</div>
<div class="paragraph">
<p>Применяя директиву <code>{$modeswitch advancedrecords}</code>, появляется возможность добавить методы и уровни видимости в record и использовать любые особенности языка, доступные классам, которые <em>не нарушают простую и предсказуемую раскладку памяти для record</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="preprocessor">{$modeswitch advancedrecords}</span>
<span class="keyword">type</span>
  TMyRecord = <span class="keyword">record</span>
  <span class="directive">public</span>
    I, Square: Integer;
    <span class="keyword">procedure</span> WriteLnDescription;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyRecord.WriteLnDescription;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Квадрат числа </span><span class="delimiter">'</span></span>, I, <span class="string"><span class="delimiter">'</span><span class="content"> равен </span><span class="delimiter">'</span></span>, Square);
<span class="keyword">end</span>;

<span class="keyword">var</span>
  A: <span class="keyword">array</span> [<span class="integer">0</span>..<span class="integer">9</span>] <span class="keyword">of</span> TMyRecord;
  R: TMyRecord;
  I: Integer;
<span class="keyword">begin</span>
  <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> <span class="integer">9</span> <span class="keyword">do</span>
  <span class="keyword">begin</span>
    A[I].I := I;
    A[I].Square := I * I;
  <span class="keyword">end</span>;

  <span class="keyword">for</span> R <span class="keyword">in</span> A <span class="keyword">do</span>
    R.WriteLnDescription;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>В современном Паскале, в первую очередь лучше использовать <code>class</code>, а не <code>record</code>, поскольку классы имеют множество дополнительных полезных возможностей, как конструкторы и наследование.
Однако, record-ы всё ещё могут оказаться полезными если необходима скорость или предсказуемая раскладка памяти:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Record-ам не требуется constructor или destructor. Они определяются как переменные. Их содержимое не определено в начале (так называемый "мусор в памяти"), кроме случаев автоматически управляемых типов, таких как string, которые всегда инициализируются пустыми. Таким образом следует быть более аккуратным при их использовании, однако преимуществом такого подхода будет увеличение скорости исполнения программы.</p>
</li>
<li>
<p>Массивы, состоящие из record-ов однородно располагаются в памяти и таким образом их удобно кешировать.</p>
</li>
<li>
<p>Разметка памяти (размер и расстояние между каждым полем) для record-ов чётко определена в некоторых ситуациях: когда запрашивается <em>C layout</em> или если используется <code>packed record</code>. Это может быть полезным в следующих случаях:</p>
<div class="ulist">
<ul>
<li>
<p>для связи между библиотеками, написанными в других языках программирования и предоставляющих API, который основывается на данных типа record,</p>
</li>
<li>
<p>для чтения и записи бинарных файлов,</p>
</li>
<li>
<p>для выполнения "грязных" низкоуровневых оптимизаций (как небезопасное приведение одного типа в другой, на основании их однозначного представления в памяти).</p>
</li>
</ul>
</div>
</li>
<li>
<p>В record-ах можно также использовать часть <code>case</code>, которая работает как <em>union</em> в C-подобных языках и позволяет интерпретировать одну и ту же область памяти, как различные типы данных, в зависимости от необходимости. Таким образом можно достичь более высокой эффективности использования памяти в некоторых случаях. В том числе, можно выполнять некоторые "грязные" низкоуровневые оптимизации.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_устаревшие_object">7.7. Устаревшие object</h3>
<div class="paragraph">
<p>Давным-давно, в Turbo Pascal был введён новый тип синтаксиса с функционалом, похожим на классы, который задавался ключевым словом <code>object</code>. По сути, это - нечто среднее между <code>record</code> и современным <code>class</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Такие object-ы можно создавать / освобождать, и в процессе этого можно вызвать их constructor / destructor.</p>
</li>
<li>
<p>Но их можно просто объявить и использовать как обычную record. Простые типы <code>record</code> или <code>object</code> не являются указателями (pointer-ами) на что-либо, они, собственно, являются данными. Это делает их весьма удобными в случаях небольших объёмов информации, когда многократное распределение или освобождение памяти не всегда оправдано.</p>
</li>
<li>
<p>Устаревшие object-ы имеют наследование и виртуальные методы, впрочем, в несколько отличном виде от современных классов. Следует быть внимательным: если попытаться использовать object, имеющий виртуальные методы, без вызова его constructor-а, могут возникнуть ошибки.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В большинстве случаев крайне не советуется использовать устаревшие objects-ы. Современные <em>class-ы</em> имеют гораздо более широкий функционал. А в случае если необходимо повысить скорость выполнения, можно использовать record-ы (включая <em>advanced records</em>). Такие подходы обычно лучше, чем устаревшие object-ы.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pointer_ы">7.8. Pointer-ы</h3>
<div class="paragraph">
<p>В Паскале возможно создать <em>pointer</em> (указатель) на любой тип данных. Указатель на тип <code>TMyRecord</code> определяется с помощью синтаксиса <code>^TMyRecord</code>, и чаще всего такие pointer-ы называют <code>PMyRecord</code>. В качестве классического примера рассмотрим связанный список целых чисел, организованный с помощью record:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  PMyRecord = ^TMyRecord;
  TMyRecord = <span class="keyword">record</span>
    Value: Integer;
    Next: PMyRecord;
  <span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следует обратить внимание, что здесь было использовано рекурсивное определение (тип <code>PMyRecord</code> определяется с помощью <code>TMyRecord</code>, а <code>TMyRecord</code> использует в своём определении <code>PMyRecord</code>). Можно определить pointer на тип, <em>который ещё не был объявлен</em>, в том случае, если он будет определён в том же самом блоке <code>type</code>.</p>
</div>
<div class="paragraph">
<p>Можно распределять и освобождать память для pointer-ов с помощью методов <code>New</code> / <code>Dispose</code>, или (более низкоуровневых, но не типобезопасных) методов <code>GetMem</code> / <code>FreeMem</code>. Для доступа к данным, на которые pointer указывает, после него следует добавить оператор <code>^</code> (в виде <code>MyInteger := MyPointerToInteger^</code>). Обратная операция (получить pointer на существующую переменную) выполняется с помощью оператора-префикса <code>@</code> (например, <code>MyPointerToInteger := @MyInteger</code>).</p>
</div>
<div class="paragraph">
<p>Существует также самый общий тип <code>Pointer</code>, который не указывает на конкретный тип данных и подобен <code>void*</code> в C-подобных языках. Он совершенно не типобезопасен, и его можно привести его тип в любой другой тип pointer-а.</p>
</div>
<div class="paragraph">
<p>Следует помнить, что <em>экземпляр класса</em> также является pointer-ом, хоть для работы с ним и не нужно использовать дополнительных операторов <code>^</code> и <code>@</code>.
Рекурсивные определения также возможны и для классов, и в данном случае всё будет выглядеть ещё проще:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
    Value: Integer;
    Next: TMyClass;
  <span class="keyword">end</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_перегрузка_операторов">7.9. Перегрузка операторов</h3>
<div class="paragraph">
<p>В Паскале существует возможность "перегрузить" (overload) значение многих операторов языка, например определить сложение и умножение пользовательских типов данных. Рассмотрим следующий пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span> StrUtils;

operator* (<span class="keyword">const</span> S: <span class="keyword">string</span>; <span class="keyword">const</span> A: Integer): <span class="keyword">string</span>;
<span class="keyword">begin</span>
  Result := DupeString(S, A);
<span class="keyword">end</span>;

<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">повтор</span><span class="delimiter">'</span></span> * <span class="integer">10</span>);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Можно также перегружать операторы над классами. Учитывая то, что обычно в такой функции-операторе создаётся новый экземпляр класса, вызывающий код должен позаботиться об надлежащем освобождении памяти.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
    MyInt: Integer;
  <span class="keyword">end</span>;

operator* (<span class="keyword">const</span> C1, C2: TMyClass): TMyClass;
<span class="keyword">begin</span>
  Result := TMyClass.Create;
  Result.MyInt := C1.MyInt * C2.MyInt;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C1, C2: TMyClass;
<span class="keyword">begin</span>
  C1 := TMyClass.Create;
  <span class="keyword">try</span>
    C1.MyInt := <span class="integer">12</span>;
    C2 := C1 * C1;
    <span class="keyword">try</span>
      WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">12 * 12 = </span><span class="delimiter">'</span></span>, C2.MyInt);
    <span class="keyword">finally</span>
      FreeAndNil(C2);
    <span class="keyword">end</span>;
  <span class="keyword">finally</span>
    FreeAndNil(C1);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Можно перегружать и операции над record-ами. Обычно это проще, чем в случае классов, поскольку нет необходимости выполнять операции по распределению или освобождению памяти.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  TMyRecord = <span class="keyword">record</span>
    MyInt: Integer;
  <span class="keyword">end</span>;

operator* (<span class="keyword">const</span> C1, C2: TMyRecord): TMyRecord;
<span class="keyword">begin</span>
  Result.MyInt := C1.MyInt * C2.MyInt;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  R1, R2: TMyRecord;
<span class="keyword">begin</span>
  R1.MyInt := <span class="integer">12</span>;
  R2 := R1 * R1;
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">12 * 12 = </span><span class="delimiter">'</span></span>, R2.MyInt);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>При работе с record-ами лучше использовать режим <code>{$modeswitch advancedrecords}</code> и перегружать операторы в виде <code>class operator</code> внутри объявления record-а. Такой подход позволяет использовать generic классы которые зависят от существования какого-либо оператора (например <code>TFPGList</code>, который зависит от доступности оператора равенства). В противоположном случае "глобальное" определение оператора (не внутри объявления данной record) не будет найдено (поскольку оно не доступно коду, который используется в <code>TFPGList</code>), и не удастся specialize список в виде <code>specialize TFPGList&lt;TMyRecord&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="preprocessor">{$modeswitch advancedrecords}</span>
<span class="keyword">uses</span>
  SysUtils, FGL;

<span class="keyword">type</span>
  TMyRecord = <span class="keyword">record</span>
    MyInt: Integer;
    <span class="keyword">class</span> operator+ (<span class="keyword">const</span> C1, C2: TMyRecord): TMyRecord;
    <span class="keyword">class</span> operator= (<span class="keyword">const</span> C1, C2: TMyRecord): boolean;
  <span class="keyword">end</span>;

<span class="keyword">class</span> operator TMyRecord.+ (<span class="keyword">const</span> C1, C2: TMyRecord): TMyRecord;
<span class="keyword">begin</span>
  Result.MyInt := C1.MyInt + C2.MyInt;
<span class="keyword">end</span>;

<span class="keyword">class</span> operator TMyRecord.= (<span class="keyword">const</span> C1, C2: TMyRecord): boolean;
<span class="keyword">begin</span>
  Result := C1.MyInt = C2.MyInt;
<span class="keyword">end</span>;

<span class="keyword">type</span>
  TMyRecordList = specialize TFPGList&lt;TMyRecord&gt;;

<span class="keyword">var</span>
  R, ListItem: TMyRecord;
  L: TMyRecordList;
<span class="keyword">begin</span>
  L := TMyRecordList.Create;
  <span class="keyword">try</span>
    R.MyInt := <span class="integer">1</span>;   L.Add(R);
    R.MyInt := <span class="integer">10</span>;  L.Add(R);
    R.MyInt := <span class="integer">100</span>; L.Add(R);

    R.MyInt := <span class="integer">0</span>;
    <span class="keyword">for</span> ListItem <span class="keyword">in</span> L <span class="keyword">do</span>
      R := ListItem + R;

    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">1 + 10 + 100 = </span><span class="delimiter">'</span></span>, R.MyInt);
  <span class="keyword">finally</span>
    FreeAndNil(L);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_дополнительные_возможности_классов">8. Дополнительные возможности классов</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_различие_private_и_strict_private">8.1. Различие private и strict private</h3>
<div class="paragraph">
<p>Спецификатор видимости <code>private</code> означает что поле или метод не доступны извне данного класса. Однако из данного правила есть одно исключение: любой код <em>в данном unit-е</em> может преодолеть это ограничение и иметь полный доступ к private полям и методам. Программист на C++ сказал бы, что в Паскале <em>все классы в одном unit-е являются "друзьями"</em>. Часто это весьма удобно.</p>
</div>
<div class="paragraph">
<p>Однако, при создании unit-ов большого размера со множеством не очень близко интегрированных классов, более безопасным является применение видимости <code>strict private</code>. Как можно легко догадаться, это означает что поле или метод не доступны извне данного класса. Точка. Никаких исключений.</p>
</div>
<div class="paragraph">
<p>Таким же образом различаются спецификаторы видимости <code>protected</code> (видимый наследникам данного класса или "друзьям" в том же unit-е) и <code>strict protected</code> (видимы только и исключительно наследникам данного класса. Точка).</p>
</div>
</div>
<div class="sect2">
<h3 id="_дополнительные_возможности_объявления_классов_и_локальные_классы">8.2. Дополнительные возможности объявления классов и локальные классы</h3>
<div class="paragraph">
<p>Внутри определения класса можно создавать константы (<code>const</code>) или типы (<code>type</code>). Таким образом можно даже создать класс внутри класса. Спецификаторы видимости будут работать как обычно, и такие локальные классы могут быть private (не видимые "внешнему миру"), что иногда удобно.</p>
</div>
<div class="paragraph">
<p>Следует обратить внимание, чтобы определить поле после константы или типа будет необходимо использовать блок <code>var</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
  <span class="directive">private</span>
    <span class="keyword">type</span>
      TInternalClass = <span class="keyword">class</span>
        Velocity: Single;
        <span class="keyword">procedure</span> DoSomething;
      <span class="keyword">end</span>;
    <span class="keyword">var</span>
      FInternalClass: TInternalClass;
  <span class="directive">public</span>
    <span class="keyword">const</span>
      DefaultVelocity = <span class="integer">10</span><span class="float">0.0</span>;
    <span class="keyword">constructor</span> Create;
    <span class="keyword">destructor</span> Destroy; <span class="directive">override</span>;
  <span class="keyword">end</span>;

<span class="keyword">constructor</span> TMyClass.Create;
<span class="keyword">begin</span>
  <span class="keyword">inherited</span>;
  FInternalClass := TInternalClass.Create;
  FInternalClass.Velocity := DefaultVelocity;
  FInternalClass.DoSomething;
<span class="keyword">end</span>;

<span class="keyword">destructor</span> TMyClass.Destroy;
<span class="keyword">begin</span>
  FreeAndNil(FInternalClass);
  <span class="keyword">inherited</span>;
<span class="keyword">end</span>;

<span class="comment">{ Обратите внимание на префикс &quot;TMyClass.TInternalClass.&quot; }</span>
<span class="keyword">procedure</span> TMyClass.TInternalClass.DoSomething;
<span class="keyword">begin</span>
<span class="keyword">end</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_class_method">8.3. Class method</h3>
<div class="paragraph">
<p>Существуют методы, которые можно вызвать из класса вообще (<code>TMyClass</code>), не обязательно из его конкретного экземпляра.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TEnemy = <span class="keyword">class</span>
    <span class="keyword">procedure</span> Kill;
    <span class="keyword">class</span> <span class="keyword">procedure</span> KillAll;
  <span class="keyword">end</span>;

<span class="keyword">var</span>
  E: TEnemy;
<span class="keyword">begin</span>
  E := TEnemy.Create;
  <span class="keyword">try</span>
    E.Kill;
  <span class="keyword">finally</span>
    FreeAndNil(E);
  <span class="keyword">end</span>;
  TEnemy.KillAll;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание, что они также могут быть виртуальными&#8201;&#8212;&#8201;иногда это весьма удобно, особенно, если применяется совместно с понятием <a href="#_ссылки_на_класс">Ссылки на класс</a>.</p>
</div>
<div class="paragraph">
<p>Следует отметить, что constructor всегда работает, как class method когда вызывается "обычным образом" (<code>MyInstance := TMyClass.Create(&#8230;&#8203;);</code>). Впрочем, можно вызвать конструктор в данном конкретном экземпляре класса как метод&#8201;&#8212;&#8201;и он тогда и сработает как обычный метод. Таким образом можно сделать удобную "цепочку" constructor-ов, когда один constructor (например, перегруженный для принятия дополнительных параметров) выполняет определённый код, а затем вызывает другой constructor (например, беспараметрический).</p>
</div>
</div>
<div class="sect2">
<h3 id="_ссылки_на_класс">8.4. Ссылки на класс</h3>
<div class="paragraph">
<p><em>Ссылки на класс</em> позволяют выбрать класс в процессе исполнения программы, например, для вызова class method-а или constructor-а не определив заранее, какой именно класс будет использоваться. Такой тип объявляется следующим образом: <code>class of TMyClass</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>(TComponent)
  <span class="keyword">end</span>;

  TMyClass1 = <span class="keyword">class</span>(TMyClass)
  <span class="keyword">end</span>;

  TMyClass2 = <span class="keyword">class</span>(TMyClass)
  <span class="keyword">end</span>;

  TMyClassRef = <span class="keyword">class</span> <span class="keyword">of</span> TMyClass;

<span class="keyword">var</span>
  C: TMyClass;
  ClassRef: TMyClassRef;
<span class="keyword">begin</span>
  <span class="comment">// Можно сделать так:</span>

  C := TMyClass.Create(<span class="keyword">nil</span>); FreeAndNil(C);
  C := TMyClass1.Create(<span class="keyword">nil</span>); FreeAndNil(C);
  C := TMyClass2.Create(<span class="keyword">nil</span>); FreeAndNil(C);

  <span class="comment">// А с помощью ссылки на класс можно сделать следующим образом:</span>

  ClassRef := TMyClass;
  C := ClassRef.Create(<span class="keyword">nil</span>); FreeAndNil(C);

  ClassRef := TMyClass1;
  C := ClassRef.Create(<span class="keyword">nil</span>); FreeAndNil(C);

  ClassRef := TMyClass2;
  C := ClassRef.Create(<span class="keyword">nil</span>); FreeAndNil(C);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ссылки на класс можно комбинировать с виртуальными class method-ами. Работает это подобно классам с виртуальными методами&#8201;&#8212;&#8201;конкретный метод, который необходимо выполнить определяется уже в процессе выполнения программы.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>(TComponent)
    <span class="keyword">class</span> <span class="keyword">procedure</span> DoSomething; <span class="directive">virtual</span>; <span class="directive">abstract</span>;
  <span class="keyword">end</span>;

  TMyClass1 = <span class="keyword">class</span>(TMyClass)
    <span class="keyword">class</span> <span class="keyword">procedure</span> DoSomething; <span class="directive">override</span>;
  <span class="keyword">end</span>;

  TMyClass2 = <span class="keyword">class</span>(TMyClass)
    <span class="keyword">class</span> <span class="keyword">procedure</span> DoSomething; <span class="directive">override</span>;
  <span class="keyword">end</span>;

  TMyClassRef = <span class="keyword">class</span> <span class="keyword">of</span> TMyClass;

<span class="keyword">var</span>
  C: TMyClass;
  ClassRef: TMyClassRef;
<span class="keyword">begin</span>
  ClassRef := TMyClass1;
  ClassRef.DoSomething;

  ClassRef := TMyClass2;
  ClassRef.DoSomething;

  <span class="comment">{ А следующая строка приведёт к ошибке выполнения,
    поскольку DoSomething является abstract в TMyClass. }</span>
  ClassRef := TMyClass;
  ClassRef.DoSomething;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если есть экземпляр класса и необходимо создать ссылку на этот класс (не на какой-либо объявленный класс, а на конкретного наследника, который был использован при создании данного экземпляра класса), можно использовать свойство <code>ClassType</code>. Вообще говоря, объявленный тип <code>ClassType</code> является <code>TClass</code>, который в свою очередь является <code>class of TObject</code>. Его тип можно привести во что либо более конкретное, когда есть информация, чем именно является данный экземпляр.</p>
</div>
<div class="paragraph">
<p><code>ClassType</code> также можно использовать  для вызова виртуальных методов, включая виртуальные constructor-ы. Такой подход позволяет создать такие методы, как <code>Clone</code> которые создают экземпляр <em>как точную копию данного класса в конкретный момент исполнения программы</em>. Можно совместить такой подход с Assign (см. <a href="#_клонирование_классов_tpersistent_assign">Клонирование классов: TPersistent.Assign</a>) для того, чтобы метод возвращал новую, готовую к работе копию текущего экземпляра.</p>
</div>
<div class="paragraph">
<p>Следует обратить внимание, что подобный подход сработает только если constructor данного класса виртуальный. Например, его можно использовать с наследниками стандартного класса <code>TComponent</code>, поскольку все они выполняют override виртуального constructor-а <code>TComponent.Create(AOwner: TComponent)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>(TComponent)
    <span class="keyword">procedure</span> Assign(Source: TPersistent); <span class="directive">override</span>;
    <span class="keyword">function</span> Clone(AOwner: TComponent): TMyClass;
  <span class="keyword">end</span>;

  TMyClassRef = <span class="keyword">class</span> <span class="keyword">of</span> TMyClass;

<span class="keyword">function</span> TMyClass.Clone(AOwner: TComponent): TMyClass;
<span class="keyword">begin</span>
  <span class="comment">// Таким образом будет создан класс конкретного типа TMyClass:</span>
  <span class="comment">// Result := TMyClass.Create(AOwner);</span>
  <span class="comment">// А такой подход может создать класс как типа TMyClass, так и его наследников:</span>
  Result := TMyClassRef(ClassType).Create(AOwner);
  Result.Assign(Self);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_class_helper">8.5. Class helper</h3>
<div class="paragraph">
<p><em>Метод</em> является лишь процедурой внутри конкретного класса. Извне класса он вызывается с помощью специального синтаксиса <code>MyInstance.MyMethod(&#8230;&#8203;)</code>. И через некоторое время приходит привычка, что <em>если нужно произвести действие над классом X, следует писать</em> <code>X.Action(&#8230;&#8203;)</code>.</p>
</div>
<div class="paragraph">
<p>Однако, иногда возникает необходимость выполнить что-либо, что концептуально является <em>действием на класс TMyClass</em>, однако при этом не изменяя исходный код <em>TMyClass</em>. Причин тому может быть несколько. Например, это может быть исходный код, написанный другим программистом, который не следует или невозможно изменять. Также иногда причиной тому могут быть зависимости&#8201;&#8212;&#8201;добавление метода <code>Render</code> к классу <code>TMy3DObject</code> кажется вполне логичным, однако, возможно, имплементация класса <code>TMy3DObject</code> должна быть независимой от кода рендера? В таких случаях удобнее "расширить" существующий класс, добавив к нему функционал, при этом не изменяя его исходный код.</p>
</div>
<div class="paragraph">
<p>Наиболее простой путь сделать это - создать глобальную процедуру, которая будет принимать ссылку на <code>TMy3DObject</code> как параметр.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">procedure</span> Render(<span class="keyword">const</span> Obj1: TMy3DObject; <span class="keyword">const</span> Color: TColor);
<span class="keyword">var</span>
  I: Integer;
<span class="keyword">begin</span>
  <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> Obj1.ShapesCount - <span class="integer">1</span> <span class="keyword">do</span>
    RenderMesh(Obj1.Shape[I].Mesh, Color);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>И это действительно сработает. Однако, недостаток такого подхода - он выглядит не очень красиво. Ведь обычно мы вызываем действия над классом с помощью <code>X.Action(&#8230;&#8203;)</code>, а тут нам приходится использовать иной синтаксис: <code>Render(X, &#8230;&#8203;)</code>. Было бы куда удобнее записать <code>X.Render(&#8230;&#8203;)</code>, даже для случаев, когда <code>Render</code> не описан в unit-е, в котором находится <code>TMy3DObject</code>.</p>
</div>
<div class="paragraph">
<p>Для этого и существуют class helper-ы, дающие возможность создать процедуры/функции, которые оперируют данным классом и вызываются таким же образом, как и остальные методы класса. Однако они не являются "обычными" методами&#8201;&#8212;&#8201;они "добавляются" извне определения класса <code>TMy3DObject</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMy3DObjectHelper = <span class="keyword">class</span> helper <span class="keyword">for</span> TMy3DObject
    <span class="keyword">procedure</span> Render(<span class="keyword">const</span> Color: TColor);
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMy3DObjectHelper.Render(<span class="keyword">const</span> Color: TColor);
<span class="keyword">var</span>
  I: Integer;
<span class="keyword">begin</span>
  <span class="comment">{ Обратите внимание, мы получаем доступ к ShapesCount, Shape без дополнительных указаний типа TMy3DObject.ShapesCount }</span>
  <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> ShapesCount - <span class="integer">1</span> <span class="keyword">do</span>
    RenderMesh(Shape[I].Mesh, Color);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
Более общая концепция является <em>"type helper"</em>, используя которую становится возможным добавлять методы даже к самым примитивным типам, например integer. Можно также создать <em>"record helper"</em> чтобы&#8230;&#8203; ну, Вы поняли. Детальнее см. здесь: <a href="http://lists.freepascal.org/fpc-announce/2013-February/000587.html" class="bare">http://lists.freepascal.org/fpc-announce/2013-February/000587.html</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_виртуальные_constructor_ы_destructor_ы">8.6. Виртуальные constructor-ы, destructor-ы</h3>
<div class="paragraph">
<p>Имя destructor-а всегда должно быть <code>Destroy</code>, и он всегда является virtual (поскольку он вызывается без указания конкретного класса при компиляции) и беспараметрический.</p>
</div>
<div class="paragraph">
<p>В качестве имени constructor-а принято использовать <code>Create</code>. Можно использовать и другое имя, однако здесь следует быть аккуратным&#8201;&#8212;&#8201;например, создав <code>CreateMy</code>, всегда создайте и <code>Create</code>, иначе constructor <code>Create</code> будет всё равно доступен из родительского класса и может быть вызван в обход конкретного <code>CreateMy</code> конструктора.</p>
</div>
<div class="paragraph">
<p>В базовом классе <code>TObject</code> constructor не является виртуальным, и при создании наследников его можно изменить. Новый constructor просто спрячет constructor родительского класса (примечание: не используйте <code>overload</code>, в данном случае это не сработает).</p>
</div>
<div class="paragraph">
<p>В наследниках же класса <code>TComponent</code>, следует выполнять <code>constructor Create(AOwner: TComponent); override;</code>. Для решения задач потоковой передачи данных, а также для создания класса без указания конкретного типа при написании программы, виртуальные constructor-ы являются очень удобными (см. раздел <a href="#_ссылки_на_класс">Ссылки на класс</a> выше).</p>
</div>
</div>
<div class="sect2">
<h3 id="_ошибки_при_исполнении_constructor_а">8.7. Ошибки при исполнении constructor-а</h3>
<div class="paragraph">
<p>Что произойдёт если в процессе выполнения constructor-а возникнет ошибка? Строка</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">X := TMyClass.Create;</code></pre>
</div>
</div>
<div class="paragraph">
<p>не будет выполнена до конца, и <code>X</code> не может быть присвоено какое-либо значение. Кто будет выполнять очистку после частично сконструированного класса?</p>
</div>
<div class="paragraph">
<p>В объектном Паскале существует следующее решение. Если возникла ошибка при исполнении constructor-а, то сразу вызывается destructor. Именно по этой причине <em>этот destructor должен быть "дубовым"</em>, т.е. сработать в любом случае, даже на частично сконструированном классе. Обычно это не сложно, если освобождать всё безопасным образом, например, с помощью <code>FreeAndNil</code>.</p>
</div>
<div class="paragraph">
<p>Также можно полагаться на факт, что перед вызовом constructor-а <em>вся память гарантированно обнуляется</em>. Таким образом, при создании все ссылки внутри класса являются <code>nil</code>, а числа равны 0 и т.п.</p>
</div>
<div class="paragraph">
<p>Т.е. следующий код сработает без утечек памяти:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  TGun = <span class="keyword">class</span>
  <span class="keyword">end</span>;

  TPlayer = <span class="keyword">class</span>
    Gun1, Gun2: TGun;
    <span class="keyword">constructor</span> Create;
    <span class="keyword">destructor</span> Destroy; <span class="directive">override</span>;
  <span class="keyword">end</span>;

<span class="keyword">constructor</span> TPlayer.Create;
<span class="keyword">begin</span>
  <span class="keyword">inherited</span>;
  Gun1 := TGun.Create;
  <span class="keyword">raise</span> Exception.Create(<span class="string"><span class="delimiter">'</span><span class="content">Вызваем exception из constructor-а!</span><span class="delimiter">'</span></span>);
  Gun2 := TGun.Create;
<span class="keyword">end</span>;

<span class="keyword">destructor</span> TPlayer.Destroy;
<span class="keyword">begin</span>
  <span class="comment">{ В данном случае в результате ошибки в constructor-е, у нас
    может оказаться Gun1 &lt;&gt; nil и Gun2 = nil. Смиритесь.
    В таком случае, FreeAndNil справится с задачей без каких-либо
    дополнительных действий с нашей стороны, поскольку FreeAndNil проверяет
    является ли экземпляр класса nil перед вызовом соответствующего destructor-а. }</span>
  FreeAndNil(Gun1);
  FreeAndNil(Gun2);
  <span class="keyword">inherited</span>;
<span class="keyword">end</span>;

<span class="keyword">begin</span>
  <span class="keyword">try</span>
    TPlayer.Create;
  <span class="keyword">except</span>
    <span class="directive">on</span> E: Exception <span class="keyword">do</span>
      WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Ошибка </span><span class="delimiter">'</span></span> + E.ClassName + <span class="string"><span class="delimiter">'</span><span class="content">: </span><span class="delimiter">'</span></span> + E.Message);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_интерфейсы">9. Интерфейсы</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_хорошие_corba_интерфейсы">9.1. Хорошие (CORBA) интерфейсы</h3>
<div class="paragraph">
<p><em>Интерфейс</em>, так же как и класс, объявляет API, но не определяет его конкретную реализацию. Класс может иметь только один родительский класс, однако может реализовать множество интерфейсов.</p>
</div>
<div class="paragraph">
<p>Можно выполнить приведение типа класса к любому интерфейсу, которому он соответствует, и потом <em>вызывать его методы через этот интерфейс</em>. Это позволяет унифицированным образом обрабатывать множество классов, которые не наследуют друг друга, однако имеют подобный функционал. Такой подход полезен в случае, если недостаточно простого механизма наследования.</p>
</div>
<div class="paragraph">
<p><em>Интерфейсы CORBA</em> в Object Pascal работают в значительной степени так, как и интерфейсы в Java (<a href="https://docs.oracle.com/javase/tutorial/java/concepts/interface.html" class="bare">https://docs.oracle.com/javase/tutorial/java/concepts/interface.html</a>) или в C# (<a href="https://msdn.microsoft.com/en-us/library/ms173156.aspx" class="bare">https://msdn.microsoft.com/en-us/library/ms173156.aspx</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="preprocessor">{$interfaces corba}</span>

<span class="keyword">uses</span>
  SysUtils, Classes;

<span class="keyword">type</span>
  IMyInterface = <span class="keyword">interface</span>
  [<span class="string"><span class="delimiter">'</span><span class="content">{79352612-668B-4E8C-910A-26975E103CAC}</span><span class="delimiter">'</span></span>]
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass1 = <span class="keyword">class</span>(IMyInterface)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass2 = <span class="keyword">class</span>(IMyInterface)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass3 = <span class="keyword">class</span>
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass1.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass1.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass2.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass2.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass3.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass3.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> UseThroughInterface(I: IMyInterface);
<span class="keyword">begin</span>
  <span class="directive">Write</span>(<span class="string"><span class="delimiter">'</span><span class="content">Стреляем... </span><span class="delimiter">'</span></span>);
  I.Shoot;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C1: TMyClass1;
  C2: TMyClass2;
  C3: TMyClass3;
<span class="keyword">begin</span>
  C1 := TMyClass1.Create;
  C2 := TMyClass2.Create;
  C3 := TMyClass3.Create;
  <span class="keyword">try</span>
    <span class="keyword">if</span> C1 <span class="keyword">is</span> IMyInterface <span class="keyword">then</span>
      UseThroughInterface(C1 <span class="keyword">as</span> IMyInterface);
    <span class="keyword">if</span> C2 <span class="keyword">is</span> IMyInterface <span class="keyword">then</span>
      UseThroughInterface(C2 <span class="keyword">as</span> IMyInterface);
    <span class="keyword">if</span> C3 <span class="keyword">is</span> IMyInterface <span class="keyword">then</span>
      UseThroughInterface(C3 <span class="keyword">as</span> IMyInterface);
  <span class="keyword">finally</span>
    FreeAndNil(C1);
    FreeAndNil(C2);
    FreeAndNil(C3);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_corba_и_com_интерфейсы">9.2. CORBA и COM интерфейсы</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Почему интерфейсы названы "CORBA"?</dt>
<dd>
<p>Название <strong>CORBA</strong> крайне неудачное. Куда лучший термин был бы <strong>обычный интерфейс</strong>. Такие интерфейсы являются <em>"чистой особенностью языка"</em>. Их можно использовать, если возникает необходимость приведения типов различных классов в виде одинакового интерфейса, поскольку у них одинаковая API.</p>
<div class="paragraph">
<p>Не смотря на то, что эти интерфейсы могут использоваться совместно с <em>технологией CORBA (Common Object Request Broker Architecture)</em> (см. <a href="https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture" class="bare">https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture</a>), они <em>не</em> имеют к ней никакого отношения.</p>
</div>
</dd>
<dt class="hdlist1">Требуется ли задавать <code>{$interfaces corba}</code> ?</dt>
<dd>
<p>Да, поскольку по умолчанию будут созданы <em>COM интерфейсы</em>. Последнее можно указать явно с помощью директивы <code>{$interfaces com}</code>, но не обязательно, так как это случай по умолчанию.</p>
<div class="paragraph">
<p>Лично я не советую использовать <em>COM интерфейсы</em>. Особенно в случае, если Вам знакомы интерфейсы из других языков программирования. <em>Интерфейсы CORBA</em> в Паскале&#8201;&#8212;&#8201;это именно то, что ожидается от интерфейсов, они идентичны интерфейсам в C# и Java. При этом <em>COM интерфейсы</em> привносят дополнительные "особенности", которые, скорее всего, не понадобятся.</p>
</div>
<div class="paragraph">
<p>Обратите внимание, что <code>{$interfaces xxx}</code> определяет только интерфейсы, родительский интерфейс которых явно не указан (лишь используется ключевое слово <code>interface</code>, а не <code>interface(ISomeAncestor)</code>). Если интерфейс имеет родительский интерфейс, он имеет такой же тип, как и родительский интерфейс и не зависит от директивы <code>{$interfaces xxx}</code>.</p>
</div>
</dd>
<dt class="hdlist1">Что такое COM интерфейсы?</dt>
<dd>
<p>Понятие <em>COM интерфейс</em> является синонимом понятия <em>интерфейс, наследующий некоторый интерфейс</em> <code>IUnknown</code>. Такое наследование от <code>IUnknown</code>:</p>
<div class="ulist">
<ul>
<li>
<p>Требует, чтобы классы определяли методы <code>_AddRef</code> и <code>_ReleaseRef</code>. Правильная имплементация этих методов позволит управлять классом с помощью подсчёта ссылок (reference-counting).</p>
</li>
<li>
<p>Добавляет метод <code>QueryInterface</code>.</p>
</li>
<li>
<p>Позволяет взаимодействовать с технологией <em>COM (Компонентная модель объектов)</em>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Почему я не советую использовать COM интерфейсы?</dt>
<dd>
<p>Дополнительные возможности, привнесённые COM интерфейсами с моей точки зрения проблематичны. Не поймите превратно&#8201;&#8212;&#8201;идея reference-counting очень хороша. Однако переплетение такого функционала с интерфейсами (вместо того, чтобы делать их "поперечными" свойствами), на мой взгляд, является очень грязным. И явно не соответствует задачам, которые я встречал в своей практике.</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Иногда возникает необходимость передать обычные классы (не имеющими ничего общего) через обычный интерфейс.</p>
</li>
<li>
<p>Иногда возникает желание управлять памятью с помощью технологии reference-counting.</p>
</li>
<li>
<p><em>Возможно</em> когда-нибудь лично мне тоже пригодится <em>COM технология</em>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Но всё это - ничем не связанные задачи. Переплетать их в единой особенности языка, на мой личный взгляд, нехорошо. И это не просто вопрос эстетики, такой подход причиняет реальные проблемы: механизм reference-counting интерфейса COM, даже если отключён с помощью специальных имплементаций <code>_AddRef</code> и <code>_ReleaseRef</code>, всё равно может привести к ошибкам. Придётся быть внимательным и следить, чтобы нигде не осталась временная ссылка на интерфейс после освобождения экземпляра класса. Чуть подробнее речь об этом пойдёт дальше.</p>
</div>
<div class="paragraph">
<p>Именно по этому, мой совет: всегда использовать интерфейс в стиле <em>CORBA</em> и соответствующую <code>{$interfaces corba}</code> директиву в современном коде, который работает с интерфейсами. На мой взгляд, <em>COM</em> интерфейсы это некоторое <em>"недоразумение" языка</em>.</p>
</div>
<div class="paragraph">
<p>Однако, чтобы быть честными, чуть дальше будет детально идти речь и о <em>COM интерфейсах</em>.</p>
</div>
</dd>
<dt class="hdlist1">Можно ли использовать reference-counting совместно с интерфейсом CORBA?</dt>
<dd>
<p>Естественно. Необходимо лишь добавить методы <code>_AddRef</code> / <code>_ReleaseRef</code>. Нет необходимости наследовать интерфейс <code>IUnknown</code>. Впрочем, в большинстве случаев, если возникает необходимость использовать reference-counting в интерфейсах, можно просто использовать COM интерфейсы.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_guid_ы_интерфейсов">9.3. GUID-ы интерфейсов</h3>
<div class="paragraph">
<p>GUID-ы это на первый взгляд случайная последовательность букв и цифр <code>['{ABCD1234-&#8230;&#8203;}']</code> которую можно увидеть при каждом объявлении интерфейса. В действительности, они и являются случайными. Но, к сожалению, в них есть необходимость. Никакого особого смысла в них не вкладывается (если не планируется интеграция с технологиями <em>COM</em> или <em>CORBA</em>). Однако, для правильного исполнения программы они обязательны. И пусть не сбивает с толку компилятор, который, увы, позволяет создавать интерфейсы без GUID-ов.</p>
</div>
<div class="paragraph">
<p>Без присваивания (уникального) GUID-а, все интерфейсы будут идентичными для оператора <code>is</code>. Таким образом, он всегда будет возвращать <code>true</code> если данный класс поддерживает <em>любой</em> из используемых интерфейсов. "Волшебная" функция <code>Supports(ObjectInstance, IMyInterface)</code> работает несколько лучше в данном случае, поскольку выдаст ошибку компиляции для интерфейсов без GUID. Это касается и CORBA, и COM интерфейсов, для версии FPC 3.0.0.</p>
</div>
<div class="paragraph">
<p>Таким образом, необходимо обязательно объявлять GUID для каждого интерфейса. Можно использовать встроенный генератор GUID-ов <em>Lazarus GUID generator</em> (горячая клавиша <code>Ctrl + Shift + G</code> в режиме редактирования). Либо воспользоваться он-лайн сервисом, например <a href="https://www.guidgenerator.com/" class="bare">https://www.guidgenerator.com/</a>.</p>
</div>
<div class="paragraph">
<p>А можно вообще написать свой инструмент, использующий <code>CreateGUID</code> и <code>GUIDToString</code> функции из RTL. Например, следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils;
<span class="keyword">var</span>
  MyGuid: TGUID;
<span class="keyword">begin</span>
  Randomize;
  CreateGUID(MyGuid);
  WriteLn(<span class="char"><span class="delimiter">'</span><span class="content">[</span><span class="delimiter">'</span></span><span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span> + GUIDToString(MyGuid) + <span class="string"><span class="delimiter">'</span><span class="char">''</span><span class="content">]</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_некрасивые_com_интерфейсы">9.4. Некрасивые (COM) интерфейсы</h3>
<div class="paragraph">
<p>Использование <em>COM интерфейсов</em> даёт две дополнительных возможности:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Интеграция с технологией COM (технология, которая используется в Windows, также доступна в Unix-системах через <em>XPCOM</em>, который применяется Mozilla),</p>
</li>
<li>
<p>Подсчёт ссылок - reference counting (что позволяет автоматически освобождать экземпляр класса, когда все ссылки на его интерфейс уходят из поля переменных).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>На мой взгляд, неправильно переплетать <em>интерфейсы</em> с такими возможностями. Это усложняет использование интерфейсов для того, для чего они предназначены: когда у многих классов один и тот же API, однако они не могут происходить от одного родительского класса. Используя же <em>COM интерфейс</em>, следует помнить о механизме <em>автоматического уничтожения</em> и его отношении к технологии COM.</p>
</div>
<div class="paragraph">
<p>На практике это означает следующее:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>В классе необходимо создать "волшебные" методы <code>_AddRef</code>, <code>_Release</code> и <code>QueryInterface</code>. Или наследовать класс, который уже имеет их. Конкретная имплеметация этих методов позволяет включить или отключить такую возможность COM интерфейсов, как <em>reference-counting</em>. Впрочем, отключать её достаточно опасно&#8201;&#8212;&#8201;см. следующий подраздел.</p>
<div class="ulist">
<ul>
<li>
<p>Стандартный класс <code>TInterfacedObject</code> имеет эти методы выполненными в таком виде, чтобы <em>включить</em> reference-counting.</p>
</li>
<li>
<p>Стандартный класс <code>TComponent</code> имеет эти методы выполненными в таком виде, чтобы <em>выключить</em> reference-counting. В <strong>Castle Game Engine</strong> предоставлены дополнительные классы, от которых можно выполнять наследование: <code>TNonRefCountedInterfacedObject</code> и <code>TNonRefCountedInterfacedPersistent</code> для этих целей, см. детальнее: <a href="https://github.com/castle-engine/castle-engine/blob/0519585abc13e8386cdae5f7dfef6f9659dc9b57/src/base/castleinterfaces.pas" class="bare">https://github.com/castle-engine/castle-engine/blob/0519585abc13e8386cdae5f7dfef6f9659dc9b57/src/base/castleinterfaces.pas</a>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Необходимо быть аккуратным при освобождении класса, когда на него могут ссылаться некоторые переменные интерфейса. Поскольку интерфейсы освобождаются с помощью виртуального метода (потому что он <em>может использовать reference-counting, даже если <code>_AddRef</code> написан таким образом, чтобы отключить эту возможность</em>), то нельзя освобождать низлежащий экземпляр класса из-за того, что какая-либо переменная интерфейса может на него указывать. См. раздел <em>"7.7 Reference counting"</em> в руководстве FPC (<a href="http://freepascal.org/docs-html/ref/refse47.html" class="bare">http://freepascal.org/docs-html/ref/refse47.html</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Чтобы безопасно использовать <em>COM интерфейсы</em> необходимо</p>
</div>
<div class="ulist">
<ul>
<li>
<p>осознавать факт, что в них используется reference-counting,</p>
</li>
<li>
<p>наследовать соответствующие классы от <code>TInterfacedObject</code></p>
</li>
<li>
<p>и избегать прямого обращения к экземпляру класса, вместо чего всегда использовать экземпляр через интерфейс, оставляя алгоритму reference-counting управление освобождением памяти.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ниже представлен пример использования такого интерфейса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="preprocessor">{$interfaces com}</span>

<span class="keyword">uses</span>
  SysUtils, Classes;

<span class="keyword">type</span>
  IMyInterface = <span class="keyword">interface</span>
  [<span class="string"><span class="delimiter">'</span><span class="content">{3075FFCD-8EFB-4E98-B157-261448B8D92E}</span><span class="delimiter">'</span></span>]
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass1 = <span class="keyword">class</span>(TInterfacedObject, IMyInterface)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass2 = <span class="keyword">class</span>(TInterfacedObject, IMyInterface)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass3 = <span class="keyword">class</span>(TInterfacedObject)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass1.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass1.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass2.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass2.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass3.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass3.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> UseThroughInterface(I: IMyInterface);
<span class="keyword">begin</span>
  <span class="directive">Write</span>(<span class="string"><span class="delimiter">'</span><span class="content">Стреляем... </span><span class="delimiter">'</span></span>);
  I.Shoot;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C1: IMyInterface;  <span class="comment">// COM управляет освобождением памяти</span>
  C2: IMyInterface;  <span class="comment">// COM управляет освобождением памяти</span>
  C3: TMyClass3;     <span class="comment">// Здесь управлять освобождением памяти придётся ВАМ</span>
<span class="keyword">begin</span>
  C1 := TMyClass1.Create <span class="keyword">as</span> IMyInterface;
  C2 := TMyClass2.Create <span class="keyword">as</span> IMyInterface;
  C3 := TMyClass3.Create;
  <span class="keyword">try</span>
    UseThroughInterface(C1); <span class="comment">// Нет необходимости в операторе &quot;as&quot;</span>
    UseThroughInterface(C2);
    <span class="keyword">if</span> C3 <span class="keyword">is</span> IMyInterface <span class="keyword">then</span>
      UseThroughInterface(C3 <span class="keyword">as</span> IMyInterface); <span class="comment">// Так не сработает</span>
  <span class="keyword">finally</span>
    <span class="comment">{ Переменные C1 и C2 выходят из поля зрения
      и будут автоматически уничтожены сейчас.

      а переменная C3 является экземпляром класса
      и не управляется интерфейсом,
      по этому её необходимо совободить вручную. }</span>
    FreeAndNil(C3);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_использование_com_интерфейсов_с_отключённым_reference_counting">9.5. Использование COM интерфейсов с отключённым reference-counting</h3>
<div class="paragraph">
<p>Как уже было упомянуто в прошлом разделе, в классах, наследующих <code>TComponent</code> (либо подобные классы, такие как <code>TNonRefCountedInterfacedObject</code> и <code>TNonRefCountedInterfacedPersistent</code>) отключено reference-counting для COM интерфейсов. Это позволяет использовать COM интерфейсы и при этом даёт возможность освобождать классы вручную.</p>
</div>
<div class="paragraph">
<p>Всё же, необходимо быть аккуратным в этом случае, чтобы не освободить класс, когда какая-либо переменная интерфейса ссылается на него и не забывать, что каждая операция приведения типа в виде <code>Cx as IMyInterface</code> также создаёт временную переменную интерфейса, которая может существовать вплоть до конца текущей процедуры. Этот пример иллюстрирует процедуру <code>UseInterfaces</code>, которая освобождает классы <em>вне</em> этой процедуры (когда мы можем быть уверены, что временная переменная интерфейса вышла из текущего поля переменных).</p>
</div>
<div class="paragraph">
<p>Чтобы избежать этих неудобств, лучше использовать интерфейсы CORBA, если в данной программе нет необходимости параллельного использования reference-counting и интерфейсов.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="preprocessor">{$interfaces com}</span>

<span class="keyword">uses</span>
  SysUtils, Classes;

<span class="keyword">type</span>
  IMyInterface = <span class="keyword">interface</span>
  [<span class="string"><span class="delimiter">'</span><span class="content">{3075FFCD-8EFB-4E98-B157-261448B8D92E}</span><span class="delimiter">'</span></span>]
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass1 = <span class="keyword">class</span>(TComponent, IMyInterface)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass2 = <span class="keyword">class</span>(TComponent, IMyInterface)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass3 = <span class="keyword">class</span>(TComponent)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass1.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass1.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass2.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass2.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass3.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass3.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> UseThroughInterface(I: IMyInterface);
<span class="keyword">begin</span>
  <span class="directive">Write</span>(<span class="string"><span class="delimiter">'</span><span class="content">Стреляем... </span><span class="delimiter">'</span></span>);
  I.Shoot;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C1: TMyClass1;
  C2: TMyClass2;
  C3: TMyClass3;

<span class="keyword">procedure</span> UseInterfaces;
<span class="keyword">begin</span>
  <span class="keyword">if</span> C1 <span class="keyword">is</span> IMyInterface <span class="keyword">then</span>
  <span class="comment">//if Supports(C1, IMyInterface) then // эта строчка идентична проверке &quot;is&quot; выше</span>
    UseThroughInterface(C1 <span class="keyword">as</span> IMyInterface);
  <span class="keyword">if</span> C2 <span class="keyword">is</span> IMyInterface <span class="keyword">then</span>
    UseThroughInterface(C2 <span class="keyword">as</span> IMyInterface);
  <span class="keyword">if</span> C3 <span class="keyword">is</span> IMyInterface <span class="keyword">then</span>
    UseThroughInterface(C3 <span class="keyword">as</span> IMyInterface);
<span class="keyword">end</span>;

<span class="keyword">begin</span>
  C1 := TMyClass1.Create(<span class="keyword">nil</span>);
  C2 := TMyClass2.Create(<span class="keyword">nil</span>);
  C3 := TMyClass3.Create(<span class="keyword">nil</span>);
  <span class="keyword">try</span>
    UseInterfaces;
  <span class="keyword">finally</span>
    FreeAndNil(C1);
    FreeAndNil(C2);
    FreeAndNil(C3);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_приведение_типов_интерфейсов">9.6. Приведение типов интерфейсов</h3>
<div class="paragraph">
<p>Этот раздел касается как <em>CORBA</em>, так и <em>COM</em> интерфейсов. Впрочем, также отмечены некоторые особенности CORBA интерфейсов.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Приведение типа интерфейса через оператор <code>as</code> выполняет проверку в режиме исполнения. Рассмотрим пример:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">UseThroughInterface(Cx <span class="keyword">as</span> IMyInterface);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот вариант скомпилируется для всех экземпляров <code>C1</code>, <code>C2</code>, <code>C3</code> из примера в предыдущем подразделе. При выполнении программы возникнет ошибка для <code>C3</code>, у которого не описан <code>IMyInterface</code>.</p>
</div>
<div class="paragraph">
<p>Использование оператора <code>as</code> работает правильно независимо от того, объявлен ли <code>Cx</code> как экземпляр класса (например, <code>TMyClass2</code>) или как интерфейс (например, <code>IMyInterface2</code>).</p>
</div>
<div class="paragraph">
<p>However, it is not allowed for CORBA interfaces.</p>
</div>
</li>
<li>
<p>Однако, возможно привести тип данного экземпляра самым непосредственным образом:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">UseThroughInterface(Cx);</code></pre>
</div>
</div>
<div class="paragraph">
<p>В таком случае проверка выполняется в момент компиляции. Такой код скомпилируется для <code>C1</code> и <code>C2</code> (которые определены, как классы, использующие <code>IMyInterface</code>), но не скомпилируется для <code>C3</code>.</p>
</div>
<div class="paragraph">
<p>По большому счёту, такое приведение типа работает как для обычных классов. В случае, если требуется экземпляр класса <code>TMyClass</code>, всегда можно использовать переменную, объявленную как <code>TMyClass</code>, <strong>которой подойдёт любой наследник <code>TMyClass</code></strong>. Точно такая же ситуация и для интерфейсов. Не требуется выполнять явные приведения типов в такой ситуации.</p>
</div>
</li>
<li>
<p>Можно также выполнить приведение типа <code>IMyInterface(Cx)</code> следующим образом:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">UseThroughInterface(IMyInterface(Cx));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обычно, такой синтаксис приведения типа является <em>небезопасным, не проверяемым</em>. Если привести ошибочный тип интерфейса подобным образом, могут возникнуть ошибки, как в случае приведения типа <em>класса к классу</em>, или _интерфейса к интерфейсу_с помощью данного синтаксиса.</p>
</div>
<div class="paragraph">
<p>Можно сделать небольшую оговорку: если <code>Cx</code> объявлен как class (например <code>TMyClass2</code>), то такая операция приведения типа должна быть верной при компиляции. Иными словами, приведение типа <em>класса к интерфейсу</em> таким образом - безопасно и быстро (проверка выполняется при компиляции).</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Можете всё это попробовать, поиграв со следующим примером:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>

<span class="comment">// {$interfaces corba} // обратите внимание, что приведение типа с помощью &quot;as&quot; для интерфейсов типа CORBA не скомпилируется</span>

<span class="keyword">uses</span> Classes;

<span class="keyword">type</span>
  IMyInterface = <span class="keyword">interface</span>
  [<span class="string"><span class="delimiter">'</span><span class="content">{7FC754BC-9CA7-4399-B947-D37DD30BA90A}</span><span class="delimiter">'</span></span>]
    <span class="keyword">procedure</span> One;
  <span class="keyword">end</span>;

  IMyInterface2 = <span class="keyword">interface</span>(IMyInterface)
  [<span class="string"><span class="delimiter">'</span><span class="content">{A72B7008-3F90-45C1-8F4C-E77C4302AA3E}</span><span class="delimiter">'</span></span>]
    <span class="keyword">procedure</span> Two;
  <span class="keyword">end</span>;

  IMyInterface3 = <span class="keyword">interface</span>(IMyInterface2)
  [<span class="string"><span class="delimiter">'</span><span class="content">{924BFB98-B049-4945-AF17-1DB08DB1C0C5}</span><span class="delimiter">'</span></span>]
    <span class="keyword">procedure</span> Three;
  <span class="keyword">end</span>;

  TMyClass = <span class="keyword">class</span>(TComponent, IMyInterface)
    <span class="keyword">procedure</span> One;
  <span class="keyword">end</span>;

  TMyClass2 = <span class="keyword">class</span>(TMyClass, IMyInterface, IMyInterface2)
    <span class="keyword">procedure</span> One;
    <span class="keyword">procedure</span> Two;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.One;
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass.One</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass2.One;
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass2.One</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass2.Two;
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass2.Two</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> UseInterface2(<span class="keyword">const</span> I: IMyInterface2);
<span class="keyword">begin</span>
  I.One;
  I.Two;
<span class="keyword">end</span>;

<span class="keyword">procedure</span> UseInterface3(<span class="keyword">const</span> I: IMyInterface3);
<span class="keyword">begin</span>
  I.One;
  I.Two;
  I.Three;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  My: IMyInterface;
  MyClass: TMyClass;
<span class="keyword">begin</span>
  My := TMyClass2.Create(<span class="keyword">nil</span>);
  MyClass := TMyClass2.Create(<span class="keyword">nil</span>);

  <span class="comment">// Следующий код не скомпилируется, так как в момент компиляции неизвестно является ли My интерфейсом IMyInterface2.</span>
  <span class="comment">// UseInterface2(My);</span>
  <span class="comment">// UseInterface2(MyClass);</span>

  <span class="comment">// Это скомпилируется и работает правильно.</span>
  UseInterface2(IMyInterface2(My));
  <span class="comment">// А это не скомпилируется. Приведение типа InterfaceType(ClassType) проверяется в момент компиляции.</span>
  <span class="comment">// UseInterface2(IMyInterface2(MyClass));</span>

  <span class="comment">// Это скомпилируется и работает правильно.</span>
  UseInterface2(My <span class="keyword">as</span> IMyInterface2);
  <span class="comment">// Это скомпилируется и работает правильно.</span>
  UseInterface2(MyClass <span class="keyword">as</span> IMyInterface2);

  <span class="comment">// Это скомпилируется, но приведёт к непонятной ошибке &quot;Access violation&quot; при выполнении программы.</span>
  <span class="comment">// UseInterface3(IMyInterface3(My));</span>
  <span class="comment">// Это не скомпилируется. Приведение типа InterfaceType(ClassType) проверяется в момент компиляции.</span>
  <span class="comment">// UseInterface3(IMyInterface3(MyClass));</span>

  <span class="comment">// Это скомпилируется, но приведёт к понятному сообщению об ошибке &quot;EInvalidCast: Invalid type cast&quot; и укажет на проблему.</span>
  <span class="comment">// UseInterface3(My as IMyInterface3);</span>
  <span class="comment">// Это скомпилируется, но приведёт к понятному сообщению об ошибке &quot;EInvalidCast: Invalid type cast&quot; и укажет на проблему.</span>
  <span class="comment">// UseInterface3(MyClass as IMyInterface3);</span>

  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Готово</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_про_этот_документ">10. Про этот документ</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Copyright Michalis Kamburelis.</p>
</div>
<div class="paragraph">
<p>Исходные файлы этого документа в формате AsciiDoc можно скачать по адресу: <a href="https://github.com/michaliskambi/modern-pascal-introduction" class="bare">https://github.com/michaliskambi/modern-pascal-introduction</a>.
Автор будет рад любым пожеланиям, исправлениям, расширениям материала, доработкам и pull request-ам :). С автором можно связаться через профиль GitHub либо по e-mail: <a href="mailto:michalis@castle-engine.io">michalis@castle-engine.io</a>. Домашняя страничка автора: <a href="https://michalis.xyz/" class="bare">https://michalis.xyz/</a>.</p>
</div>
<div class="paragraph">
<p>Этот документ можно свободно распространять и изменять согласно лицензи идентичной лицензии Wikipedia, см. <a href="https://en.wikipedia.org/wiki/Wikipedia:Copyrights" class="bare">https://en.wikipedia.org/wiki/Wikipedia:Copyrights</a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Creative Commons Attribution-ShareAlike 3.0 Unported License (CC BY-SA)</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Либо</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>GNU Free Documentation License (GFDL) (unversioned, with no invariant sections, front-cover texts, or back-cover texts)</em> .</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Благодарю за прочтение!</p>
</div>
<div class="paragraph">
<p>Перевод на русский выполнен:
Александр Скворцов и Евгений Лоза
2016-2019</p>
</div>
<div class="paragraph">
<p>Благодарность за помощь в поиске и исправлении ошибок и очепяток:
vitaly_l и pupsik @ freepascal.ru</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Последнее обновление 2022-08-22 13:33:02 +0200
</div>
</div>
<!-- Google analytics -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-6792759-1");
pageTracker._trackPageview();
} catch(err) {}</script>

<!-- Piwik -->
<a href="http://piwik.org" title="Web analytics" onclick="window.open(this.href);return(false);">
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://michalis.xyz/piwik/" : "http://michalis.xyz/piwik/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
piwik_action_name = '';
piwik_idsite = 1;
piwik_url = pkBaseURL + "piwik.php";
piwik_log(piwik_action_name, piwik_idsite, piwik_url);
</script>
<object><noscript><p>Web analytics <img src="http://michalis.xyz/piwik/piwik.php?idsite=1" style="border:0" alt=""/></p></noscript></object></a>
<!-- End Piwik Tag -->
</body>
</html>