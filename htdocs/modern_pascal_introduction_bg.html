<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<meta name="author" content="Michalis Kamburelis">
<title>Модерен обектен Паскал - Въведение за програмисти</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>
/*! Stylesheet for CodeRay to loosely match GitHub themes | MIT License */
pre.CodeRay{background:#f7f7f8}
.CodeRay .line-numbers{border-right:1px solid;opacity:.35;padding:0 .5em 0 0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
.CodeRay span.line-numbers{display:inline-block;margin-right:.75em}
.CodeRay .line-numbers strong{color:#000}
table.CodeRay{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.CodeRay td{vertical-align:top;line-height:inherit}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.code{padding:0 0 0 .75em}
.CodeRay .debug{color:#fff!important;background:navy!important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:navy}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:teal}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:teal}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:teal}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword{color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:teal}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
<style>.patreon-link {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size: 14px;
  line-height: 35px;
  padding-bottom: 10px;
  padding-left: 15px;
  padding-right: 15px;
  padding-top: 10px;
  text-decoration: none;
  text-align: left;
  float: right;
}
/*
a.patreon-link:hover,
a.patreon-link:focus {
  color: black;
  background: #EEE;
}
*/
</style></head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Модерен обектен Паскал - Въведение за програмисти</h1>
<div class="details">
<span id="author" class="author">Michalis Kamburelis</span><br>
</div>
<a href="https://patreon.com/castleengine" class="navbar-link patreon-link" style="display: inline-block; background-color: #FF424D; border-radius: 0; text-align: center;">
  <div style="color: #ffffff; padding-left: 1em; padding-right: 1em;">
    <span style="vertical-align: middle;">Support&nbsp;us&nbsp;on</span>&nbsp;<img src="patreon-wordmark.png" alt="Patreon Wordmark" style="display: inline-block; vertical-align: middle;" width="80" height="16">
  </div>
</a>
<div id="toc" class="toc2">
<div id="toctitle">Съдържание</div>
<ul class="sectlevel1">
<li><a href="#_защо">1. Защо</a></li>
<li><a href="#_основи">2. Основи</a>
<ul class="sectlevel2">
<li><a href="#_програма_hello_world">2.1. Програма "Hello world"</a></li>
<li><a href="#_функции_процедури_примитивни_типове">2.2. Функции, процедури, примитивни типове</a></li>
<li><a href="#_проверки_if">2.3. Проверки (if)</a></li>
<li><a href="#_логически_релационни_и_побитови_оператори">2.4. Логически, релационни и побитови оператори</a></li>
<li><a href="#_тестване_на_единичен_израз_за_множество_стойности_case">2.5. Тестване на единичен израз за множество стойности (case)</a></li>
<li><a href="#_изброени_и_бройни_типове_множества_и_масиви_с_постоянна_дължина">2.6. Изброени и бройни типове, множества и масиви с постоянна дължина</a></li>
<li><a href="#_цикли_for_while_repeat_for_in">2.7. Цикли (for, while, repeat, for .. in)</a></li>
<li><a href="#_изпечатване_на_информация_логове">2.8. Изпечатване на информация, логове</a></li>
<li><a href="#_преобразуване_в_низ">2.9. Преобразуване в низ</a></li>
</ul>
</li>
<li><a href="#_модули_unit_и">3. Модули (Unit-и)</a>
<ul class="sectlevel2">
<li><a href="#_unit_и_които_се_използват_взаимно">3.1. Unit-и, които се използват взаимно</a></li>
<li><a href="#_квалифициране_на_идентификаторите_с_името_на_unit_а">3.2. Квалифициране на идентификаторите с името на unit-а</a></li>
<li><a href="#_представяне_на_идентификаторите_от_един_unit_чрез_друг">3.3. Представяне на идентификаторите от един unit чрез друг</a></li>
</ul>
</li>
<li><a href="#_класове">4. Класове</a>
<ul class="sectlevel2">
<li><a href="#_основи_2">4.1. Основи</a></li>
<li><a href="#_наследяване_проверка_is_конверсия_на_типа_as">4.2. Наследяване, проверка (is), конверсия на типа (as)</a></li>
<li><a href="#_свойства">4.3. Свойства</a>
<ul class="sectlevel3">
<li><a href="#_сериализация_на_свойства">4.3.1. Сериализация на свойства</a></li>
</ul>
</li>
<li><a href="#_изключения_кратък_пример">4.4. Изключения - Кратък пример</a></li>
<li><a href="#_нива_на_видимост">4.5. Нива на видимост</a></li>
<li><a href="#_предшественик_по_подразбиране">4.6. Предшественик по подразбиране</a></li>
<li><a href="#_self">4.7. Self</a></li>
<li><a href="#_извикване_на_наследен_метод">4.8. Извикване на наследен метод</a></li>
<li><a href="#virtual-methods-override-reintroduce">4.9. Виртуални методи, подмяна и скриване</a></li>
</ul>
</li>
<li><a href="#_освобождаване_на_паметта_за_класове">5. Освобождаване на паметта за класове</a>
<ul class="sectlevel2">
<li><a href="#_помнете_да_освобождавате_паметта_заета_от_инстанциите">5.1. Помнете да освобождавате паметта заета от инстанциите</a></li>
<li><a href="#_как_да_освободим_паметта">5.2. Как да освободим паметта</a></li>
<li><a href="#_ръчно_и_автоматично_освобождаване">5.3. Ръчно и автоматично освобождаване</a></li>
<li><a href="#_виртуалният_деструктор_destroy">5.4. Виртуалният деструктор Destroy</a></li>
<li><a href="#_известие_при_освобождаване">5.5. Известие при освобождаване</a></li>
<li><a href="#_наблюдател_за_известие_при_освобождаване_castle_game_engine">5.6. Наблюдател за известие при освобождаване (Castle Game Engine)</a></li>
</ul>
</li>
<li><a href="#Exceptions">6. Изключения</a>
<ul class="sectlevel2">
<li><a href="#_преглед">6.1. Преглед</a></li>
<li><a href="#_предизвикване">6.2. Предизвикване</a></li>
<li><a href="#_прихващане">6.3. Прихващане</a></li>
<li><a href="#_finally_изпълнение_на_код_независимо_дали_има_изключение">6.4. Finally (изпълнение на код независимо дали има изключение)</a></li>
<li><a href="#_как_изключенията_се_показват_от_различните_библиотеки">6.5. Как изключенията се показват от различните библиотеки</a></li>
</ul>
</li>
<li><a href="#_run_time_библиотека">7. Run-time библиотека</a>
<ul class="sectlevel2">
<li><a href="#_входизход_с_помощта_на_потоци">7.1. Вход/изход с помощта на потоци</a></li>
<li><a href="#generic-containers-section">7.2. Контейнери (списъци, речници), използващи генерици</a></li>
<li><a href="#_клониране_tpersistent_assign">7.3. Клониране: TPersistent.Assign</a></li>
</ul>
</li>
<li><a href="#_разни_възможности_на_езика">8. Разни възможности на езика</a>
<ul class="sectlevel2">
<li><a href="#_локални_вложени_подпрограми">8.1. Локални (вложени) подпрограми</a></li>
<li><a href="#Callbacks">8.2. Callbacks (познати като <em>Събития</em>, също като <em>Указатели към функции</em>, също като <em>Процедурни променливи</em>)</a></li>
<li><a href="#Generics">8.3. Генерици</a></li>
<li><a href="#_overloading">8.4. Overloading</a></li>
<li><a href="#_препроцесор">8.5. Препроцесор</a></li>
<li><a href="#_записи">8.6. Записи</a></li>
<li><a href="#_обекти_стар_стил">8.7. Обекти, стар стил</a></li>
<li><a href="#_указатели">8.8. Указатели</a></li>
<li><a href="#_замяна_на_оператори">8.9. Замяна на оператори</a></li>
</ul>
</li>
<li><a href="#_допълнителни_възможности_на_класовете">9. Допълнителни възможности на класовете</a>
<ul class="sectlevel2">
<li><a href="#_частни_и_лични_полета">9.1. Частни и лични полета</a></li>
<li><a href="#_допълнителни_декларации_и_вложени_класове">9.2. Допълнителни декларации и вложени класове</a></li>
<li><a href="#_методи_на_класа">9.3. Методи на класа</a></li>
<li><a href="#_препратки_към_клас">9.4. Препратки към клас</a></li>
<li><a href="#_статични_методи_на_клас">9.5. Статични методи на клас</a></li>
<li><a href="#_полета_и_свойства_на_клас">9.6. Полета и свойства на клас</a></li>
<li><a href="#_помощници_за_клас">9.7. Помощници за клас</a></li>
<li><a href="#_виртуални_конструктори_деструктори">9.8. Виртуални конструктори, деструктори</a></li>
<li><a href="#_изключение_в_конструктор">9.9. Изключение в конструктор</a></li>
</ul>
</li>
<li><a href="#_интерфейси">10. Интерфейси</a>
<ul class="sectlevel2">
<li><a href="#_голи_corba_интерфейси">10.1. Голи (CORBA) интерфейси</a></li>
<li><a href="#_интерфейси_corba_и_com">10.2. Интерфейси CORBA и COM</a></li>
<li><a href="#_интерфейсни_guids">10.3. Интерфейсни GUIDs</a></li>
<li><a href="#_интерфейси_с_броене_на_препратки_com">10.4. Интерфейси с броене на препратки (COM)</a></li>
<li><a href="#_използване_на_com_интерфейси_с_изключено_броене">10.5. Използване на COM интерфейси с изключено броене</a></li>
<li><a href="#_преобразуване_на_интерфейси">10.6. Преобразуване на интерфейси</a></li>
</ul>
</li>
<li><a href="#_относно_този_документ">11. Относно този документ</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<style>
body { font-family: "Open Sans", "DejaVu Sans", sans-serif; }
</style>
</div>
</div>
<div class="sect1">
<h2 id="_защо">1. Защо</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Има много книги и ресурси за Паскал, но в повечето от тях се говори само за стария Паскал, който е без класове, модули<sup class="footnote" id="_footnote_unit">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup> или генерици<sup class="footnote" id="_footnote_generics">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>.</p>
</div>
<div class="paragraph">
<p>Затова написах кратко въведение в това, което аз наричам <strong>модерен Обектен Паскал</strong>. Повечето от програмистите, които го използват, всъщност не го наричат така. Просто го наричаме <em>"нашия Паскал"</em>. Но чувствам, че когато представям езика е важно да подчертая, че е вече модерен, обектно-ориентиран език. Той се е развил <strong>значително</strong> от времето на стария (Turbo) Паскал, който много хора са учили преди време в училище. Функционално е доста подобен на C++, Java или C#.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Той има всички съвременни функции, които можете да очаквате - класове, модули, интерфейси<sup class="footnote" id="_footnote_interface">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>, генерици &#8230;&#8203;</p>
</li>
<li>
<p>Той се компилира директно до бърз машинен код,</p>
</li>
<li>
<p>Той е типово обезопасен,</p>
</li>
<li>
<p>Той е език от високо ниво, но също така може да е и от ниско ако желаете.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Освен това има отличен преносим компилатор с отворен код, наречен <em>Free Pascal Compiler</em>, <a href="http://freepascal.org/" class="bare">http://freepascal.org/</a> . Има и придружаващо IDE (редактор, Debugger, библиотека от визуални компоненти, дизайнер на форми), наречен <em>Lazarus</em> <a href="http://lazarus.freepascal.org/" class="bare">http://lazarus.freepascal.org/</a> . Самият аз съм автор на <em>Castle Game Engine</em>, <a href="https://castle-engine.io/" class="bare">https://castle-engine.io/</a> , която е 3D и 2D библиотека с отворен код, използваща Паскал за създаване на игри на много платформи (Windows, Linux, macOS, Android, iOS, Nintendo Switch; подготвя се и WebGL).</p>
</div>
<div class="paragraph">
<p>Това въведение е насочено най-вече към програмисти, които вече имат опит в програмирането на други езици. Тук няма да разглеждаме значенията на някои универсални концепции като <em>"Какво е клас"</em>, само ще покажем как да ги използваме в Паскал.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_основи">2. Основи</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_програма_hello_world">2.1. Програма "Hello world"</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span> <span class="comment">// Използвайте този ред във всички нови програми</span>

<span class="keyword">program</span> MyProgram; <span class="comment">// Запишете файла като myprogram.lpr</span>
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Hello world!</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Това е завършена програма, която можете да <em>компилирате</em> и <em>стартирате</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ако използвате FPC на командния ред, просто създайте нов файл <code>myprogram.lpr</code> и изпълнете <code>fpc myprogram.lpr</code>.</p>
</li>
<li>
<p>Ако използвате <em>Lazarus</em>, създайте нов проект (меню <em>Project</em> &#8594; <em>New Project</em> &#8594; <em>Simple Program</em>). Запазете го като <code>myProgram</code> и поставете по-горния код като основен файл. Компилирайте го с помощта на командата от менюто <em>Run &#8594; Compile</em>.</p>
</li>
<li>
<p>Това е програма за командния ред, така че и в двата случая&#8201;&#8212;&#8201;просто стартирайте компилирания изпълним файл от командния ред.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В останалата част от тази книга се говори за езика Обектен Паскал, така че не очаквайте да видите нещо по-забавно от програми за команден ред. Ако искате да видите нещо по-така, просто създайте нов GUI проект в <em>Lazarus</em> (<em>Project</em> &#8594; <em>New Project</em> &#8594; <em>Application</em>).
Готово&#8201;&#8212;&#8201;работещо GUI приложение, крос-платформено, с естествен изглед навсякъде, използвайки удобна библиотека с визуални компоненти. <em>Lazarus</em> и <em>Free Pascal Compiler</em> се предлагат с много готови модули за работа в мрежа, GUI, база данни, файлови формати (XML, JSON, изображения &#8230;&#8203;), многозадачност и всичко останало, от което може да се нуждаете. Вече споменах моя готин <em>Castle Game Engine</em> по-рано :)</p>
</div>
</div>
<div class="sect2">
<h3 id="_функции_процедури_примитивни_типове">2.2. Функции, процедури, примитивни типове</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>

<span class="keyword">program</span> MyProgram;

<span class="keyword">procedure</span> MyProcedure(<span class="keyword">const</span> A: Integer);
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">A + 10 е: </span><span class="delimiter">'</span></span>, A + <span class="integer">10</span>);
<span class="keyword">end</span>;

<span class="keyword">function</span> MyFunction(<span class="keyword">const</span> S: <span class="keyword">string</span>): <span class="keyword">string</span>;
<span class="keyword">begin</span>
  Result := S + <span class="string"><span class="delimiter">'</span><span class="content">низовете се управляват автоматично</span><span class="delimiter">'</span></span>;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  X: Single;
<span class="keyword">begin</span>
  WriteLn(MyFunction(<span class="string"><span class="delimiter">'</span><span class="content">Забележка: </span><span class="delimiter">'</span></span>));
  MyProcedure(<span class="integer">5</span>);

  <span class="comment">// Делението с &quot;/&quot; винаги дава резултат float, </span>
  <span class="comment">// използвайте &quot;div&quot; за целочислено делене</span>
  X := <span class="integer">15</span> / <span class="integer">5</span>;
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">X сега е: </span><span class="delimiter">'</span></span>, X); <span class="comment">// научна нотация</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">X сега е: </span><span class="delimiter">'</span></span>, X:<span class="integer">1</span>:<span class="integer">2</span>); <span class="comment">// 2 десетични знака</span>
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>За да върнете стойност от функция, задайте стойност на магическата променлива <code>Result</code>. Можете да четете и присвоявате свободно <code>Result</code>, точно както и всяка друга локална променлива.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">function</span> MyFunction(<span class="keyword">const</span> S: <span class="keyword">string</span>): <span class="keyword">string</span>;
<span class="keyword">begin</span>
  Result := S + <span class="string"><span class="delimiter">'</span><span class="content">нещо</span><span class="delimiter">'</span></span>;
  Result := Result + <span class="string"><span class="delimiter">'</span><span class="content"> още нещо!</span><span class="delimiter">'</span></span>;
  Result := Result + <span class="string"><span class="delimiter">'</span><span class="content"> и още!</span><span class="delimiter">'</span></span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Можете също да използвате и името на функцията (<code>MyFunction</code> в горния пример) като променлива, на която да присвоите резултата. Но не бих го препоръчал в нов код, тъй като изглежда "съмнително", когато се използва в дясната страна на оператор за присвояване. Просто използвайте <code>Result</code> винаги, когато искате да прочетете или да зададете резултата от функцията.</p>
</div>
<div class="paragraph">
<p>Разбира се може да го направите ако искате да извикате функцията рекурсивно. Ако извиквате рекурсивно функция без параметри, уверете се, че сте сложили скобите  <code>()</code> след името (въпреки че в Паскал обикновено можете да ги пропуснете в този случай). Това ще направи рекурсивното извикване на функция без параметри различимо от прочитането на текущата стойност на функцията. Например така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">function</span> SumIntegersUntilZero: Integer;
<span class="keyword">var</span>
  I: Integer;
<span class="keyword">begin</span>
  Readln(I);
  Result := I;
  <span class="keyword">if</span> I &lt;&gt; <span class="integer">0</span> <span class="keyword">then</span>
    Result := Result + SumIntegersUntilZero();
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Можете да извикате <code>Exit</code> за да приключите изпълнението на процедурата или функцията преди тя да е достигнала последния си <code>end;</code>. Ако извикате <code>Exit</code> без параметри във функция, тогава ще се върне последното нещо присвоено на <code>Result</code>. Може да се използва и конструкцията <code>Exit(X)</code>, за да се зададе резултата от функцията и да се излезе <strong>сега</strong>&#8201;&#8212;&#8201;точно както <code>return X</code> в C-подобните езици.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">function</span> AddName(<span class="keyword">const</span> ExistingNames, NewName: <span class="keyword">string</span>): <span class="keyword">string</span>;
<span class="keyword">begin</span>
  <span class="keyword">if</span> ExistingNames = <span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span> <span class="keyword">then</span>
    Exit(NewName);
  Result := ExistingNames + <span class="string"><span class="delimiter">'</span><span class="content">, </span><span class="delimiter">'</span></span> + NewName;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обърнете внимание, че резултатът от функцията може да бъде игнориран. Всяка функция може да се използва и като процедура. Това има смисъл, когато функцията има някакъв <em>страничен ефект</em> (напр. променя глобална променлива) вместо да изчислява резултат. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  Count: Integer;
  MyCount: Integer;

<span class="keyword">function</span> CountMe: Integer;
<span class="keyword">begin</span>
  Inc(Count);
  Result := Count;
<span class="keyword">end</span>;

<span class="keyword">begin</span>
  Count := <span class="integer">10</span>;
  CountMe; <span class="comment">// функцията се изпълнява но резултата й се игнорира, Count сега е 11</span>
  MyCount := CountMe; <span class="comment">// резултата от функцията се използва, MyCount става равно на Count, което сега е 12</span>
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_проверки_if">2.3. Проверки (if)</h3>
<div class="paragraph">
<p>Използвайте <code>if .. then</code> или <code>if .. then .. else</code> за да изпълните някакъв код, когато е удовлетворено определено условие. За разлика от C-подобните езици, в Паскал не е необходимо да ограждате условието в скоби.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  A: Integer;
  B: boolean;
<span class="keyword">begin</span>
  <span class="keyword">if</span> A &gt; <span class="integer">0</span> <span class="keyword">then</span>
    DoSomething;

  <span class="keyword">if</span> A &gt; <span class="integer">0</span> <span class="keyword">then</span>
  <span class="keyword">begin</span>
    DoSomething;
    AndDoSomethingMore;
  <span class="keyword">end</span>;

  <span class="keyword">if</span> A &gt; <span class="integer">10</span> <span class="keyword">then</span>
    DoSomething
  <span class="keyword">else</span>
    DoSomethingElse;

  <span class="comment">// еквивалентно на горното</span>
  B := A &gt; <span class="integer">10</span>;
  <span class="keyword">if</span> B <span class="keyword">then</span>
    DoSomething
  <span class="keyword">else</span>
    DoSomethingElse;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Клаузата <code>else</code> се отнася към последния <code>if</code>. Така че следното ще работи, както се очаква:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> A &lt;&gt; <span class="integer">0</span> <span class="keyword">then</span>
  <span class="keyword">if</span> B &lt;&gt; <span class="integer">0</span> <span class="keyword">then</span>
    AIsNonzeroAndBToo
  <span class="keyword">else</span>
    AIsNonzeroButBIsZero;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Въпреки че горния пример с вложени <code>if</code> е коректен, винаги в такива случаи е по-добре вложения <code>if</code> да се огради в <code>begin</code> &#8230;&#8203; <code>end</code> блок. Това прави кода по-очевиден за читателя и той ще остане такъв, дори ако объркате отстъпа отляво. По-долу е подобрената версия на горния пример. Когато добавите или премахнете някоя клауза <code>else</code> в долния код, винаги ще е ясно към кое условие ще бъде тя (към проверката на <code>A</code> или към проверката на <code>B</code>), така че е по-малко вероятно да се допуснат грешки.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> A &lt;&gt; <span class="integer">0</span> <span class="keyword">then</span>
<span class="keyword">begin</span>
  <span class="keyword">if</span> B &lt;&gt; <span class="integer">0</span> <span class="keyword">then</span>
    AIsNonzeroAndBToo
  <span class="keyword">else</span>
    AIsNonzeroButBIsZero;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_логически_релационни_и_побитови_оператори">2.4. Логически, релационни и побитови оператори</h3>
<div class="paragraph">
<p><em>Логически оператори</em> се наричат <code>and</code>, <code>or</code>, <code>not</code>, <code>xor</code>. Тяхното значение вероятно е очевидно (потърсете <em>"exclusive or"</em> ако не сте сигурни какво върши <em>xor</em>). Те вземат <em>boolean аргументи</em> и връщат <em>boolean</em> резултат. Те също могат да действат и като <em>побитови оператори</em> когато и двата аргумента са цели числа, в този случай те връщат цяло число.</p>
</div>
<div class="paragraph">
<p><em>Релационни (сравнителни)</em> оператори са <code>=</code>, <code>&lt;&gt;</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>. Ако сте свикнали с C-подобни езици, обърнете внимание, че в Паскал сравнението на две стойности (проверката дали са равни), се прави като използвате само един символ на равенство <code>A = B</code> (За разлика от C, където използвате два <code>A == B</code>). Специалният оператор <em>assignment</em> в Паскал е <code>:=</code>.</p>
</div>
<div class="paragraph">
<p><em>Логическите (или побитовите) оператори имат по-висок приоритет от релационните оператори</em>. Може да се наложи да използвате скоби около някои изрази, за да получите желания ред на изчисление.</p>
</div>
<div class="paragraph">
<p>Например това е грешка при компилация:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  A, B: Integer;
<span class="keyword">begin</span>
  <span class="keyword">if</span> A = <span class="integer">0</span> <span class="keyword">and</span> B &lt;&gt; <span class="integer">0</span> <span class="keyword">then</span> ... <span class="comment">// НЕКОРЕКТЕН пример</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Горното не успява да се компилира, тъй като първо компилаторът иска да изпълни побитовия <code>and</code> в средата на израза: <code>(0 and B)</code>. Това е побитова операция, която връща цяло число. След това компилатора изпълнява оператора <code>=</code>, чийто резултат е логическа стойност <code>A = (0 and B)</code>. Накрая се получава грешка <em>"type mismatch"</em> след опита да се сравни логическата стойност <code>A = (0 and B)</code> и цялото число <code>0</code>.</p>
</div>
<div class="paragraph">
<p>Това е вярно:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  A, B: Integer;
<span class="keyword">begin</span>
  <span class="keyword">if</span> (A = <span class="integer">0</span>) <span class="keyword">and</span> (B &lt;&gt; <span class="integer">0</span>) <span class="keyword">then</span> ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>В изчислението на логически изрази се използва т.н. <em>кратко оценяване</em> (short-circuit evaluation). Разглеждаме следния израз:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> MyFunction(X) <span class="keyword">and</span> MyOtherFunction(Y) <span class="keyword">then</span>...</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Гарантирано е, че първо ще бъде оценена <code>MyFunction(X)</code>.</p>
</li>
<li>
<p>Ако <code>MyFunction(X)</code> върне <code>false</code>, тогава стойността на израза е известна (стойността на <code>false and каквото_и_да_е</code> е винаги <code>false</code>), и <code>MyOtherFunction(Y)</code> няма да се извика изобщо.</p>
</li>
<li>
<p>Подобно е правилото и за  <code>or</code> изрази. Тогава, ако израза е ясно, че е <code>true</code> (защото първия операнд е <code>true</code>), втория операнд не се оценява.</p>
</li>
<li>
<p>Това е особено полезно, когато пишете изрази като</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> (A &lt;&gt; <span class="keyword">nil</span>) <span class="keyword">and</span> A.IsValid <span class="keyword">then</span>...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Това ще сработи превилно, дори когато <code>A</code> е <code>nil</code>. Ключовата дума <code>nil</code> е за указател, равен на нула (когато е представен като число). Нарича се <em>null pointer</em> в много други езици за програмиране.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_тестване_на_единичен_израз_за_множество_стойности_case">2.5. Тестване на единичен израз за множество стойности (case)</h3>
<div class="paragraph">
<p>Ако трябва да се изпълни различно действие в зависимост от стойността на някакъв израз, тогава е полезна конструкцията <code>case .. of .. end</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">case</span> SomeValue <span class="keyword">of</span>
  <span class="integer">0</span>: DoSomething;
  <span class="integer">1</span>: DoSomethingElse;
  <span class="integer">2</span>: <span class="keyword">begin</span>
       IfItsTwoThenDoThis;
       AndAlsoDoThis;
     <span class="keyword">end</span>;
  <span class="integer">3</span>..<span class="integer">10</span>: DoSomethingInCaseItsInThisRange;
  <span class="integer">11</span>, <span class="integer">21</span>, <span class="integer">31</span>: AndDoSomethingForTheseSpecialValues;
  <span class="keyword">else</span> DoSomethingInCaseOfUnexpectedValue;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Клаузата <code>else</code> е незадължителна (и съответства на <code>default</code> в C-подобните езици). Когато нито една стойност не съвпада и не е зададена <code>else</code> клауза, тогава не се изпълнява нищо.</p>
</div>
<div class="paragraph">
<p>Ако познавате C-подобни езици и сравните това с оператор <code>switch</code>, ще забележите, че няма автоматично <em>пропадане</em> (fall-through) към следващия клон. Това е умишлена благодат в Паскал. Не е нужно да помните и да поставяте инструкции <code>break</code>. При всяко изпълнение, се изпълнява <em>най-много един</em> клон на <code>case</code>, това е всичко.</p>
</div>
</div>
<div class="sect2">
<h3 id="_изброени_и_бройни_типове_множества_и_масиви_с_постоянна_дължина">2.6. Изброени и бройни типове, множества и масиви с постоянна дължина</h3>
<div class="paragraph">
<p>Изброеният тип в Паскал е много удобен, непрозрачен тип. Вероятно ще го използвате много по-често от enums в другите езици:)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TAnimalKind = (akDuck, akCat, akDog);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Прието е пред имената в изброения тип да се сложи двубуквен префикс от името на типа, оттук <code>ak</code> = префикс за <em>"Animal Kind"</em>. Това е полезно правило, тъй като имената на изброения тип са в глобалното пространство от имена. Така че ако им сложите префикс <code>ak</code>, вие намалявате възможността за конфликт с други идентификатори.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
Конфликтите в имената не са фатални. Възможно е различните модули да дефинират един и същ идентификатор. Но е добра идея да се опитате да избягвате конфликтите така или иначе, за да поддържате кода лесен за разбиране и анализ.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
Можете да избегнете дефинирането на имената от изброения тип в глобалното пространство от имена чрез компилаторната директива <code>{$scopedenums on}</code>. Това означава, че ще трябва да ги указвате винаги квалифицирани по име на тип, напр. <code>TAnimalKind.akDuck</code>. В такъв случай нуждата от префикс <code>ak</code> отпада и вероятно тогава просто ще ги наречете <code>Duck, Cat, Dog</code>. Това е подобно на C# enums.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Фактът, че изброения тип е <em>непрозрачен</em> означава, че не е възможно да се присвои директно към и от целочислен тип. Ако това е необходимо, може да се използва <code>Ord(MyAnimalKind)</code> за да се преобразува изброен тип към целочислен, или <code>TAnimalKind(MyInteger)</code> за да се преобразува целочислен тип към изброен. В последния случай първо се уверете, че <code>MyInteger</code> е в диапазона (0 .. <code>Ord(High(TAnimalKind))</code>).</p>
</div>
<div class="paragraph">
<p>Изброените и бройните типове могат да се използват за индекси на масиви:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TArrayOfTenStrings = <span class="keyword">array</span> [<span class="integer">0</span>..<span class="integer">9</span>] <span class="keyword">of</span> <span class="keyword">string</span>;
  TArrayOfTenStrings1Based = <span class="keyword">array</span> [<span class="integer">1</span>..<span class="integer">10</span>] <span class="keyword">of</span> <span class="keyword">string</span>;

  TMyNumber = <span class="integer">0</span>..<span class="integer">9</span>;
  TAlsoArrayOfTenStrings = <span class="keyword">array</span> [TMyNumber] <span class="keyword">of</span> <span class="keyword">string</span>;

  TAnimalKind = (akDuck, akCat, akDog);
  TAnimalNames = <span class="keyword">array</span> [TAnimalKind] <span class="keyword">of</span> <span class="keyword">string</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Те също могат да се използват за създаване на множества (побитови полета):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TAnimalKind = (akDuck, akCat, akDog);
  TAnimals = <span class="keyword">set</span> <span class="keyword">of</span> TAnimalKind;
<span class="keyword">var</span>
  A: TAnimals;
<span class="keyword">begin</span>
  A := [];
  A := [akDuck, akCat];
  A := A + [akDog];
  A := A * [akCat, akDog];
  Include(A, akDuck);
  Exclude(A, akDuck);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_цикли_for_while_repeat_for_in">2.7. Цикли (for, while, repeat, for .. in)</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="preprocessor">{$R+}</span> <span class="comment">// включена проверка на диапазона - подходящо за дебъг</span>
<span class="keyword">var</span>
  MyArray: <span class="keyword">array</span> [<span class="integer">0</span>..<span class="integer">9</span>] <span class="keyword">of</span> Integer;
  I: Integer;
<span class="keyword">begin</span>
  <span class="comment">// инизиализация</span>
  <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> <span class="integer">9</span> <span class="keyword">do</span>
    MyArray[I] := I * I;

  <span class="comment">// показване</span>
  <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> <span class="integer">9</span> <span class="keyword">do</span>
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Квадрата е </span><span class="delimiter">'</span></span>, MyArray[I]);

  <span class="comment">// прави същото като горното</span>
  <span class="keyword">for</span> I := Low(MyArray) <span class="keyword">to</span> High(MyArray) <span class="keyword">do</span>
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Квадрата е </span><span class="delimiter">'</span></span>, MyArray[I]);

  <span class="comment">// прави същото като горното</span>
  I := <span class="integer">0</span>;
  <span class="keyword">while</span> I &lt; <span class="integer">10</span> <span class="keyword">do</span>
  <span class="keyword">begin</span>
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Квадрата е </span><span class="delimiter">'</span></span>, MyArray[I]);
    I := I + <span class="integer">1</span>; <span class="comment">// или &quot;I += 1&quot;, или &quot;Inc(I)&quot;</span>
  <span class="keyword">end</span>;

  <span class="comment">// прави същото като горното</span>
  I := <span class="integer">0</span>;
  <span class="keyword">repeat</span>
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Квадрата е </span><span class="delimiter">'</span></span>, MyArray[I]);
    Inc(I);
  <span class="keyword">until</span> I = <span class="integer">10</span>;

  <span class="comment">// прави същото като горното</span>
  <span class="comment">// забележка: тук се изброяват стойностите на MyArray, а не индексите</span>
  <span class="keyword">for</span> I <span class="keyword">in</span> MyArray <span class="keyword">do</span>
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Квадрата е </span><span class="delimiter">'</span></span>, I);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Относно циклите <code>repeat</code> и <code>while</code></strong>:</p>
</div>
<div class="paragraph">
<p>Има две разлики между тези типове цикли:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Условието за цикъл има противоположен смисъл. В цикъла <code>while .. do</code> условито казва <em>кога да се продължи</em>, но в <code>repeat .. until</code> условието казва <em>кога да се спре</em>.</p>
</li>
<li>
<p>При цикъла <code>repeat</code> <em>условието не се проверява в началото</em>. По този начин цикъла <code>repeat</code> винаги се изпълнява поне веднъж.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Относно цикъл <code>for I := &#8230;&#8203;</code></strong>:</p>
</div>
<div class="paragraph">
<p>Цикълът <code>for I := .. to .. do &#8230;&#8203;</code> е близък до C-подобния цикъл <code>for</code>. Въпреки това е по-ограничен, защото не може да му се укаже произволно действие и / или произволно условие за контрол на цикъла. Той може да се изпълнява само с последователни числа (или други бройни типове). Единствената различна възможност е тази, че може да се използва <code>downto</code> вместо <code>to</code>, за да се брои наобратно.</p>
</div>
<div class="paragraph">
<p>За сметка на това той изглежда прост и изпълнението му е силно оптимизирано. По-конкретно, <em>изразите за горната и долната граници се изчисляват само веднъж</em> преди цикъла да започне.</p>
</div>
<div class="paragraph">
<p>Обърнете внимание, че стойността на променливата на брояча на цикъла (в примера <code>I</code>) се счита за <em>неопределена</em> след приключването на цикъла заради възможните оптимизации. Прочитане на стойността на <code>I</code> след цикъла може да доведе до издаване на предупреждение от компилатора. В случай обаче на предсрочно излизане с <code>Break</code> или <code>Exit</code>, променливата гарантирано запазва последната си стойност.</p>
</div>
<div class="paragraph">
<p><strong>Относно цикъл  <code>for I in &#8230;&#8203;</code></strong>:</p>
</div>
<div class="paragraph">
<p>Цикълът <code>for I in .. do ..</code> е подобен на <code>foreach</code> в повечето модерни езици за програмиране. Той може да работи с много от вградените типове:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Може да се изпълни за всички стойности в масив (горния пример).</p>
</li>
<li>
<p>Може да се изпълни за всички стойности на изброен тип:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  AK: TAnimalKind;
<span class="keyword">begin</span>
  <span class="keyword">for</span> AK <span class="keyword">in</span> TAnimalKind <span class="keyword">do</span>...</code></pre>
</div>
</div>
</li>
<li>
<p>Може да се изпълни за всички елементи включени в множество:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  Animals: TAnimals;
  AK: TAnimalKind;
<span class="keyword">begin</span>
  Animals := [akDog, akCat];
  <span class="keyword">for</span> AK <span class="keyword">in</span> Animals <span class="keyword">do</span> ...</code></pre>
</div>
</div>
</li>
<li>
<p>И работи с потребителски типове списъци, включително генерици, като <code>TObjectList</code> or <code>TFPGObjectList</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils, FGL;

<span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
    I, Square: Integer;
  <span class="keyword">end</span>;
  TMyClassList = specialize TFPGObjectList&lt;TMyClass&gt;;

<span class="keyword">var</span>
  List: TMyClassList;
  C: TMyClass;
  I: Integer;
<span class="keyword">begin</span>
  List := TMyClassList.Create(true); <span class="comment">// true = притежава елементите си</span>
  <span class="keyword">try</span>
    <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> <span class="integer">9</span> <span class="keyword">do</span>
    <span class="keyword">begin</span>
      C := TMyClass.Create;
      C.I := I;
      C.Square := I * I;
      List.Add(C);
    <span class="keyword">end</span>;

    <span class="keyword">for</span> C <span class="keyword">in</span> List <span class="keyword">do</span>
      WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Квадрата на </span><span class="delimiter">'</span></span>, C.I, <span class="string"><span class="delimiter">'</span><span class="content"> е </span><span class="delimiter">'</span></span>, C.Square);
  <span class="keyword">finally</span>
    FreeAndNil(List);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Все още не сме обяснили концепцията за класовете, така че последният пример може да не е съвсем очевиден. Просто продължете напред и по-късно ще стане ясно :)</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_изпечатване_на_информация_логове">2.8. Изпечатване на информация, логове</h3>
<div class="paragraph">
<p>За изпечатване на низове в Паскал, използвайте процедурите <code>Write</code> или <code>WriteLn</code>. Във втората автоматично се добавя символ за нов ред накрая.</p>
</div>
<div class="paragraph">
<p>Това е "вълшебна" процедура в Паскал. Тя може да приеме променлив брой аргументи и те могат да имат почти всякакъв тип. Всички подадени аргументи се преобразуват в низове при изпечатването и има специален синтаксис за определяне ширината на полето и броя десетични цифри след запетаята.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Hello world!</span><span class="delimiter">'</span></span>);
WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Може да отпечатате цяло число: </span><span class="delimiter">'</span></span>, <span class="integer">3</span> * <span class="integer">4</span>);
WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Може да разширите полето на цяло число: </span><span class="delimiter">'</span></span>, <span class="integer">666</span>:<span class="integer">10</span>);
WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Може да отпечатате число с плаваща запетая: </span><span class="delimiter">'</span></span>, Pi:<span class="integer">1</span>:<span class="integer">4</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>За да вмъкнете изрично нов ред в низа, използвайте константата <code>LineEnding</code> (от FPC RTL). (<em>Castle Game Engine</em> също така дефинира по-кратката константа <code>NL</code>.) Паскал не интерпретира никакви специални поредици в низовете, така че изписването на</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">One line.\nSecond line.</span><span class="delimiter">'</span></span>); <span class="comment">// НЕКОРЕКТЕН пример</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Не работи така, както някои от вас биха очаквали. Ще работи това:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Първи ред.</span><span class="delimiter">'</span></span> + LineEnding + <span class="string"><span class="delimiter">'</span><span class="content">Втори ред.</span><span class="delimiter">'</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>или това:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Първи ред.</span><span class="delimiter">'</span></span>);
WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Втори ред.</span><span class="delimiter">'</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обърнете внимание, че това ще работи само в <em>конзолно</em> приложение. Уверете се, че имате дефиниция <code>{$apptype CONSOLE}</code> а <strong>не</strong> <code>{$apptype GUI}</code> в основния файл на програмата. В някои операционни системи няма значение и винаги ще работи (Unix), но на други (Windows) опита за изпечатване с <code>Write</code> или <code>WriteLn</code> в GUI приложение ще предизвика грешка.</p>
</div>
<div class="paragraph">
<p>В <strong>Castle Game Engine:</strong> използвайте <code>WriteLnLog</code> или <code>WriteLnWarning</code> вместо <code>WriteLn</code> за печат на диагностична информация. Те винаги ще бъдат насочени към някакво полезно устройство или файл. В Unix това ще бъде стандартния изход. В Windows GUI приложение ще бъде лог-файл. В Android ще бъде <em>Android logging facility</em> (може да се прочете с <code>adb logcat</code>). Използването на <code>WriteLn</code> трябва да се ограничи до случаите, в които се пишат конзолни приложения (напримел 3D моделен конвертор / генератор) и знаете, че  <em>стандартния изход</em> съществува.</p>
</div>
</div>
<div class="sect2">
<h3 id="_преобразуване_в_низ">2.9. Преобразуване в низ</h3>
<div class="paragraph">
<p>За конвертиране на произволен брой аргументи в низ (вместо просто директно да ги извеждате) съществуват няколко възможности.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Може да конвертирате определени типове в низ като използвате специализираните функции като <code>IntToStr</code> и <code>FloatToStr</code>. Освен това, в Паскал да можете да конкатенирате (свързвате) низове просто като използвате оператора за събиране. По този начин можете да съдадете низ подобен на следния: <code>'Моето цяло число е ' + IntToStr(MyInt) + ' и стойността на Pi е ' + FloatToStr(Pi)</code>.</p>
<div class="ulist">
<ul>
<li>
<p><em>Предимство</em>: Изключително удобно. Съществува множество готови функции <code>XxxToStr</code> и подобни на тях (например <code>FormatFloat</code>), покриващи  много типове. Повечето от тях са в модула <code>SysUtils</code>.</p>
</li>
<li>
<p><em>Друго предимство</em>: Почти винаги съществува и обратна функция. За конвертиране на низ (напр. въведен от потребителя) обратно до цяло число или до число с плаваща запетая, може да се използват <code>StrToInt</code>, <code>StrToFloat</code> и подобни на тях (например <code>StrToIntDef</code>).</p>
</li>
<li>
<p><em>Недостатък</em>: Дълга конкатенация от много извиквания на <code>XxxToStr</code> и низове не изглежда красиво.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Функцията <code>Format</code>, използва се по следния начин: <code>Format('%d %f %s', [MyInt, MyFloat, MyString])</code>. Тя е подобна на функцията <code>sprintf</code> в C-подобните езици. Тя вмъква аргументите си на зададените места в указания шаблон. Така зададените места може да използват специален синтаксис за уточняване на формата, напр. <code>%.4f</code> означава число с плаваща запетая с 4 знака след запетаята.</p>
<div class="ulist">
<ul>
<li>
<p><em>Предимство</em>: Разделянето на <em>шаблона</em> от <em>аргументите</em> изглежда по-чисто и спретнато. Ако искате да промените <em>шаблона</em> без да закачате аргументите (напр. при езиков превод), лесно може да го направите.</p>
</li>
<li>
<p><em>Друго предимство</em>: Няма никаква компилаторна магия. Може да използвате същия синтаксис за да подадете всякакъв брой аргументи от произволен тип в собствените си подпрограми (декларирайте параметър като <code>array of const</code>). След това можете да предадете тези аргументи надолу към <code>Format</code>, или да разчлените листа с аргументи и да правите каквото си искате с тях.</p>
</li>
<li>
<p><em>Недостатък</em>: Компилатора не проверява дали шаблона съвпада с броя и типа на аргументите. Използването на неподходящ синтаксис на конкретното място в шаблона ще предизвика изключение по време на изпълнение (<code>EConvertError</code> а не нещо гадно като грешка в сегментацията).</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>WriteStr(TargetString, &#8230;&#8203;)</code> процедурата работи по същия начин както <code>Write(&#8230;&#8203;)</code>, с изключение на това, че резултата се записва в  <code>TargetString</code> вместо да се отпечати.</p>
<div class="ulist">
<ul>
<li>
<p><em>Предимство</em>: Поддържа всички функционалности на <code>Write</code>, включително специалния синтаксис за форматиране за ширина на полето и знаци след запетаята, напр. <code>Pi:1:4</code>.</p>
</li>
<li>
<p><em>Недостатък</em>: Синтаксиса за форматиране е като "компилаторна магия", направена конкретно за процедури като тази. Това понякога е проблем, защото не можете да направите собствена процедура <code>MyStringFormatter(&#8230;&#8203;)</code>, която да позволява използването на нещо подобно на <code>Pi:1:4</code>. Поради тази причина (и защото дълго време не е била имплементирана в основните Паскал компилатори), конструкцията не е много популярна.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_модули_unit_и">3. Модули (Unit-и)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unit-ите позволяват групиране на общи елементи (всички, които могат да се декларират), за използване от други unit-и и програми. Те са еквиваленти на <em>модулите</em> и <em>пакетите</em> в други езици за програмиране. Имат секция <em>interface</em>, където се декларират елементите достъпни за използване от другите unit-и и програми и секция <em>implementation</em> където е описано как тези елементи работят. Може да запишете unit-а <code>MyUnit</code> под името <code>myunit.pas</code> (малки букви с разширение <code>.pas</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> MyUnit;
<span class="keyword">interface</span>

<span class="keyword">procedure</span> MyProcedure(<span class="keyword">const</span> A: Integer);
<span class="keyword">function</span> MyFunction(<span class="keyword">const</span> S: <span class="keyword">string</span>): <span class="keyword">string</span>;

<span class="keyword">implementation</span>

<span class="keyword">procedure</span> MyProcedure(<span class="keyword">const</span> A: Integer);
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">A + 10 е равно на: </span><span class="delimiter">'</span></span>, A + <span class="integer">10</span>);
<span class="keyword">end</span>;

<span class="keyword">function</span> MyFunction(<span class="keyword">const</span> S: <span class="keyword">string</span>): <span class="keyword">string</span>;
<span class="keyword">begin</span>
  Result := S + <span class="string"><span class="delimiter">'</span><span class="content">низовете се управляват автоматично</span><span class="delimiter">'</span></span>;
<span class="keyword">end</span>;

<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Основната програма се записва обикновено под име <code>myprogram.lpr</code> (<code>lpr</code> = Lazarus program file; в Delphi обикновено се използва <code>.dpr</code>). Трябва да се спомене, че са възможни и други разширения, някои проекти използват <code>.pas</code> за основната програма, някои използват <code>.pp</code> за unit-и или програми. Аз препоръчвам използването на <code>.pas</code> за unit-и и <code>.lpr</code> за FPC/Lazarus програми.</p>
</div>
<div class="paragraph">
<p>Програма може да използва unit със служебната дума <code>uses</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>

<span class="keyword">program</span> MyProgram;

<span class="keyword">uses</span>
  MyUnit;

<span class="keyword">begin</span>
  WriteLn(MyFunction(<span class="string"><span class="delimiter">'</span><span class="content">Забележка: </span><span class="delimiter">'</span></span>));
  MyProcedure(<span class="integer">5</span>);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unit-а може да съдържа секции <code>initialization</code> и <code>finalization</code>. Кода в тези секции се изпълнява когато програмата стартира или респективно&#8201;&#8212;&#8201;приключва.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> initialization_finalization;
<span class="keyword">interface</span>

<span class="keyword">implementation</span>

<span class="keyword">initialization</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Hello world!</span><span class="delimiter">'</span></span>);
<span class="keyword">finalization</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Goodbye world!</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_unit_и_които_се_използват_взаимно">3.1. Unit-и, които се използват взаимно</h3>
<div class="paragraph">
<p>Един unit може да използва друг unit. Другия unit може да се използва в секцията interface или само в секцията implementation. Първото позволява да се дефинират нови публикувани елементи (процедури, типове,&#8230;&#8203;) на базата на вече известните от другия unit. Второто е по-ограничено, т.е. ако използвате unit само в секцията implementation, неговите идентификатори важат само в нея.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> AnotherUnit;
<span class="keyword">interface</span>

<span class="keyword">uses</span> Classes;

<span class="comment">{ Типът (клас) &quot;TComponent&quot; е дефиниран в unit Classes.
  Поради тази причина трябва да използваме uses Classes; по-горе. }</span>
<span class="keyword">procedure</span> DoSomethingWithComponent(<span class="keyword">var</span> C: TComponent);

<span class="keyword">implementation</span>

<span class="keyword">uses</span> SysUtils;

<span class="keyword">procedure</span> DoSomethingWithComponent(<span class="keyword">var</span> C: TComponent);
<span class="keyword">begin</span>
  <span class="comment">{ Процедурата FreeAndNil е дефинирана в unit SysUtils.
    Тъй като го използваме само в реализацията а не в интерфейсната част, 
    достатъчно е да използваме uses SysUtils; в секция &quot;implementation&quot;. }</span>
  FreeAndNil(C);
<span class="keyword">end</span>;

<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Не е позволено да има <em>кръгови зависимости между unit-и</em> в техния интерфейс. Това означава, че не може два unit-а да се използват взаимно в секцията interface.
Причината за това е, че за да "разбере"
интерфейсната част на даден unit, компилатора трябва първо да "разбере" интерфейсната част на всички други unit-и, които той използва. Езикът Паскал спазва това правило много стриктно и това позволява бързата компилация и автоматичното определяне <em>какво е нужно да се прекомпилира</em>. Няма необходимост да се използват сложни файлове <code>Makefile</code> за простата задача по компилирането, както и също няма нужда от <em>прекомпилиране на всичко</em> само за да се уверим, че всички зависимости са се обновили правилно.</p>
</div>
<div class="paragraph">
<p>Напълно е възможно кръговото използване на unit-и при условие, че <em>поне единият от тях се използва в секция implementation</em>. Така например unit <code>A</code> може да използва <code>B</code> в секцията си interface а от друга страна unit <code>B</code> може да използва  unit <code>A</code> в секцията си implementation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_квалифициране_на_идентификаторите_с_името_на_unit_а">3.2. Квалифициране на идентификаторите с името на unit-а</h3>
<div class="paragraph">
<p>Различни unit-и може да дефинират един и същи идентификатор. За да бъде кода прост за четене и търсене, това би трябвало да се избягва но не винаги е възможно.
В тези случаи обикновено "печели" последния включен unit в клаузата <code>uses</code>, което означава че неговите идентификатори скриват тези със същите имена от предишните unit-и.</p>
</div>
<div class="paragraph">
<p>Винаги може да укажете изрично unit-а за даден идентификатор като използвате името на unit-а пред него разделено с точка <code>MyUnit.MyIdentifier</code>. Това е стандартното решение за ситуации, в които желания идентификатор от <code>MyUnit</code> е скрит от друг unit. Разбира се може също да промените реда на unit-ите в клаузата uses, но пък това ще засегне и всички други дефинирани идентификатори.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">program</span> showcolor;

<span class="comment">// И двата unit-а Graphics и GoogleMapsEngine дефинират тип TColor.</span>
<span class="keyword">uses</span> Graphics, GoogleMapsEngine;

<span class="keyword">var</span>
  <span class="comment">{ Това не работи както ни се иска, оказва се, че TColor е
    дефиниран от GoogleMapsEngine. }</span>
  <span class="comment">// Color: TColor;</span>
  <span class="comment">{ Това работи. }</span>
  Color: Graphics.TColor;
<span class="keyword">begin</span>
  Color := clYellow;
  WriteLn(Red(Color), <span class="char"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span>, Green(Color), <span class="char"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span>, Blue(Color));
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>За unit-ите трябва да се запомни, че имат две <code>uses</code> клаузи: едната в част interface и другата в част implementation. Правилото <em>следващите unit-и скриват идентификаторите на предишните</em> се прилага навсякъде, което означава и че <em>unit-ите използвани в част implementation</em> могат да скрият идентификатори от unit-и <em>използвани в секция interface</em>. От друга страна, факта че за секция <code>interface</code> имат значение само unit-ите използвани в interface, може да доведе до объркващи ситуации, в които привидно еднакви декларации се приемат за различни от компилатора:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> UnitUsingColors;

<span class="comment">// НЕКОРЕКТЕН пример</span>

<span class="keyword">interface</span>

<span class="keyword">uses</span> Graphics;

<span class="keyword">procedure</span> ShowColor(<span class="keyword">const</span> Color: TColor);

<span class="keyword">implementation</span>

<span class="keyword">uses</span> GoogleMapsEngine;

<span class="keyword">procedure</span> ShowColor(<span class="keyword">const</span> Color: TColor);
<span class="keyword">begin</span>
  <span class="comment">// WriteLn(ColorToString(Color));</span>
<span class="keyword">end</span>;

<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>В unit <code>Graphics</code> (от Lazarus LCL) се дефинира тип <code>TColor</code>. Но компилатора няма да компилира горния unit, твърдейки че не сте написали тяло на процедурата <code>ShowColor</code>, която да отговаря на декларацията в interface. Проблемът е че unit <code>GoogleMapsEngine</code> също дефинира тип с името <code>TColor</code>. Понеже се използва само в секция <code>implementation</code>, тази дефиниция <em>засенчва</em> дефиницията <code>TColor</code> само в implementation. Еквивалентната версия на горния unit, където грешката е очевидна, би изглеждала така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> UnitUsingColors;

<span class="comment">// НЕКОРЕКТЕН пример</span>
<span class="comment">// Ето какво &quot;вижда&quot; компилатора когато се опитва да компилира предишното</span>

<span class="keyword">interface</span>

<span class="keyword">uses</span> Graphics;

<span class="keyword">procedure</span> ShowColor(<span class="keyword">const</span> Color: Graphics.TColor);

<span class="keyword">implementation</span>

<span class="keyword">uses</span> GoogleMapsEngine;

<span class="keyword">procedure</span> ShowColor(<span class="keyword">const</span> Color: GoogleMapsEngine.TColor);
<span class="keyword">begin</span>
  <span class="comment">// WriteLn(ColorToString(Color));</span>
<span class="keyword">end</span>;

<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Решението на проблема в случая е просто&#8201;&#8212;&#8201;укажете изрично в implementaton да се използва <code>TColor</code> от unit <code>Graphics</code>. Може и да го оправите като преместите <code>GoogleMapsEngine</code> в секция interface преди <code>Graphics</code>. Това обаче ще доведе до други последици в unit-а <code>UnitUsingColors</code> защото ще се отрази на всичките му дефиниции.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> UnitUsingColors;

<span class="keyword">interface</span>

<span class="keyword">uses</span> Graphics;

<span class="keyword">procedure</span> ShowColor(<span class="keyword">const</span> Color: TColor);

<span class="keyword">implementation</span>

<span class="keyword">uses</span> GoogleMapsEngine;

<span class="keyword">procedure</span> ShowColor(<span class="keyword">const</span> Color: Graphics.TColor);
<span class="keyword">begin</span>
  <span class="comment">// WriteLn(ColorToString(Color));</span>
<span class="keyword">end</span>;

<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_представяне_на_идентификаторите_от_един_unit_чрез_друг">3.3. Представяне на идентификаторите от един unit чрез друг</h3>
<div class="paragraph">
<p>Понякога искате да вземете идентификатор от един unit и да го <em>представите</em> чрез друг. Крайният резултат трябва да бъде, че когато исползвате новия unit, стария идентификатор ще бъде достъпен в пространството на имената.</p>
</div>
<div class="paragraph">
<p>Понякога това е необходимо за да се запази съвместимостта с по-стари версии на unit-а. А понякога е удобно да се "скрие" някой unit само за вътрешно ползване.</p>
</div>
<div class="paragraph">
<p>Това може да се направи с повторна дефиниция на идентификатора в новия unit.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> MyUnit;

<span class="keyword">interface</span>

<span class="keyword">uses</span> Graphics;

<span class="keyword">type</span>
  <span class="comment">{ Представи TColor от unit Graphics като TMyColor. }</span>
  TMyColor = TColor;

  <span class="comment">{ Алтернативно, представи го под същото име.
    Квалифицирай типа с името на unit-a, в противен случай ще изглежда,
    че типа се позовава сам на себе си &quot;TColor = TColor&quot; в дефиницията. }</span>
  TColor = Graphics.TColor;

<span class="keyword">const</span>
  <span class="comment">{ Може така да предстaвите и константи от друг unit. }</span>
  clYellow = Graphics.clYellow;
  clBlue = Graphics.clBlue;

<span class="keyword">implementation</span>

<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Трябва да се отбележи, че този трик не може така лесно да се направи с глобалните процедури, функции и променливи. С процедурите и функциите можете да обявите константен указател към процедура в друг unit (виж <a href="#Callbacks">Callbacks (познати като <em>Събития</em>, също като <em>Указатели към функции</em>, също като <em>Процедурни променливи</em>)</a>), но това изглежда доста "нечисто".</p>
</div>
<div class="paragraph">
<p>Обикновено решението се състои в създаване на "опаковъчни" функции<sup class="footnote" id="_footnote_wrappers">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup>, които просто извикват старите от другия unit, като им подават параметрите и връщат резултата.</p>
</div>
<div class="paragraph">
<p>За да се направи нещо подобно с глобалните променливи, може да се използват глобални свойства (unit-level properties), виж <a href="#_свойства">Свойства</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_класове">4. Класове</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_основи_2">4.1. Основи</h3>
<div class="paragraph">
<p>В Паскал се използват класове (classes). На базово ниво класовете са просто контейнери за:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>полета (fields)</em> (друго име за <em>"променлива вътре в класа"</em>),</p>
</li>
<li>
<p><em>методи (methods)</em> (друго име за <em>"процедура или функция вътре в класа"</em>),</p>
</li>
<li>
<p>и <em>свойства (properties)</em> (удобен синтаксис за нещо, което е подобно на поле, но всъщност е двойка методи за <em>четене (get)</em> и <em>запис (set)</em> на някаква стойност; повече за това в <a href="#_свойства">Свойства</a>).</p>
</li>
<li>
<p>Общо казано, в един клас може да се вместят много други неща, повече е описано в <a href="#_допълнителни_декларации_и_вложени_класове">Допълнителни декларации и вложени класове</a>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
    MyInt: Integer; <span class="comment">// това е поле</span>
    <span class="keyword">property</span> MyIntProperty: Integer <span class="directive">read</span> MyInt <span class="directive">write</span> MyInt; <span class="comment">// това е свойство</span>
    <span class="keyword">procedure</span> MyMethod; <span class="comment">// това е метод</span>
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.MyMethod;
<span class="keyword">begin</span>
  WriteLn(MyInt + <span class="integer">10</span>);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_наследяване_проверка_is_конверсия_на_типа_as">4.2. Наследяване, проверка (is), конверсия на типа (as)</h3>
<div class="paragraph">
<p>Паскал поддържа <em>наследяване</em> на класове и <em>виртуални</em> методи.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">program</span> MyProgram;

<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
    MyInt: Integer;
    <span class="keyword">procedure</span> MyVirtualMethod; <span class="directive">virtual</span>;
  <span class="keyword">end</span>;

  TMyClassDescendant = <span class="keyword">class</span>(TMyClass)
    <span class="keyword">procedure</span> MyVirtualMethod; <span class="directive">override</span>;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.MyVirtualMethod;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass shows MyInt + 10: </span><span class="delimiter">'</span></span>, MyInt + <span class="integer">10</span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClassDescendant.MyVirtualMethod;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClassDescendant shows MyInt + 20: </span><span class="delimiter">'</span></span>, MyInt + <span class="integer">20</span>);
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C: TMyClass;
<span class="keyword">begin</span>
  C := TMyClass.Create;
  <span class="keyword">try</span>
    C.MyVirtualMethod;
  <span class="keyword">finally</span>
    FreeAndNil(C);
  <span class="keyword">end</span>;

  C := TMyClassDescendant.Create;
  <span class="keyword">try</span>
    C.MyVirtualMethod;
  <span class="keyword">finally</span>
    FreeAndNil(C);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>По подразбиране методите не са виртуални, за да бъдат такива трябва да се декларират със запазената дума <code>virtual</code>. Подмяната на виртуален метод трябва да се декларира с <code>override</code>, в противен случай ще се изведе предупреждение. За да скриете метод без да го подменяте трябва да се използва думата <code>reintroduce</code> (обикновено това се прави само ако имате основателна причина).</p>
</div>
<div class="paragraph">
<p>За да се провери какъв е класа на обектна инстанция по време на изпълнение се използва оператора <code>is</code>. За да се смени типа на инстанция, т.е. да се конвертира до друг клас, се използва оператора  <code>as</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">program</span> is_as;

<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
    <span class="keyword">procedure</span> MyMethod;
  <span class="keyword">end</span>;

  TMyClassDescendant = <span class="keyword">class</span>(TMyClass)
    <span class="keyword">procedure</span> MyMethodInDescendant;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.MyMethod;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">MyMethod</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClassDescendant.MyMethodInDescendant;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">MyMethodInDescendant</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">var</span>
  Descendant: TMyClassDescendant;
  C: TMyClass;
<span class="keyword">begin</span>
  Descendant := TMyClassDescendant.Create;
  <span class="keyword">try</span>
    Descendant.MyMethod;
    Descendant.MyMethodInDescendant;

    <span class="comment">{ Descendant има цялата функционалност, която се очаква от
      TMyClass, така че това присвояване е OK }</span>
    C := Descendant;
    C.MyMethod;

    <span class="comment">{ Това не може да сработи, тъй като TMyClass не дефинира този метод }</span>
    <span class="comment">//C.MyMethodInDescendant;</span>
    <span class="keyword">if</span> C <span class="keyword">is</span> TMyClassDescendant <span class="keyword">then</span>
      (C <span class="keyword">as</span> TMyClassDescendant).MyMethodInDescendant;

  <span class="keyword">finally</span>
    FreeAndNil(Descendant);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вместо <code>X as TMyClass</code>, може да използвате и конвертиране <em>без проверка</em> <code>TMyClass(X)</code>. Това е по-бързо от предишното, но резултата може да доведе до неопределено поведение ако <code>X</code> не се явява наследник на <code>TMyClass</code>. Поради тази причина не използвайте <code>TMyClass(X)</code>, освен ако не е <strong>абсолютно</strong> сигурно, че <code>X</code> е наследник на <code>TMyClass</code>, например ако преди това сте проверили с <code>is</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> A <span class="keyword">is</span> TMyClass <span class="keyword">then</span>
  (A <span class="keyword">as</span> TMyClass).CallSomeMethodOfMyClass;
<span class="comment">// долното е малко по-бързо</span>
<span class="keyword">if</span> A <span class="keyword">is</span> TMyClass <span class="keyword">then</span>
  TMyClass(A).CallSomeMethodOfMyClass;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_свойства">4.3. Свойства</h3>
<div class="paragraph">
<p>Свойствата са много удобна <em>"синтактична захар"</em> (б.пр. syntax sugar - особеност на синтаксиса, която не влияе на поведението на програмата, но прави използването на езика по-удобно) за:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Нещо да изглежда като поле (да може да се чете и записва) но под него да има методи за четене (<em>getter</em>) и запис (<em>setter</em>). Често се използва за получаване на странични ефекти (напр. обновяване на екрана) всеки път когато стойността се промени;</p>
</li>
<li>
<p>Нещо да изглежда като поле, но да е само за четене. В резултат на това полето е подобно на константа или функция без аргументи.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TWebPage = <span class="keyword">class</span>
  <span class="directive">private</span>
    FURL: <span class="keyword">string</span>;
    FColor: TColor;
    <span class="keyword">function</span> SetColor(<span class="keyword">const</span> Value: TColor);
  <span class="directive">public</span>
    <span class="comment">{ Няма начин да се запише директно.
      Извикайте метода Load, например Load('http://www.freepascal.org/'),
      за да заредите страницатата и да установите свойството. }</span>
    <span class="keyword">property</span> URL: <span class="keyword">string</span> <span class="directive">read</span> FURL;
    <span class="keyword">procedure</span> Load(<span class="keyword">const</span> AnURL: <span class="keyword">string</span>);
    <span class="keyword">property</span> Color: TColor <span class="directive">read</span> FColor <span class="directive">write</span> SetColor;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TWebPage.Load(<span class="keyword">const</span> AnURL: <span class="keyword">string</span>);
<span class="keyword">begin</span>
  FURL := AnURL;
  NetworkingComponent.LoadWebPage(AnURL);
<span class="keyword">end</span>;

<span class="keyword">function</span> TWebPage.SetColor(<span class="keyword">const</span> Value: TColor);
<span class="keyword">begin</span>
  <span class="keyword">if</span> FColor &lt;&gt; Value <span class="keyword">then</span>
  <span class="keyword">begin</span>
    FColor := Value;
    <span class="comment">// за пример: предизвиква обновяване всеки път при промяна на стойността</span>
    Repaint;
    <span class="comment">// пак за пример: осигурява, че някаква друга вътрешна инстанция,</span>
    <span class="comment">// като &quot;RenderingComponent&quot; (каквато и да е тя),</span>
    <span class="comment">// съдържа същата стойност за Color.</span>
    RenderingComponent.Color := Value;
  <span class="keyword">end</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Забележете, че вместо да се укаже метод, може да се укаже и име на поле (обикновено частно поле) за директно четене или запис. В горния пример, свойството <code>Color</code> използва метод за запис (<em>setter</em> <code>SetColor</code>. Но за прочитане на стойността свойството <code>Color</code> указва директно към частното поле <code>FColor</code>. Указването на поле е по-бързо отколкото извикването на "опъковъчен" метод за четене или запис. По-бързо е както за писане, така и за изпълнение.</p>
</div>
<div class="paragraph">
<p>Когато се декларира свойство трябва да се укаже:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Дали може да се чете и как (с директен достъп до поле или с извикване на метод <code>getter</code>);</p>
</li>
<li>
<p>И съответно&#8201;&#8212;&#8201;дали може да се записва и как (с директен достъп до поле или с използване на метод <code>setter</code>).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Компилатора проверява дали типовете на указаните полета и методи съответстват на типа на свойството. Например, за да прочетете <code>Integer</code> свойство, трябва да укажете или поле от тип <code>Integer</code> или метод без параметри, който връща <code>Integer</code>.</p>
</div>
<div class="paragraph">
<p>Технически, за компилатора методите "getter" и "setter" са просто нормални методи и могат да правят абсолютно всичко (включително странични ефекти или рандомизация). Но е добра практика свойствата да се проектират така, че да се държат повече или по-малко като полета:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Функцията <em>getter</em> не би трябвало да има видими странични ефекти (напр. не трябва да чете от файл или от клавиатурата). Четенето трябва да е детерминистично (без рандомизация, дори псевдо-рандомизация :). Многократното четене на свойство трябва да връща една и съща стойност ако нищо не се е променило междувременно.</p>
<div class="paragraph">
<p>Напълно в реда на нещата е <em>getter</em> да има някакви <em>невидими</em> странични ефекти, например да съхрани стойностите от някакво изчисление за да се ускори изпълнението при следващо извикване. Това е една от полезните функции на методите "getter".</p>
</div>
</li>
<li>
<p>Функцията <em>setter</em> трябва винаги да запише подадената стойност, по такъв начин, че извикването на <em>getter</em> да я върне обратно. Не бива некоректните стойности автоматично да се игнорират в "setter", в такива случаи е редно да се предизвика изключение (exception). Не е добре също стойността да се конвертира или мащабира. Идеята е, че след <code>MyClass.MyProperty := 123;</code> програмиста трябва да очаква, че <code>MyClass.MyProperty = 123</code>.</p>
</li>
<li>
<p>Свойствата само за четене, <em>read-only properties</em>, често се използват за да е възможно само четенето на някое поле отвън. Отново, добрата практика е това свойство да се държи като константа или поне като константа за текущото състояние на обекта. Стойността не бива да се променя неочаквано. <em>Ако четенето предизвиква странични ефекти или се връща случайна стойност, вместо свойство трябва да се използва функция</em>.</p>
</li>
<li>
<p>Полето, към което се обръща свойството трябва винаги да е <em>private</em> защото идеята на свойството е да "капсулира" целия външен достъп до него.</p>
</li>
<li>
<p>Технически е възможно да се направи свойство само за запис, <em>set-only property</em>, но още не съм видял добър пример за какво може да послужи такова свойство :)</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
Свойствата могат да се дефинират и извън клас, на ниво unit. Такива свойства служат за аналогични цели&#8201;&#8212;&#8201;изглеждат като глобални променливи, но четенето и записа им извиква указаните подпрограми за <em>getter</em> и <em>setter</em>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_сериализация_на_свойства">4.3.1. Сериализация на свойства</h4>
<div class="paragraph">
<p><em>Публикуваните свойства</em> са база за <em>сериализацията</em> (или <em>streaming components</em>) в Паскал. <em>Сериализация</em> означава, че данните на инстанцията от даден клас се записват в поток (<em>stream</em>, подобно на файл), от който може по-късно да се прочетат обратно.</p>
</div>
<div class="paragraph">
<p>Сериализирането е това, което се случва, когато Lazarus чете (или записва) състоянието на компонент във файл <code>xxx.lfm</code>. (В Delphi еквивалентния файл има разширение <code>.dfm</code>). Този механизъм може да се използва и за други цели с помощта на процедури като <code>ReadComponentFromTextStream</code> от unit <code>LResources</code>. Също така може да се използват и други сериализационни алгоритми, например от unit <code>FpJsonRtti</code> (сериализация в JSON формат).</p>
</div>
<div class="paragraph">
<p>В <strong>Castle Game Engine</strong>: Използвайте unit <code>CastleComponentSerialize</code> (базиран на <code>FpJsonRtti</code>) за да сериализирате нашите компоненти като user-interface и transformation component hierarchies.</p>
</div>
<div class="paragraph">
<p>За всяко свойство може да се декларират допълнителни полезни неща за алгоритъма за сериализация:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Може да укажете подразбираща се стойност за свойството (с резервираната дума <code>default</code>). Обърнете внимание, че така или иначе в конструктора е необходимо да се инициализира това свойство с тази конкретна стойност по подразбиране. Това не се прави автоматично. Декларацията <code>default</code> е само информативна за сериализиращия алгоритъм: <em>"когато конструктора се изпълни, даденото свойство има дадената стойност"</em>.</p>
</li>
<li>
<p>Дали свойството трябва да се записва изобщо (с резервираната дума <code>stored</code>).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_изключения_кратък_пример">4.4. Изключения - Кратък пример</h3>
<div class="paragraph">
<p>В Паскал може да се предизвикват и обработват изключения. Обработката се прави с клаузи <code>try &#8230;&#8203; except &#8230;&#8203; end</code>, също така има и финални секции <code>try &#8230;&#8203; finally &#8230;&#8203; end</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>

<span class="keyword">program</span> MyProgram;

<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
    <span class="keyword">procedure</span> MyMethod;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.MyMethod;
<span class="keyword">begin</span>
  <span class="keyword">if</span> Random &gt; <span class="float">0.5</span> <span class="keyword">then</span>
    <span class="keyword">raise</span> Exception.Create(<span class="string"><span class="delimiter">'</span><span class="content">Raising an exception!</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C: TMyClass;
<span class="keyword">begin</span>
  Randomize;
  C := TMyClass.Create;
  <span class="keyword">try</span>
    C.MyMethod;
  <span class="keyword">finally</span>
    FreeAndNil(C);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обърнете внимание, че клаузата <code>finally</code> се изпълнява дори ако излезете от блок с използването на <code>Exit</code> (от функция / процедура / метод) или <code>Break</code> или <code>Continue</code> (от тялото на цикъл).</p>
</div>
<div class="paragraph">
<p>Виж глава <a href="#Exceptions">Изключения</a> за по-задълбочено описание на <em>изключенията</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_нива_на_видимост">4.5. Нива на видимост</h3>
<div class="paragraph">
<p>Както в повечето обектно-ориентирани езици, в Паскал има спецификатори за ограничаване на видимостта на полета / методи / свойства.</p>
</div>
<div class="paragraph">
<p>Основните нива на видимост са:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>public</code></dt>
<dd>
<p>всеки може да го достъпи, в това число и кода от други unit-и.</p>
</dd>
<dt class="hdlist1"><code>private</code></dt>
<dd>
<p>достъпно само в този клас.</p>
</dd>
<dt class="hdlist1"><code>protected</code></dt>
<dd>
<p>достъпно само в този клас и наследниците му.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Даденото по-горе обяснение за <code>private</code> и <code>protected</code> не е напълно вярно. Кодът <em>в същия unit</em> може да прескача ограничението и да достъпва неща, които са указани като <code>private</code> или <code>protected</code>. Понякога това е удобно, тъй като позволява създаване на по-силно свързани класове. Използвайте <code>strict private</code> или <code>strict protected</code> за да обезопасите вашите класове още по-стриктно. По-подробно това е описано в <a href="#_частни_и_лични_полета">Частни и лични полета</a>.</p>
</div>
<div class="paragraph">
<p>Ако не укажете видимост, по подразбиране се приема <code>public</code>. Изключение се прави за класовете компилирани с директивата <code>{$M+}</code>, или наследници на класове компилирани с <code>{$M+}</code>, което включва всички наследници на <code>TPersistent</code>, също така включва и всички наследници на <code>TComponent</code> (защото <code>TComponent</code> е наследник на <code>TPersistent</code>). За тях видимостта по подразбиране е <code>published</code>, което е като <code>public</code>, но с допълнението, че системата за сериализация знае как да ги обработва.</p>
</div>
<div class="paragraph">
<p>Не всяко поле и свойство може да бъде в секция <code>published</code> (не веки тип може да се сериализира и само класове от прости полета могат да се сериализират). Просто използвайте <code>public</code>, ако не ви е грижа за сериализацията, но искате нещо да е достъпно за всички ползватели.</p>
</div>
</div>
<div class="sect2">
<h3 id="_предшественик_по_подразбиране">4.6. Предшественик по подразбиране</h3>
<div class="paragraph">
<p>Ако не декларирате предшестващ клас, то по подразбиране се приема, че се наследява класа <code>TObject</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_self">4.7. Self</h3>
<div class="paragraph">
<p>Резервираната дума <code>Self</code> (аз) може да се използва в реализацията на класа за да укаже изрично, че става дума за вашата собствена инстанция. Това е еквивалент на <code>this</code> от C++, Java и подобни езици.</p>
</div>
</div>
<div class="sect2">
<h3 id="_извикване_на_наследен_метод">4.8. Извикване на наследен метод</h3>
<div class="paragraph">
<p>В рамките на реализация на метод, ако извикате друг метод, тогава по подразбиране вие извиквате метода на вашия собствен клас. В примерния код по-долу, <code>TMyClass2.MyOtherMethod</code> извиква <code>MyMethod</code>, който в крайна сметка извиква <code>TMyClass2.MyMethod</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span> SysUtils;

<span class="keyword">type</span>
  TMyClass1 = <span class="keyword">class</span>
    <span class="keyword">procedure</span> MyMethod;
  <span class="keyword">end</span>;

  TMyClass2 = <span class="keyword">class</span>(TMyClass1)
    <span class="keyword">procedure</span> MyMethod;
    <span class="keyword">procedure</span> MyOtherMethod;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass1.MyMethod;
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass1.MyMethod</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass2.MyMethod;
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass2.MyMethod</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass2.MyOtherMethod;
<span class="keyword">begin</span>
  MyMethod; <span class="comment">// this calls TMyClass2.MyMethod</span>
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C: TMyClass2;
<span class="keyword">begin</span>
  C := TMyClass2.Create;
  <span class="keyword">try</span>
    C.MyOtherMethod;
  <span class="keyword">finally</span> FreeAndNil(C) <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако метода не е дефиниран за дадения клас, тогава се извиква метод от предшестващия клас. Всъщност, когато извикате <code>MyMethod</code> на инстация от <code>TMyClass2</code>, тогава</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Компилатора търси <code>TMyClass2.MyMethod</code>.</p>
</li>
<li>
<p>Ако не го намери, търси <code>TMyClass1.MyMethod</code>.</p>
</li>
<li>
<p>Ако не го намери, търси <code>TObject.MyMethod</code>.</p>
</li>
<li>
<p>Ако не го намери, дава грешка при компилация.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Може да го проверите като сложите коментар пред дефиницията на <code>TMyClass2.MyMethod</code> в по-горния пример. Като резултат от извикването на <code>TMyClass2.MyOtherMethod</code> ще се извика <code>TMyClass1.MyMethod</code>.</p>
</div>
<div class="paragraph">
<p>Понякога не искате да извиквате метода на собствения си клас а искате да извикате метода на предшественик (или предшественик на предшественик и т.н). За да направите това, добавете ключовата дума <code>inherited</code> преди извикването на <code>MyMethod</code> по следния начин:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">inherited</span> MyMethod;</code></pre>
</div>
</div>
<div class="paragraph">
<p>По този начин вие <em>насилвате</em> компилаторът да започне да търси от предшестващия клас. В нашия пример това означава, че компилаторът търси <code>MyMethod</code> в <code>TMyClass1.MyMethod</code>, след това <code>TObject.MyMethod</code> и след това се отказва. Дори и не обмисля използването на <code>TMyClass2.MyMethod</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Подсказка</div>
</td>
<td class="content">
Променете <code>TMyClass2.MyOtherMethod</code> така, че да използва <code>inherited MyMethod</code> и вижте каква ще е разликата в резултата.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Най-често извикването на наследен метод се използва от метода със същото име в наследника. По този начин наследника може да допълни и подобри предшественика запазвайки неговата функционалност вместо да я подмени изцяло. Както в примера по-долу.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span> SysUtils;

<span class="keyword">type</span>
  TMyClass1 = <span class="keyword">class</span>
    <span class="keyword">constructor</span> Create;
    <span class="keyword">procedure</span> MyMethod(<span class="keyword">const</span> A: Integer);
  <span class="keyword">end</span>;

  TMyClass2 = <span class="keyword">class</span>(TMyClass1)
    <span class="keyword">constructor</span> Create;
    <span class="keyword">procedure</span> MyMethod(<span class="keyword">const</span> A: Integer);
  <span class="keyword">end</span>;

<span class="keyword">constructor</span> TMyClass1.Create;
<span class="keyword">begin</span>
  <span class="keyword">inherited</span> Create; <span class="comment">// this calls TObject.Create</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass1.Create</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass1.MyMethod(<span class="keyword">const</span> A: Integer);
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass1.MyMethod </span><span class="delimiter">'</span></span>, A);
<span class="keyword">end</span>;

<span class="keyword">constructor</span> TMyClass2.Create;
<span class="keyword">begin</span>
  <span class="keyword">inherited</span> Create; <span class="comment">// this calls TMyClass1.Create</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass2.Create</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass2.MyMethod(<span class="keyword">const</span> A: Integer);
<span class="keyword">begin</span>
  <span class="keyword">inherited</span> MyMethod(A); <span class="comment">// this calls TMyClass1.MyMethod</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass2.MyMethod </span><span class="delimiter">'</span></span>, A);
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C: TMyClass2;
<span class="keyword">begin</span>
  C := TMyClass2.Create;
  <span class="keyword">try</span>
    C.MyMethod(<span class="integer">123</span>);
  <span class="keyword">finally</span> FreeAndNil(C) <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Понеже използването на <code>inherited</code> за извикване на метод със същото име и аргументи се среща много често, има специален съкратен вариант: може да напишете само <code>inherited;</code> (ключовата дума <code>inherited</code>, следвана непосредствено от точка и запетая, вместо името на метод). Това означава "<em>извикай наследения метод със същото име, предавайки му същите параметри както на текущия метод</em>".</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Подсказка</div>
</td>
<td class="content">
В горния пример, всички извиквания на <code>inherited &#8230;&#8203;;</code> могат да се заменят просто с <code>inherited;</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Бележка 1: Този <code>inherited;</code> е наистина съкращение на извикването на наследения метод със <em>същите параметри</em>. Ако вече сте променили стойностите на параметрите (което е напълно възможно ако не са <code>const</code>), тогава наследения метод може да получи различни входни стойности от вашия наследник. Разгледайте следното:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">procedure</span> TMyClass2.MyMethod(A: Integer);
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass2.MyMethod начално </span><span class="delimiter">'</span></span>, A);
  A := <span class="integer">456</span>;
  <span class="comment">{ Това извиква TMyClass1.MyMethod with A = 456,
    независимо от стойността на A подадена на този метод (TMyClass2.MyMethod). }</span>
  <span class="keyword">inherited</span>;
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass2.MyMethod крайно </span><span class="delimiter">'</span></span>, A);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Бележка 2: Когато много класове дефинират метода <code>MyMethod</code> (по "<em>веригата на наследяване</em>") обикновено той се прави <em>виртуален</em>. Повече за виртуалните методи има в раздела по-долу. Но ключовата дума <code>inherited</code> работи независимо дали методът е виртуален или не. <code>inherited</code> винаги означава, че компилаторът започва да търси метода в предшественика и има смисъл както за <em>виртуални</em>, така и за <em>не виртуални</em> методи.</p>
</div>
</div>
<div class="sect2">
<h3 id="virtual-methods-override-reintroduce">4.9. Виртуални методи, подмяна и скриване</h3>
<div class="paragraph">
<p>По подразбиране методите <em>не са виртуални</em>. Това е както в езика C++ и за разлика от Java.</p>
</div>
<div class="paragraph">
<p>Когато методът <em>не е виртуален</em>, компилаторът определя кой метод да се извика въз основа на текущия <em>деклариран</em> тип клас, а не въз основа на <em>действително създадения</em> тип клас. Разликата изглежда незначителна, но е важно, когато променливата ви е декларирана, че е от клас <code>TFruit</code>, но всъщност може да е от клас-наследник например <code>TApple</code>.</p>
</div>
<div class="paragraph">
<p>Идеята на обектно-ориентираното програмиране е, че <em>класът-наследник винаги е добър поне колкото наследения</em>, така че компилатора позволява използването на наследник винаги когато се очаква някой от предшествениците му. Когато един метод <em>не е виртуален</em>, това може да доведе до нежелани последици. Разгледайте следния случай:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span> SysUtils;

<span class="keyword">type</span>
  TFruit = <span class="keyword">class</span>
    <span class="keyword">procedure</span> Eat;
  <span class="keyword">end</span>;

  TApple = <span class="keyword">class</span>(TFruit)
    <span class="keyword">procedure</span> Eat;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TFruit.Eat;
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Изядохме плод</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TApple.Eat;
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Изядохме ябълка</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> DoSomethingWithAFruit(<span class="keyword">const</span> Fruit: TFruit);
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Имаме плод от клас </span><span class="delimiter">'</span></span>, Fruit.ClassName);
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Ядем го:</span><span class="delimiter">'</span></span>);
  Fruit.Eat;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  Apple: TApple; <span class="comment">// Забележка: тук също така може да декларирате &quot;Apple: TFruit&quot;</span>
<span class="keyword">begin</span>
  Apple := TApple.Create;
  <span class="keyword">try</span>
    DoSomethingWithAFruit(Apple);
  <span class="keyword">finally</span> FreeAndNil(Apple) <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Този пример ще отпечата</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Имаме плод от клас TApple
Ядем го:
Изядохме плод</pre>
</div>
</div>
<div class="paragraph">
<p>Всъщност извикването <code>Fruit.Eat</code> извиква имплементацията на <code>TFruit.Eat</code> и нищо не извика имплементацията на <code>TApple.Eat</code>.</p>
</div>
<div class="paragraph">
<p>Ако се замислите как работи компилатора, това ще ви се стори естествено: когато написахте <code>Fruit.Eat</code>, променливата <code>Fruit</code> бе декларирана от тип <code>TFruit</code>. Компилаторът търси метод наречен <code>Eat</code> в класа <code>TFruit</code>. Ако класът <code>TFruit</code> не съдържа такъв метод, компилаторът ще търси в предшественика (<code>TObject</code> в този случай). Но компилаторът <em>не може да търси в наследници (като <code>TApple</code>)</em>, тъй като не знае дали <em>действителният клас</em> на <code>Fruit</code> е <code>TApple</code>, <code>TFruit</code> или някакъв друг наследник на <code>TFruit</code> (като <code>TOrange</code>, не е показан в примера по-горе).</p>
</div>
<div class="paragraph">
<p>С други думи, <em>методът, който ще бъде извикан</em>, се определя по време на компилиране.</p>
</div>
<div class="paragraph">
<p>Използването на <em>виртуалните методи</em> променя това поведение. <strong>Ако методът <code>Eat</code> е виртуален</strong> (пример за него е показан по-долу), тогава действителната метод, която ще бъде извикан, се определя <em>по време на изпълнение</em>. Ако променливата <code>Fruit</code> съдържа екземпляр на класа <code>TApple</code> (дори ако променливата е декларирана като <code>TFruit</code>), тогава методът <code>Eat</code> ще бъде потърсен първо в <code>TApple</code>.</p>
</div>
<div class="paragraph">
<p>В Обектния Паскал, за да дефинирате метод като <em>виртуален</em>, трябва да:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Маркирайте първата му дефиниция (в най-горния предшественик) с ключовата дума <code>virtual</code>.</p>
</li>
<li>
<p>Маркирайте всички останали дефиниции (в наследниците) с ключовата дума <code>override</code>. Всички подменени версии трябва да имат абсолютно еднакви параметри (и да връщат едни и същи типове, в случая на функции).</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span> SysUtils;

<span class="keyword">type</span>
  TFruit = <span class="keyword">class</span>
    <span class="keyword">procedure</span> Eat; <span class="directive">virtual</span>;
  <span class="keyword">end</span>;

  TApple = <span class="keyword">class</span>(TFruit)
    <span class="keyword">procedure</span> Eat; <span class="directive">override</span>;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TFruit.Eat;
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Изядохме плод</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TApple.Eat;
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Изядохме ябълка</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> DoSomethingWithAFruit(<span class="keyword">const</span> Fruit: TFruit);
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Имаме плод от клас </span><span class="delimiter">'</span></span>, Fruit.ClassName);
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Ядем го:</span><span class="delimiter">'</span></span>);
  Fruit.Eat;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  Apple: TApple; <span class="comment">// Забележка: тук също така може да декларирате &quot;Apple: TFruit&quot;</span>
<span class="keyword">begin</span>
  Apple := TApple.Create;
  <span class="keyword">try</span>
    DoSomethingWithAFruit(Apple);
  <span class="keyword">finally</span> FreeAndNil(Apple) <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Този пример ще отпечата</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Имаме плод от клас TApple
Ядем го:
Изядохме ябълка</pre>
</div>
</div>
<div class="paragraph">
<p>Вътрешно виртуалните методи работят, като използват така наречената <em>виртуална таблица с методи (VMT)</em>, свързана с всеки клас. Тази таблица е списък с указатели към виртуалните методи за този клас. Когато извиква метода <code>Eat</code>, компилаторът разглежда таблицата с виртуални методи, свързана с <em>действителния</em> клас на <code>Fruit</code>, и използва указател към конкретния метод <code>Eat</code> съхранен там.</p>
</div>
<div class="paragraph">
<p>Ако не използвате ключовата дума <code>override</code>, компилаторът ще ви предупреди, че <em>скривате</em> виртуалния метод на предшественика с невиртуална дефиниция. Ако сте сигурни, че точно това искате да направите, можете да добавите ключова дума <code>reintroduce</code>. Но в повечето случаи e по-добре да запазите метода виртуален и да добавите ключовата дума <code>override</code>, като по този начин сте сигурни, че се извиква правилно.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_освобождаване_на_паметта_за_класове">5. Освобождаване на паметта за класове</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_помнете_да_освобождавате_паметта_заета_от_инстанциите">5.1. Помнете да освобождавате паметта заета от инстанциите</h3>
<div class="paragraph">
<p>Инстанциите на класове трябва да се освобождават ръчно. В противен случай ще се получи <em>изтичане на памет</em>. Съветвам да се използват опциите <code>-gl -gh</code> на FPC за засичане на изтичания (виж <a href="https://castle-engine.io/manual_optimization.php#section_memory" class="bare">https://castle-engine.io/manual_optimization.php#section_memory</a> ).</p>
</div>
<div class="paragraph">
<p>Забележете, че това не касае възникналите изключения. Въпреки че изрично създавате инстанция от клас, когато предизвиквате изключение (и това е напълно нормален клас и можете да създадете свои собствени класове за тази цел), то тази инстанция ще бъде освободена автоматично от вградения механизъм за обработка на изключения.</p>
</div>
</div>
<div class="sect2">
<h3 id="_как_да_освободим_паметта">5.2. Как да освободим паметта</h3>
<div class="paragraph">
<p>За да освободите заетата памет от инстанция на клас, най-добре извикайте <code>FreeAndNil(A)</code> от unit <code>SysUtils</code> върху нея. Тази процедура ще провери дали <code>A</code> е <code>nil</code>, ако не е&#8201;&#8212;&#8201;ще извика нейния деструктор (destructor) и ще и присвои стойност <code>nil</code>. Така многократното и извикване няма да доведе до грешка.</p>
</div>
<div class="paragraph">
<p>Приблизително това съответства на следното:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> A &lt;&gt; <span class="keyword">nil</span> <span class="keyword">then</span>
<span class="keyword">begin</span>
  A.Destroy;
  A := <span class="keyword">nil</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Всъщност това е доста опростено, тъй като <code>FreeAndNil</code> използва трик за да присвои <code>nil</code> на <code>A</code> <strong>преди</strong> да извика деструктора с подходяща препратка. Това предотвратява  определен клас грешки&#8201;&#8212;&#8201;идеята е, че "външният" код никога не бива да има достъп до полуразрушено копие на инстанция от класа.</p>
</div>
<div class="paragraph">
<p>Често ще видите и да се използва метода <code>A.Free</code>, което е същото като:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> A &lt;&gt; <span class="keyword">nil</span> <span class="keyword">then</span>
  A.Destroy;</code></pre>
</div>
</div>
<div class="paragraph">
<p>което унищожава инстанцията <code>A</code> (и освобождава заетата памет от нея) , освен ако тя е <code>nil</code>.</p>
</div>
<div class="paragraph">
<p>Забележете, че при нормални обстоятелства никога не бива да се извиква метод на инстанция, която може да е <code>nil</code>. Затова извикването <code>A.Free</code> може да изглежда подозрително на пръв поглед. Методът <code>Free</code> обаче е изключение от това правило. Той прави нещо "нечисто" в тялото си&#8201;&#8212;&#8201;именно проверява дали <code>Self &lt;&gt; nil</code>. Този трик работи само при методи, които не са виртуални (които не извикват други виртуални методи и не достъпват никакви полета).</p>
</div>
<div class="paragraph">
<p>Съветвам ви да използвате <code>FreeAndNil(A)</code> винаги, без изключения и никога да не извиквате директно метода <code>Free</code> или деструктора <code>Destroy</code>. <em>Castle Game Engine</em> работи по този начин. Това позволява да бъдете уверени в това, че <em>всички препратки са или <code>nil</code>, или сочат към валидни инстанции</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ръчно_и_автоматично_освобождаване">5.3. Ръчно и автоматично освобождаване</h3>
<div class="paragraph">
<p>В много случаи необходимостта от освобождаване на инстанцията не е голям проблем. Вие просто пишете деструктор, който съответства на конструктора и освобождава всичко, за което е заделена памет в конструктора (или по-точно - през целия живот на инстанцията). Внимавайте да освободите всяко нещо само <strong>веднъж</strong>. Добра идея е да установите освободения указател на <code>nil</code>, обикновено е най-удобно да го направите, като извикате <code>FreeAndNil(A)</code>.</p>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">uses</span> SysUtils;

<span class="keyword">type</span>
  TGun = <span class="keyword">class</span>
  <span class="keyword">end</span>;

  TPlayer = <span class="keyword">class</span>
    Gun1, Gun2: TGun;
    <span class="keyword">constructor</span> Create;
    <span class="keyword">destructor</span> Destroy; <span class="directive">override</span>;
  <span class="keyword">end</span>;

<span class="keyword">constructor</span> TPlayer.Create;
<span class="keyword">begin</span>
  <span class="keyword">inherited</span>;
  Gun1 := TGun.Create;
  Gun2 := TGun.Create;
<span class="keyword">end</span>;

<span class="keyword">destructor</span> TPlayer.Destroy;
<span class="keyword">begin</span>
  FreeAndNil(Gun1);
  FreeAndNil(Gun2);
  <span class="keyword">inherited</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>За да избегнете необходимостта от изрично освобождаване, можете също да използвате функцията за <em>"собственост"</em> на <code>TComponent</code>. Обект, който е <em>нечий</em> ще бъде автоматично освободен от <em>собственика</em>. Механизмът е достатъчно съобразителен и никога няма да освободи вече освободена инстанция (така че нещата ще работят правилно, дори ако ръчно освободите притежавания обект по-рано). Можем да променим предишния пример така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">uses</span> SysUtils, Classes;

<span class="keyword">type</span>
  TGun = <span class="keyword">class</span>(TComponent)
  <span class="keyword">end</span>;

  TPlayer = <span class="keyword">class</span>(TComponent)
    Gun1, Gun2: TGun;
    <span class="keyword">constructor</span> Create(AOwner: TComponent); <span class="directive">override</span>;
  <span class="keyword">end</span>;

<span class="keyword">constructor</span> TPlayer.Create(AOwner: TComponent);
<span class="keyword">begin</span>
  <span class="keyword">inherited</span>;
  Gun1 := TGun.Create(Self);
  Gun2 := TGun.Create(Self);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обърнете внимание, че тук трябва да заменим виртуалния конструктор на <code>TComponent</code>. Така че не можем да променим параметрите на конструктора. (Всъщност можете&#8201;&#8212;&#8201;декларирайте нов конструктор с <code>reintroduce</code>. Но бъдете внимателни, тъй като някои функции, например тези за сериализация, все още ще използват виртуалния конструктор, така че се уверете, че работи правилно и в двата случая.)</p>
</div>
<div class="paragraph">
<p>Имайте предвид, че винаги можете да използвате за собственик <code>nil</code>. По този начин механизмът за <em>"собственост"</em> няма да се използва за този компонент. Това има смисъл, ако трябва да използвате наследника на <code>TComponent</code>, но искате винаги да го освобождавате ръчно. За да направите това, трябва да конструирате наследника по този начин: <code>ManualGun := TGun.Create(nil);</code>.</p>
</div>
<div class="paragraph">
<p>Друг механизъм за автоматично освобождаване е функционалността <code>OwnsObjects</code> (по подразбиране е вече <code>true</code>!) на класовете-контейнери като <code>TFPGObjectList</code> или <code>TObjectList</code>. Така че можем също да напишем:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">uses</span> SysUtils, Classes, FGL;

<span class="keyword">type</span>
  TGun = <span class="keyword">class</span>
  <span class="keyword">end</span>;

  TGunList = specialize TFPGObjectList&lt;TGun&gt;;

  TPlayer = <span class="keyword">class</span>
    Guns: TGunList;
    Gun1, Gun2: TGun;
    <span class="keyword">constructor</span> Create;
    <span class="keyword">destructor</span> Destroy; <span class="directive">override</span>;
  <span class="keyword">end</span>;

<span class="keyword">constructor</span> TPlayer.Create;
<span class="keyword">begin</span>
  <span class="keyword">inherited</span>;
  <span class="comment">// Всъщност, стойността true (за OwnsObjects) е зададена по подразбиране</span>
  Guns := TGunList.Create(true);
  Gun1 := TGun.Create;
  Guns.Add(Gun1);
  Gun2 := TGun.Create;
  Guns.Add(Gun2);
<span class="keyword">end</span>;

<span class="keyword">destructor</span> TPlayer.Destroy;
<span class="keyword">begin</span>
  <span class="comment">{ Трябва да се погрижим за освобождаването на списъка.
    Той ще освободи елементите си автоматично. }</span>
  FreeAndNil(Guns);

  <span class="comment">{ Вече няма нужда да освобождаваме ръчно Gun1, Gun2. Хубав навик е да установим на &quot;nil&quot;
    техните препратки, тъй като знаем, че са освободени. В този прост клас и с
    този прост деструктор, очевидно е, че те няма да бъдат достъпвани повече --
    но правейки така ще ни помогне в случая на по-големи и по-сложни деструктори.

    Алтернативно, можем да си спестим декларирането на Gun1 и Gun2,
    и вместо това да използваме Guns[0] и Guns[1] в нашия код.
    Или да създадем метод Gun1, който връща Guns[0]. }</span>
  Gun1 := <span class="keyword">nil</span>;
  Gun2 := <span class="keyword">nil</span>;
  <span class="keyword">inherited</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Имайте предвид, че механизмът за "собственост" в този случай е сравнително прост и ще се получи грешка, ако освободите инстанция по друг начин докато тя все още присъства в списъка. Използвайте метода <code>Extract</code> за да извлечете инстанцията от него без да я освобождавате и по този начин да поемете отговорността за освобождаването й.</p>
</div>
<div class="paragraph">
<p>В <strong>Castle Game Engine</strong>: Наследниците на <code>TX3DNode</code> имат автоматично управление на заетата памет когато са вмъкнати като children на друг <code>TX3DNode</code>. Основният X3D възел, <code>TX3DRootNode</code>, на свой ред обикновено се притежава от <code>TCastleSceneCore</code>. Някои други обекти също имат прост механизъм за собственост - потърсете параметри и свойства, наречени <code>OwnsXxx</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_виртуалният_деструктор_destroy">5.4. Виртуалният деструктор Destroy</h3>
<div class="paragraph">
<p>Както видяхте в примерите по-горе, когато класът се унищожожава, се извиква неговият <code>деструктор</code>, наречен <code>Destroy</code>.</p>
</div>
<div class="paragraph">
<p>На теория можете да имате много деструктори, но на практика почти никога не е добра идея. Много по-лесно е да имате само един деструктор, наречен <code>Destroy</code>, който от своя страна се извиква от метода <code>Free</code>, той пък от своя страна се извиква от процедурата <code>FreeAndNil</code>.</p>
</div>
<div class="paragraph">
<p>Деструкторът <code>Destroy</code> в <code>TObject</code> е дефиниран като <em>виртуален</em> метод, така че винаги трябва да го маркирате с ключовата дума <code>override</code> във всички ваши класове (тъй като всички класове произлизат от <code>TObject</code>). Това е предпоставка за правилната работа на <code>Free</code>. Спомнете си как работят виртуалните методи от <a href="#virtual-methods-override-reintroduce">Виртуални методи, подмяна и скриване</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
<div class="paragraph">
<p>Тази информация за <em>деструкторите</em> не важи за <em>конструкторите</em>.</p>
</div>
<div class="paragraph">
<p>Нормално е един клас да има множество конструктори. Обикновено всички те се наричат <code>Create</code> и имат различни параметри, но не е неправилно да има и конструктори с други имена.</p>
</div>
<div class="paragraph">
<p>Освен това конструкторът <code>Create</code> в <code>TObject</code> <em>не е виртуален</em>, така че не го маркирайте с <code>override</code> в наследниците.</p>
</div>
<div class="paragraph">
<p>Това дава допълнителна гъвкавост при дефиниране на конструкторите. Често не е необходимо те да са виртуални, така че по подразбиране не сте принудени да го правите.</p>
</div>
<div class="paragraph">
<p>Имайте предвид обаче, че ситуацията е различна за наследниците на <code>TComponent</code>. <code>TComponent</code> дефинира виртуален конструктор <code>Create(AOwner: TComponent)</code> защото се нуждае от такъв, за да работи системата за сериализация. Когато наследявате <code>TComponent</code>, трябва да замените този конструктор (да го маркирате с ключовата дума <code>override</code>) и да извършите цялата си инициализация вътре в него. Дефинирането на допълнителни конструктори все пак е възможно, но те трябва да са само в ролята на <em>"помощни"</em>. Инстанцията трябва да работи винаги, когато е създадена с помощта <em>именно</em> на конструктора <code>Create(AOwner: TComponent)</code>, в противен случай тя няма да бъде правилно конструирана при сериализацията. <em>Сериализация</em> се използва например когато записвате и зареждате този компонент във форма на Lazarus.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_известие_при_освобождаване">5.5. Известие при освобождаване</h3>
<div class="paragraph">
<p>Ако копирате препратка към инстанция, така че да имате две препратки към една и съща памет, и след това едната от тях се освободи&#8201;&#8212;&#8201;другата се превръща във <em>"висящ указател"</em>. Тя не бива да се използва, тъй като сочи към памет, която вече не е заета. Достъпът до нея може да доведе до грешка по време на изпълнение или връщане на произволен "боклук" (тъй като паметта може да се използва повторно вече за други неща).</p>
</div>
<div class="paragraph">
<p>Използването на <code>FreeAndNil</code> тук вече не може да помогне. <code>FreeAndNil</code> записва <code>nil</code> само в препратката, която е получила&#8201;&#8212;&#8201;няма начин да нулира автоматично всички други препратки. Разгледайте следния код:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  Obj1, Obj2: TObject;
<span class="keyword">begin</span>
  Obj1 := TObject.Create;
  Obj2 := Obj1;
  FreeAndNil(Obj1);

  <span class="comment">// какво ще се случи ако достъпим тук Obj1 или Obj2?</span>
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>В края на този блок <code>Obj1</code> е <code>nil</code>. Ако някакъв код трябва да има достъп до него, той може надеждно да използва <code>if Obj1 &lt;&gt; nil then &#8230;&#8203;</code>, за да избегне извикване на методи на несъществуваща вече инстанция, като</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">if</span> Obj1 &lt;&gt; <span class="keyword">nil</span> <span class="keyword">then</span>
  WriteLn(Obj1.ClassName);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Опитът за достъп до поле на нулева инстанция води до предвидимо изключение по време на изпълнение. Така че дори ако някой код не провери <code>Obj1 &lt;&gt; nil</code> и сляпо се обърне към полето <code>Obj1</code>, ще се получи ясно изключение по време на изпълнение.</p>
</div>
<div class="paragraph">
<p>Същото важи и за извикване на виртуален или невиртуален метод, който се обръща към поле на <code>nil</code> инстанция.</p>
</div>
</li>
<li>
<p>С <code>Obj2</code>, нещата не са така предвидими. Той не е <code>nil</code>, но е невалиден. Опита за обръщение към поле на ненулева невалидна инстанция
ще предизвика непредвидимо поведение&#8201;&#8212;&#8201;може би ще предизвика изключение (exception), а може би ще върне безсмисленни данни.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Има различни решения на проблема:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Едно от решенията е да бъдете внимателни и да прочетете документацията. Не предполагайте нищо относно живота на инстанцията, ако е създадена от друг код. Ако клас <code>TCar</code> има поле, сочещо към някакъв екземпляр на <code>TWheel</code>, <em>конвенцията</em> е, че препратката към <em>wheel</em> е валидна, докато препратката към <em>car</em> съществува, и <em>car</em> ще освободи своите <em>wheels</em> в своя деструктор. Но това е само конвенция, документацията трябва да споменава, ако има нещо по-сложно.</p>
</li>
<li>
<p>В горния пример, веднага след освобождаването на екземпляра <code>Obj1</code>, можете просто да присвоите изрично <code>nil</code> на променливата <code>Obj2</code> . Това е тривиално в такива прости случаи.</p>
</li>
<li>
<p>Най-сигурното решение е да се използва механизма на клас <code>TComponent</code> за "известяване при освобождаване". Един компонент може да бъде известен, когато друг току-що е освободен и по този начин неговата референция да се направи равна на <code>nil</code>.</p>
<div class="paragraph">
<p>По този начин получавате нещо подобно на <em>слаба референция</em>. Тя може да се справи в различни сценарии, например можете да оставите кода извън класа да зададе вашата препратка, а външният код може също да освободи екземпляра по всяко време.</p>
</div>
<div class="paragraph">
<p>Това изисква и двата класа да са наследници на <code>TComponent</code>. Използването му като цяло се свежда до извикване на <code>FreeNotification</code>, <code>RemoveFreeNotification</code> и замяна на <code>Notification</code>.</p>
</div>
<div class="paragraph">
<p>Ето пълен пример, показващ как да използвате този механизъм, заедно с конструктор/деструктор и свойство за настройка със <em>setter</em>. Понякога може да се направи и по-просто, но това е пълната версия, която винаги е правилна :)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TControl = <span class="keyword">class</span>(TComponent)
  <span class="keyword">end</span>;

  TContainer = <span class="keyword">class</span>(TComponent)
  <span class="directive">private</span>
    FSomeSpecialControl: TControl;
    <span class="keyword">procedure</span> SetSomeSpecialControl(<span class="keyword">const</span> Value: TControl);
  <span class="directive">protected</span>
    <span class="keyword">procedure</span> Notification(AComponent: TComponent; Operation: TOperation); <span class="directive">override</span>;
  <span class="directive">public</span>
    <span class="keyword">destructor</span> Destroy; <span class="directive">override</span>;
    <span class="keyword">property</span> SomeSpecialControl: TControl
      <span class="directive">read</span> FSomeSpecialControl <span class="directive">write</span> SetSomeSpecialControl;
  <span class="keyword">end</span>;

<span class="keyword">implementation</span>

<span class="keyword">procedure</span> TContainer.Notification(AComponent: TComponent; Operation: TOperation);
<span class="keyword">begin</span>
  <span class="keyword">inherited</span>;
  <span class="keyword">if</span> (Operation = opRemove) <span class="keyword">and</span> (AComponent = FSomeSpecialControl) <span class="keyword">then</span>
    <span class="comment">{ set to nil by SetSomeSpecialControl to clean nicely }</span>
    SomeSpecialControl := <span class="keyword">nil</span>;
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TContainer.SetSomeSpecialControl(<span class="keyword">const</span> Value: TControl);
<span class="keyword">begin</span>
  <span class="keyword">if</span> FSomeSpecialControl &lt;&gt; Value <span class="keyword">then</span>
  <span class="keyword">begin</span>
    <span class="keyword">if</span> FSomeSpecialControl &lt;&gt; <span class="keyword">nil</span> <span class="keyword">then</span>
      FSomeSpecialControl.RemoveFreeNotification(Self);
    FSomeSpecialControl := Value;
    <span class="keyword">if</span> FSomeSpecialControl &lt;&gt; <span class="keyword">nil</span> <span class="keyword">then</span>
      FSomeSpecialControl.FreeNotification(Self);
  <span class="keyword">end</span>;
<span class="keyword">end</span>;

<span class="keyword">destructor</span> TContainer.Destroy;
<span class="keyword">begin</span>
  <span class="comment">{ set to nil by SetSomeSpecialControl, to detach free notification }</span>
  SomeSpecialControl := <span class="keyword">nil</span>;
  <span class="keyword">inherited</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_наблюдател_за_известие_при_освобождаване_castle_game_engine">5.6. Наблюдател за известие при освобождаване (Castle Game Engine)</h3>
<div class="paragraph">
<p>В <strong>Castle Game Engine</strong> препоръчваме да използвате <code>TFreeNotificationObserver</code> от модула <code>CastleClassUtils</code> вместо директно извикване на <code>FreeNotification</code>, <code>RemoveFreeNotification</code> и замяна на <code>Notification</code>.</p>
</div>
<div class="paragraph">
<p>Като цяло използването на <code>TFreeNotificationObserver</code> изглежда малко по-просто от използването на механизма <code>FreeNotification</code> директно (въпреки че признавам, че е въпрос на вкус). Но по-специално, когато <em>един и същи екземпляр на клас трябва да се наблюдава поради множество причини</em> тогава <code>TFreeNotificationObserver</code> е много по-прост за използване (директното използване на <code>FreeNotification</code> в този случай може да стане комплицирано, тъй като трябва да внимавате да не дерегистрирате известието твърде скоро) .</p>
</div>
<div class="paragraph">
<p>Това е примерният код, използващ <code>TFreeNotificationObserver</code>, за постигане на същия ефект като примера в предишния раздел:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TControl = <span class="keyword">class</span>(TComponent)
  <span class="keyword">end</span>;

  TContainer = <span class="keyword">class</span>(TComponent)
  <span class="directive">private</span>
    FSomeSpecialControlObserver: TFreeNotificationObserver;
    FSomeSpecialControl: TControl;
    <span class="keyword">procedure</span> SetSomeSpecialControl(<span class="keyword">const</span> Value: TControl);
    <span class="keyword">procedure</span> SomeSpecialControlFreeNotification(<span class="keyword">const</span> Sender: TFreeNotificationObserver);
  <span class="directive">public</span>
    <span class="keyword">constructor</span> Create(AOwner: TComponent); <span class="directive">override</span>;
    <span class="keyword">property</span> SomeSpecialControl: TControl
      <span class="directive">read</span> FSomeSpecialControl <span class="directive">write</span> SetSomeSpecialControl;
  <span class="keyword">end</span>;

<span class="keyword">implementation</span>

<span class="keyword">uses</span> CastleComponentSerialize;

<span class="keyword">constructor</span> TContainer.Create(AOwner: TComponent);
<span class="keyword">begin</span>
  <span class="keyword">inherited</span>;
  FSomeSpecialControlObserver := TFreeNotificationObserver.Create(Self);
  FSomeSpecialControlObserver.OnFreeNotification := <span class="preprocessor">{$ifdef FPC}</span>@<span class="preprocessor">{$endif}</span> SomeSpecialControlFreeNotification;
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TContainer.SetSomeSpecialControl(<span class="keyword">const</span> Value: TControl);
<span class="keyword">begin</span>
  <span class="keyword">if</span> FSomeSpecialControl &lt;&gt; Value <span class="keyword">then</span>
  <span class="keyword">begin</span>
    FSomeSpecialControl := Value;
    FSomeSpecialControlObserver.Observed := Value;
  <span class="keyword">end</span>;
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TContainer.SomeSpecialControlFreeNotification(<span class="keyword">const</span> Sender: TFreeNotificationObserver);
<span class="keyword">begin</span>
  <span class="comment">// set property to nil when the referenced component is freed</span>
  SomeSpecialControl := <span class="keyword">nil</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вижте <a href="https://castle-engine.io/custom_components" class="bare">https://castle-engine.io/custom_components</a> .</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Exceptions">6. Изключения</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_преглед">6.1. Преглед</h3>
<div class="paragraph">
<p>Изключенията позволяват <em>прекъсване на нормалния ход на изпълнение на кода</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Във всеки момент от програмата можете да <strong>предизвикате</strong> изключение, като използвате ключовата дума <code>raise</code>. На практика редовете код, следващи извикването <code>raise &#8230;&#8203;</code>, няма да се изпълнят.</p>
</li>
<li>
<p>Изключение може да бъде <strong>прихванато</strong> с помощта на конструкция <code>try &#8230;&#8203; except &#8230;&#8203; end</code>. Прихващането на изключение означава, че по някакъв начин ще се "справите" с изключението и следващият код трябва да се изпълни както обикновено, изключението повече няма да се разпространява нагоре.</p>
<div class="paragraph">
<p>Забележка: Ако бъде предизвикано изключение, но то никога не е уловено, това ще доведе до спиране на цялото приложение с грешка.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Но в LCL приложенията изключенията около събития (events) винаги се улавят (и извеждат в LCL диалогов прозорец), ако предварително не ги прихванете.</p>
</li>
<li>
<p>В <em>Castle Game Engine</em> приложения, използващи <code>CastleWindow</code>, изключенията около вашите събития винаги се прихващат по същия начин (и се показва правилния диалогов прозорец).</p>
</li>
<li>
<p>Така че не е толкова лесно да се предизвика изключение, което <em>не е прихванато никъде</em> (не е прихванато във вашия код, в LCL код, в CGE код&#8230;&#8203;).</p>
</li>
</ul>
</div>
</li>
<li>
<p>Въпреки че изключенията прекъсват изпълнението, можете да използвате конструкцията <code>try &#8230;&#8203; finally &#8230;&#8203; end</code>, за да изпълните някакъв код <strong>винаги</strong>, дори ако кодът е бил прекъснат от изключение.</p>
<div class="paragraph">
<p>Конструкцията <code>try &#8230;&#8203; finally &#8230;&#8203; end</code> също сработва, когато кодът е прекъснат от ключови думи <code>Break</code> или <code>Continue</code> или <code>Exit</code>. Въпросът е кода в секцията <code>finally</code> да се изпълнява наистина <em>винаги</em>.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Като цяло "изключение" може да бъде инстанция от всеки един клас.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Компилаторът не налага никой конкретен клас. Просто трябва да извикате <code>raise XXX</code>, където <code>XXX</code> е екземпляр от какъвто и да е клас (така че всичко, произлизащо от <code>TObject</code> става за целта).</p>
</li>
<li>
<p>Стандартна конвенция за класовете от изключения е те да наследяват специалния клас <code>Exception</code>. Класът <code>Exception</code> наследява <code>TObject</code>, като добавя свойството низ <code>Message</code> и конструктор за лесно задаване на това свойство. Всички изключения, предизвикани от стандартната библиотека, наследяват <code>Exception</code>. Съветваме ви да следвате тази конвенция.</p>
</li>
<li>
<p>Класовете с изключение (по конвенция) имат имена, които започват с <code>E</code>, не с <code>T</code>. Например <code>ESomethingBadHappened</code>.</p>
</li>
<li>
<p>Компилаторът автоматично ще освободи обекта-изключение, когато той бъде обработен. Не го освобождавайте сами.</p>
<div class="paragraph">
<p>В повечето случаи вие просто конструирате обекта по същото време, когато извиквате <code>raise</code>, например <code>raise ESomethingBadHappened.Create('Описание на случилото се лошо нещо.')</code>.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_предизвикване">6.2. Предизвикване</h3>
<div class="paragraph">
<p>Ако искате да предизвикате свое собствено изключение, декларирайте го и извикайте <code>raise &#8230;&#8203;</code>, когато е подходящо:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  EInvalidParameter = <span class="keyword">class</span>(Exception);

<span class="keyword">function</span> ReadParameter: <span class="keyword">String</span>;
<span class="keyword">begin</span>
  Result := Readln;
  <span class="keyword">if</span> Pos(<span class="char"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span>, Result) &lt;&gt; <span class="integer">0</span> <span class="keyword">then</span>
    <span class="keyword">raise</span> EInvalidParameter.Create(<span class="string"><span class="delimiter">'</span><span class="content">Invalid parameter, space is not allowed</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обърнете внимание, че изразът след <code>raise</code> трябва да бъде валиден екземпляр на клас. Почти винаги ще създавате екземпляра за изключение по време на предизвикването му.</p>
</div>
<div class="paragraph">
<p>Можете също да използвате конструктора <code>CreateFmt</code>, който е удобно съкращение на <code>Create(Format(MessageFormat, MessageArguments))</code>. Това е обичаен начин за предоставяне на повече информация в съобщението за изключение. Можем да подобрим предишния пример така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  EInvalidParameter = <span class="keyword">class</span>(Exception);

<span class="keyword">function</span> ReadParameter: <span class="keyword">String</span>;
<span class="keyword">begin</span>
  Result := Readln;
  <span class="keyword">if</span> Pos(<span class="char"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span>, Result) &lt;&gt; <span class="integer">0</span> <span class="keyword">then</span>
    <span class="keyword">raise</span> EInvalidParameter.CreateFmt(<span class="string"><span class="delimiter">'</span><span class="content">Невалиден параметър %s, не са позволени интервали.</span><span class="delimiter">'</span></span>, [Result]);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_прихващане">6.3. Прихващане</h3>
<div class="paragraph">
<p>Можете да прихванете изключение така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  Parameter1, Parameter2, Parameter3: <span class="keyword">String</span>;
<span class="keyword">begin</span>
  <span class="keyword">try</span>
    Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Въведете 1-ви параметър:</span><span class="delimiter">'</span></span>);
    Parameter1 := ReadParameter;
    Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Въведете 2-ри параметър:</span><span class="delimiter">'</span></span>);
    Parameter2 := ReadParameter;
    Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Въведете 3-ти параметър:</span><span class="delimiter">'</span></span>);
    Parameter3 := ReadParameter;
  <span class="keyword">except</span>
    <span class="comment">// прихващане на EInvalidParameter предизвикан от някое от извикванията на ReadParameter</span>
    <span class="directive">on</span> EInvalidParameter <span class="keyword">do</span>
      Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Възникна изключение EInvalidParameter</span><span class="delimiter">'</span></span>);
  <span class="keyword">end</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>За да подобрим горния пример, можем да декларираме име за инстанцията на изключение (ще използваме <code>E</code> в примера). По този начин можем да отпечатаме съобщението за грешка:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">try</span>
...
except
  <span class="directive">on</span> E: EInvalidParameter <span class="keyword">do</span>
    Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Възникна изключение EInvalidParameter със съобщение: </span><span class="delimiter">'</span></span> + E.Message);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Може също да се тества за множество изключения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">try</span>
...
except
  <span class="directive">on</span> E: EInvalidParameter <span class="keyword">do</span>
    Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Възникна изключение EInvalidParameter със съобщение: </span><span class="delimiter">'</span></span> + E.Message);
  <span class="directive">on</span> E: ESomeOtherException <span class="keyword">do</span>
    Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Възникна изключение ESomeOtherException със съобщение: </span><span class="delimiter">'</span></span> + E.Message);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Можете също така да отработите и произволно предизвикано изключение, ако не използвате никакъв израз <code>on</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">try</span>
...
except
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Предупреждение: Възникна изключение</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;
<span class="comment">// ПРЕДУПРЕЖДЕНИЕ: НЕ СЛЕДВАЙТЕ ПРИМЕРА БЕЗ ДА СТЕ ПРОЧЕЛИ ЗАБЕЛЕЖКАТА ПО-ДОЛУ</span>
<span class="comment">// ОТНОСНО &quot;ПРИХВАЩАНЕ НА ВСИЧКИ ИЗКЛЮЧЕНИЯ&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Като цяло <em>трябва да прихванете само изключения от определен клас, които сигнализират за определен проблем, с който знаете как да се справите</em>. Бъдете внимателни с прихващането на изключения от общ тип (като всяко <code>Exception</code> или всеки <code>TObject</code>), тъй като лесно можете да уловите прекалено много и по-късно да причините проблеми при отстраняване на други грешки. Както във всички езици за програмиране с изключения, доброто правило, което трябва да следвате, е <em>никога да не прихващате изключение, с което не знаете как да се справите</em>. По-специално, не прихващайте изключение само за да отстраните проблема, без първо да проучите <em>защо</em> възниква изключението.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Изключението показва ли проблем при въвеждането от потребителя? Тогава трябва да го докладвате на потребителя.</p>
</li>
<li>
<p>Изключението показва ли грешка във вашия код? Тогава трябва да поправите кода, за да не се случва повече изключението.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Друг начин да прихванете всички изключения е да използвате:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">try</span>
...
except
  <span class="directive">on</span> E: TObject <span class="keyword">do</span>
    Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Предупреждение: Възникна изключение</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;
<span class="comment">// ПРЕДУПРЕЖДЕНИЕ: НЕ СЛЕДВАЙТЕ ПРИМЕРА БЕЗ ДА СТЕ ПРОЧЕЛИ ЗАБЕЛЕЖКАТА ПО-ГОРЕ</span>
<span class="comment">// ОТНОСНО &quot;ПРИХВАЩАНЕ НА ВСИЧКИ ИЗКЛЮЧЕНИЯ&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Въпреки че обикновено е достатъчно да се прихване само <code>Exception</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">try</span>
...
except
  <span class="directive">on</span> E: Exception <span class="keyword">do</span>
    Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Предупреждение: Възникна изключение: </span><span class="delimiter">'</span></span> + E.ClassName + <span class="string"><span class="delimiter">'</span><span class="content">, съобщение: </span><span class="delimiter">'</span></span> + E.Message);
<span class="keyword">end</span>;
<span class="comment">// ПРЕДУПРЕЖДЕНИЕ: НЕ СЛЕДВАЙТЕ ПРИМЕРА БЕЗ ДА СТЕ ПРОЧЕЛИ ЗАБЕЛЕЖКАТА ПО-ГОРЕ</span>
<span class="comment">// ОТНОСНО &quot;ПРИХВАЩАНЕ НА ВСИЧКИ ИЗКЛЮЧЕНИЯ&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Можете да "предизвикате отново" изключението в блока <code>except &#8230;&#8203; end</code>, ако е необходимо. Можете да извикате <code>raise E;</code>, ако инстанцията е <code>E</code>, можете също така просто да използвате <code>raise</code> без параметър. Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">try</span>
...
except
  <span class="directive">on</span> E: EInvalidSoundFile <span class="keyword">do</span>
  <span class="keyword">begin</span>
    <span class="keyword">if</span> E.InvalidUrl = <span class="string"><span class="delimiter">'</span><span class="content">http://example.com/blablah.wav</span><span class="delimiter">'</span></span> <span class="keyword">then</span>
      Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Предупреждение: зареждането на http://example.com/blablah.wav се провали, игнорирайте го</span><span class="delimiter">'</span></span>)
    <span class="keyword">else</span>
      <span class="keyword">raise</span>;
  <span class="keyword">end</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Имайте предвид, че въпреки че изключението е екземпляр на обект, никога не бива да го освобождавате ръчно. Компилаторът ще генерира подходящ код, който гарантира освобождаването след като бъде обработен.</p>
</div>
</div>
<div class="sect2">
<h3 id="_finally_изпълнение_на_код_независимо_дали_има_изключение">6.4. Finally (изпълнение на код независимо дали има изключение)</h3>
<div class="paragraph">
<p>Често се използва конструкцията <code>try .. finally .. end</code>, за освобождаване на екземпляр от някакъв клас, независимо дали е възникнало изключение при използването му. Начинът за използване е следния:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">procedure</span> MyProcedure;
<span class="keyword">var</span>
  MyInstance: TMyClass;
<span class="keyword">begin</span>
  MyInstance := TMyClass.Create;
  <span class="keyword">try</span>
    MyInstance.DoSomething;
    MyInstance.DoSomethingElse;
  <span class="keyword">finally</span>
    FreeAndNil(MyInstance);
  <span class="keyword">end</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Това работи надеждно винаги и не причинява изтичане на памет, дори ако <code>MyInstance.DoSomething</code> или <code>MyInstance.DoSomethingElse</code> предизвикат изключение.</p>
</div>
<div class="paragraph">
<p>Обърнете внимание, че това взема предвид, че локалните променливи, като <code>MyInstance</code> по-горе, имат недефинирани стойности (може да съдържат случаен "боклук в паметта") преди първото присвояване. Тоест, писането на нещо подобно <em>не</em> би било вярно:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="comment">// НЕКОРЕКТЕН ПРИМЕР:</span>
<span class="keyword">procedure</span> MyProcedure;
<span class="keyword">var</span>
  MyInstance: TMyClass;
<span class="keyword">begin</span>
  <span class="keyword">try</span>
    CallSomeOtherProcedure;
    MyInstance := TMyClass.Create;
    MyInstance.DoSomething;
    MyInstance.DoSomethingElse;
  <span class="keyword">finally</span>
    FreeAndNil(MyInstance);
  <span class="keyword">end</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Горният пример е грешен: ако възникне изключение в <code>TMyClass.Create</code> (конструктора може също да предизвика изключение) или в рамките на <code>CallSomeOtherProcedure</code>, тогава променливата <code>MyInstance</code> не се инициализира. Извикването на <code>FreeAndNil(MyInstance)</code> ще се опита да извика деструктора на <code>MyInstance</code>, което най-вероятно ще се срине с <em>Access Violation (Segmentation Fault)</em>. Всъщност едно изключение ще причини друго изключение, което ще направи съобщението за грешка безполезно: няма да видите съобщението на първото изключение.</p>
</div>
<div class="paragraph">
<p>Понякога е оправдано да поправите горния код, като първо инициализирате всички локални променливи на <code>nil</code> (тогава извикването на <code>FreeAndNil</code> е безопасно). Това има смисъл, ако освождавате <strong>много</strong> екземпляри на класове. Така че двата примера по-долу работят еднакво добре:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">procedure</span> MyProcedure;
<span class="keyword">var</span>
  MyInstance1: TMyClass1;
  MyInstance2: TMyClass2;
  MyInstance3: TMyClass3;
<span class="keyword">begin</span>
  MyInstance1 := TMyClass1.Create;
  <span class="keyword">try</span>
    MyInstance1.DoSomething;

    MyInstance2 := TMyClass2.Create;
    <span class="keyword">try</span>
      MyInstance2.DoSomethingElse;

      MyInstance3 := TMyClass3.Create;
      <span class="keyword">try</span>
        MyInstance3.DoYetAnotherThing;
      <span class="keyword">finally</span>
        FreeAndNil(MyInstance3);
      <span class="keyword">end</span>;
    <span class="keyword">finally</span>
      FreeAndNil(MyInstance2);
    <span class="keyword">end</span>;
  <span class="keyword">finally</span>
    FreeAndNil(MyInstance1);
  <span class="keyword">end</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вероятно това е по-четливо във вида по-долу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">procedure</span> MyProcedure;
<span class="keyword">var</span>
  MyInstance1: TMyClass1;
  MyInstance2: TMyClass2;
  MyInstance3: TMyClass3;
<span class="keyword">begin</span>
  MyInstance1 := <span class="keyword">nil</span>;
  MyInstance2 := <span class="keyword">nil</span>;
  MyInstance3 := <span class="keyword">nil</span>;
  <span class="keyword">try</span>
    MyInstance1 := TMyClass1.Create;
    MyInstance1.DoSomething;

    MyInstance2 := TMyClass2.Create;
    MyInstance2.DoSomethingElse;

    MyInstance3 := TMyClass3.Create;
    MyInstance3.DoYetAnotherThing;
  <span class="keyword">finally</span>
    FreeAndNil(MyInstance3);
    FreeAndNil(MyInstance2);
    FreeAndNil(MyInstance1);
  <span class="keyword">end</span>;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
В този прост пример можете да направите правилния довод, че кодът би трябвало да се раздели на 3 отделни процедури, като едната извиква всяка от другите две.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_как_изключенията_се_показват_от_различните_библиотеки">6.5. Как изключенията се показват от различните библиотеки</h3>
<div class="ulist">
<ul>
<li>
<p>В случая на Lazarus LCL, изключенията, предизвикани по време на събития (различни обратни извиквания, <em>callbacks</em>, присвоени на свойствата на <code>OnXxx</code> в LCL компонентите) ще бъдат прихванати и ще доведат до диалогово съобщение, което позволява на потребителя да продължи или да спре приложението. Това означава, че вашите собствени изключения не "излизат" от <code>Application.ProcessMessages</code>, така че те не прекъсват директно приложението. Можете да конфигурирате какво точно да се случи с помощта на <code>TApplicationProperties.OnException</code>.</p>
</li>
<li>
<p>По същия начин, в <em>Castle Game Engine</em> с <code>CastleWindow</code>: изключението се прихваща вътрешно и води до съобщение за грешка. Така изключенията не "излизат" от <code>Application.ProcessMessages</code>. Отново можете да конфигурирате какво да се случва с помощта на <code>Application.OnException</code>.</p>
</li>
<li>
<p>Други GUI библиотеки може да направят нещо подобно на горното.</p>
</li>
<li>
<p>В случай на други приложения, можете да конфигурирате как се показва изключението, като присвоите глобален <em>callback</em> на <code>OnHaltProgram</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_run_time_библиотека">7. Run-time библиотека</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_входизход_с_помощта_на_потоци">7.1. Вход/изход с помощта на потоци</h3>
<div class="paragraph">
<p>Съвременните програми на Паскал трябва да използват класа <code>TStream</code> и неговите наследници за да извършват входно/изходни операции. Много полезни класове наследяват <code>TStream</code>, например: <code>TFileStream</code>, <code>TMemoryStream</code>, <code>TStringStream</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils, Classes;

<span class="keyword">var</span>
  S: TStream;
  InputInt, OutputInt: Integer;
<span class="keyword">begin</span>
  InputInt := <span class="integer">666</span>;

  S := TFileStream.Create(<span class="string"><span class="delimiter">'</span><span class="content">my_binary_file.data</span><span class="delimiter">'</span></span>, fmCreate);
  <span class="keyword">try</span>
    S.WriteBuffer(InputInt, SizeOf(InputInt));
  <span class="keyword">finally</span>
    FreeAndNil(S);
  <span class="keyword">end</span>;

  S := TFileStream.Create(<span class="string"><span class="delimiter">'</span><span class="content">my_binary_file.data</span><span class="delimiter">'</span></span>, fmOpenRead);
  <span class="keyword">try</span>
    S.ReadBuffer(OutputInt, SizeOf(OutputInt));
  <span class="keyword">finally</span>
    FreeAndNil(S);
  <span class="keyword">end</span>;

  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Read from file got integer: </span><span class="delimiter">'</span></span>, OutputInt);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>В <strong>Castle Game Engine</strong>: Трябва да използвате функцията <code>Download</code> за създаването на поток, който получава данни от произволен URL адрес. По този начин се поддържат обикновени файлове, HTTP и HTTPS ресурси, Android assets и други. Освен това, за да отворите ресурс във вашите данни за играта (в поддиректорията <code>data</code>), използвайте специалния URL адрес <code>castle-data:/xxx</code>. Примери:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">EnableNetwork := true;
S := Download(<span class="string"><span class="delimiter">'</span><span class="content">https://castle-engine.io/latest.zip</span><span class="delimiter">'</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">S := Download(<span class="string"><span class="delimiter">'</span><span class="content">file:///home/michalis/my_binary_file.data</span><span class="delimiter">'</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">S := Download(<span class="string"><span class="delimiter">'</span><span class="content">castle-data:/gui/my_image.png</span><span class="delimiter">'</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>За да четете текстови файлове, препоръчваме да използвате класа <code>TTextReader</code>. Той предоставя поредово API и съдържа в себе си <code>TStream</code>. Конструкторът <code>TTextReader</code> може да вземе готов URL адрес или вие можете да подадете там вашия персонализиран източник <code>TStream</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">Text := TTextReader.Create(<span class="string"><span class="delimiter">'</span><span class="content">castle-data:/my_data.txt</span><span class="delimiter">'</span></span>);
<span class="keyword">try</span>
  <span class="keyword">while</span> <span class="keyword">not</span> Text.Eof <span class="keyword">do</span>
    WriteLnLog(<span class="string"><span class="delimiter">'</span><span class="content">NextLine</span><span class="delimiter">'</span></span>, Text.ReadLn);
<span class="keyword">finally</span>
  FreeAndNil(Text);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="generic-containers-section">7.2. Контейнери (списъци, речници), използващи генерици</h3>
<div class="paragraph">
<p>Езикът и run-time библиотеката предлагат различни гъвкави контейнери. Има редица "негенерични" класове (като <code>TList</code> и <code>TObjectList</code> от модула <code>Contnrs</code>), има и динамични масиви (<code>array of TMyType</code>). Но за да получите най-голяма гъвкавост <strong>и</strong> безопасност, съветвам за повечето от вашите нужди да използвате <strong>генерични контейнери</strong>.</p>
</div>
<div class="paragraph">
<p><em>Генеричните контейнери</em> ви дават много полезни методи за добавяне, премахване, обхождане, търсене, сортиране&#8230;&#8203; Компилаторът също така знае (и проверява), че контейнерът съдържа единствено елементи от указания тип.</p>
</div>
<div class="paragraph">
<p>В момента има три библиотеки, предоставящи генерични контейнери в FPC:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Модул <code>Generics.Collections</code> (от FPC &gt;= 3.2.0)</p>
</li>
<li>
<p>Модул <code>FGL</code></p>
</li>
<li>
<p>Модул <code>GVector</code> (включен в <code>fcl-stl</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Съветваме да се използва модул <code>Generics.Collections</code>. Генеричните контейнери реализирани там са:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>пакетирани с полезни функции,</p>
</li>
<li>
<p>много ефективни (особено важно при достъп до речници<sup class="footnote" id="_footnote_dictionary">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup> с помощта на ключове),</p>
</li>
<li>
<p>съвместими между FPC и Delphi,</p>
</li>
<li>
<p>именуването е в съответствие с другите части на стандартната библиотека (като негенеричните контейнери от модула <code>Contnrs</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В <strong>Castle Game Engine</strong>: Ние използваме интензивно <code>Generics.Collections</code> и съветваме да използвате <code>Generics.Collections</code> и във вашите приложения!</p>
</div>
<div class="paragraph">
<p>Най-важните класове от <code>Generics.Collections</code> са:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">TList</dt>
<dd>
<p>Генеричен списък от елементи от указан тип.</p>
</dd>
<dt class="hdlist1">TObjectList</dt>
<dd>
<p>Генеричен списък от екземпляри от указан клас. Може да "притежава" екземплярите, което означава че ще ги унищожи автоматично при унищожаване на списъка.</p>
</dd>
<dt class="hdlist1">TDictionary</dt>
<dd>
<p>Генеричен речник<sup class="footnoteref">[<a class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup>.</p>
</dd>
<dt class="hdlist1">TObjectDictionary</dt>
<dd>
<p>Генеричен речник, Може да "притежава" ключовете и/или стойностите.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Ето как да използвате прост генеричен <code>TObjectList</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span> SysUtils, Generics.Collections;

<span class="keyword">type</span>
  TApple = <span class="keyword">class</span>
    Name: <span class="keyword">string</span>;
  <span class="keyword">end</span>;

  TAppleList = specialize TObjectList&lt;TApple&gt;;

<span class="keyword">var</span>
  A: TApple;
  Apples: TAppleList;
<span class="keyword">begin</span>
  Apples := TAppleList.Create(true);
  <span class="keyword">try</span>
    A := TApple.Create;
    A.Name := <span class="string"><span class="delimiter">'</span><span class="content">my apple</span><span class="delimiter">'</span></span>;
    Apples.Add(A);

    A := TApple.Create;
    A.Name := <span class="string"><span class="delimiter">'</span><span class="content">another apple</span><span class="delimiter">'</span></span>;
    Apples.Add(A);

    Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Count: </span><span class="delimiter">'</span></span>, Apples.Count);
    Writeln(Apples[<span class="integer">0</span>].Name);
    Writeln(Apples[<span class="integer">1</span>].Name);
  <span class="keyword">finally</span> FreeAndNil(Apples) <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обърнете внимание, че някои операции изискват сравняване на два елемента, като сортиране и търсене (напр. чрез методите <code>Sort</code> и <code>IndexOf</code>). Контейнерите в <code>Generics.Collections</code> използват за това <em>сравнител</em>. <em>Подразбиращия се сравнител</em> е смислен за всички типове, дори за записи (в дадения случай сравнява съдържанието на паметта, което е разумна настройка по подразбиране поне за търсене чрез <code>IndexOf</code>).</p>
</div>
<div class="paragraph">
<p>Когато сортирате списък, можете да укажете <em>персонализиран сравнител</em> като параметър. <em>Сравнителя</em> е клас, реализиращ интерфейса <code>IComparer</code>. На практика обикновено дефинирате подходящ <em>callback</em> и използвате метода <code>TComparer&lt;T&gt;.Construct</code>, за да пакетирате този <em>callback</em> в екземпляр на <code>IComparer</code>. Пример за това е по-долу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>

<span class="comment">{ If GENERICS_CONSTREF is defined, then various routines used with Generics.Collections
  (like callbacks we pass to TComparer, or OnNotify callback or Notify virtual method)
  should have &quot;constref&quot; parameter, not &quot;const&quot;.
  This was the case of FPC&lt;= 3.2.0, FPC changed it in
  https://gitlab.com/freepascal.org/fpc/source/-/commit/693491048bf2c6f9122a0d8b044ad0e55382354d .
  It is also applied to FPC fixes branch 3.2.3. }</span>
<span class="preprocessor">{$ifdef VER3_0}</span> <span class="preprocessor">{$define GENERICS_CONSTREF}</span> <span class="preprocessor">{$endif}</span>
<span class="preprocessor">{$ifdef VER3_2_0}</span> <span class="preprocessor">{$define GENERICS_CONSTREF}</span> <span class="preprocessor">{$endif}</span>
<span class="preprocessor">{$ifdef VER3_2_2}</span> <span class="preprocessor">{$define GENERICS_CONSTREF}</span> <span class="preprocessor">{$endif}</span>

<span class="keyword">uses</span> SysUtils, Generics.Defaults, Generics.Collections;

<span class="keyword">type</span>
  TApple = <span class="keyword">class</span>
    Name: <span class="keyword">string</span>;
  <span class="keyword">end</span>;

  TAppleList = specialize TObjectList&lt;TApple&gt;;

<span class="keyword">function</span> CompareApples(
  <span class="preprocessor">{$ifdef GENERICS_CONSTREF}</span>constref<span class="preprocessor">{$else}</span><span class="keyword">const</span><span class="preprocessor">{$endif}</span>
  Left, Right: TApple): Integer;
<span class="keyword">begin</span>
  Result := AnsiCompareStr(Left.Name, Right.Name);
<span class="keyword">end</span>;

<span class="keyword">type</span>
  TAppleComparer = specialize TComparer&lt;TApple&gt;;
<span class="keyword">var</span>
  A: TApple;
  L: TAppleList;
<span class="keyword">begin</span>
  L := TAppleList.Create(true);
  <span class="keyword">try</span>
    A := TApple.Create;
    A.Name := <span class="string"><span class="delimiter">'</span><span class="content">11</span><span class="delimiter">'</span></span>;
    L.Add(A);

    A := TApple.Create;
    A.Name := <span class="string"><span class="delimiter">'</span><span class="content">33</span><span class="delimiter">'</span></span>;
    L.Add(A);

    A := TApple.Create;
    A.Name := <span class="string"><span class="delimiter">'</span><span class="content">22</span><span class="delimiter">'</span></span>;
    L.Add(A);

    L.Sort(TAppleComparer.Construct(@CompareApples));

    Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Count: </span><span class="delimiter">'</span></span>, L.Count);
    Writeln(L[<span class="integer">0</span>].Name);
    Writeln(L[<span class="integer">1</span>].Name);
    Writeln(L[<span class="integer">2</span>].Name);
  <span class="keyword">finally</span> FreeAndNil(L) <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Класът <code>TDictionary</code> реализира <strong>речник</strong>, познат като <strong>map (key &#8594; value)</strong>, също познат като <strong>associative array</strong>. Неговото API е подобно на <code>TDictionary</code> в C#. Има полезни итератори за ключове, стойности и двойки ключ&#8594;стойност.</p>
</div>
<div class="paragraph">
<p>Примерен код, използващ речник:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span> SysUtils, Generics.Collections;

<span class="keyword">type</span>
  TApple = <span class="keyword">class</span>
    Name: <span class="keyword">string</span>;
  <span class="keyword">end</span>;

  TAppleDictionary = specialize TDictionary&lt;<span class="keyword">string</span>, TApple&gt;;

<span class="keyword">var</span>
  Apples: TAppleDictionary;
  A, FoundA: TApple;
  ApplePair: TAppleDictionary.TDictionaryPair;
  AppleKey: <span class="keyword">string</span>;
<span class="keyword">begin</span>
  Apples := TAppleDictionary.Create;
  <span class="keyword">try</span>
    A := TApple.Create;
    A.Name := <span class="string"><span class="delimiter">'</span><span class="content">моята ябълка</span><span class="delimiter">'</span></span>;
    Apples.AddOrSetValue(<span class="string"><span class="delimiter">'</span><span class="content">ключ за ябълка 1</span><span class="delimiter">'</span></span>, A);

    <span class="keyword">if</span> Apples.TryGetValue(<span class="string"><span class="delimiter">'</span><span class="content">ключ за ябълка 1</span><span class="delimiter">'</span></span>, FoundA) <span class="keyword">then</span>
      Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Намерена ябълка с ключ &quot;ключ за ябълка 1&quot; с име: </span><span class="delimiter">'</span></span> +
        FoundA.Name);

    <span class="keyword">for</span> AppleKey <span class="keyword">in</span> Apples.Keys <span class="keyword">do</span>
      Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Намерен ключ за ябълка: </span><span class="delimiter">'</span></span> + AppleKey);
    <span class="keyword">for</span> A <span class="keyword">in</span> Apples.Values <span class="keyword">do</span>
      Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Намерена ябълка с име: </span><span class="delimiter">'</span></span> + A.Name);
    <span class="keyword">for</span> ApplePair <span class="keyword">in</span> Apples <span class="keyword">do</span>
      Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Намерен ключ за ябълка-&gt;име на ябълка: </span><span class="delimiter">'</span></span> +
        ApplePair.Key + <span class="string"><span class="delimiter">'</span><span class="content">-&gt;</span><span class="delimiter">'</span></span> + ApplePair.Value.Name);

    <span class="comment">{ Долният ред също работи, но може да се използва само да 
      зададе стойност на *съществуващ* ключ в речника.
      Вместо това обикновено се използва AddOrSetValue
      за да се зададе или добави нов ключ ако е необходимо. }</span>
    <span class="comment">// Apples['ключ за ябълка 1'] := ... ;</span>

    Apples.Remove(<span class="string"><span class="delimiter">'</span><span class="content">ключ за ябълка 1</span><span class="delimiter">'</span></span>);

    <span class="comment">{ Забележете, че TDictionary не притежава елементите си
      и трябва да ги освобожавате ръчно.
      Може да използвате TObjectDictionary за да имате автоматичен
      режим за притежание. }</span>
    A.Free;
  <span class="keyword">finally</span> FreeAndNil(Apples) <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TObjectDictionary</code> може да <em>притежава</em> ключовете и/или стойностите, което означава че ще ги унищожава автоматично. Внимавайте <em>това притежание да бъде само когато ключовете/стойностите са екземпляри на обекти</em>. Ако укажете, че ще се притежават елементи от друг тип, например <code>Integer</code> (т.е. ако ключовете са <code>Integer</code>, и включите <code>doOwnsKeys</code>), ще получите много неприятен срив при изпълнение на програмата.</p>
</div>
<div class="paragraph">
<p>Пример за това как се използва <code>TObjectDictionary</code> е даден по-долу. Компилирайте примера с <em>memory leak detection</em>, напр. така <code>fpc -gl -gh generics_object_dictionary.lpr</code>, за да видите, че няма изтичане на памет при приключване на програмата.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span> SysUtils, Generics.Collections;

<span class="keyword">type</span>
  TApple = <span class="keyword">class</span>
    Name: <span class="keyword">string</span>;
  <span class="keyword">end</span>;

  TAppleDictionary = specialize TObjectDictionary&lt;<span class="keyword">string</span>, TApple&gt;;

<span class="keyword">var</span>
  Apples: TAppleDictionary;
  A: TApple;
  ApplePair: TAppleDictionary.TDictionaryPair;
<span class="keyword">begin</span>
  Apples := TAppleDictionary.Create([doOwnsValues]);
  <span class="keyword">try</span>
    A := TApple.Create;
    A.Name := <span class="string"><span class="delimiter">'</span><span class="content">my apple</span><span class="delimiter">'</span></span>;
    Apples.AddOrSetValue(<span class="string"><span class="delimiter">'</span><span class="content">apple key 1</span><span class="delimiter">'</span></span>, A);

    <span class="keyword">for</span> ApplePair <span class="keyword">in</span> Apples <span class="keyword">do</span>
      Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Found apple key-&gt;value: </span><span class="delimiter">'</span></span> +
        ApplePair.Key + <span class="string"><span class="delimiter">'</span><span class="content">-&gt;</span><span class="delimiter">'</span></span> + ApplePair.Value.Name);

    Apples.Remove(<span class="string"><span class="delimiter">'</span><span class="content">apple key 1</span><span class="delimiter">'</span></span>);
  <span class="keyword">finally</span> FreeAndNil(Apples) <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако предпочитате да използвате модула <code>FGL</code> вместо <code>Generics.Collections</code>, най-важните класове от <code>FGL</code> са:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">TFPGList</dt>
<dd>
<p>Генеричен списък от елементи от указан тип.</p>
</dd>
<dt class="hdlist1">TFPGObjectList</dt>
<dd>
<p>Генеричен списък от екземпляри от указан клас. Може да "притежава" екземплярите.</p>
</dd>
<dt class="hdlist1">TFPGMap</dt>
<dd>
<p>Генеричен речник<sup class="footnoteref">[<a class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>В модул <code>FGL</code>, <code>TFPGList</code> може да се използва само с типове, които имат дефиниран оператор за равенство (=). При <code>TFPGMap</code> за типа на ключа трябват дефинирани оператори <em>"по-голямо"</em> (&gt;) и <em>"по-малко"</em> (&lt;). Ако искате да използвате тези контейнери с типове, които нямат дефинирани оператори за сравнение (например записи), ще трябва да им дефинирате съответните оператори както е показано в <a href="#_замяна_на_оператори">Замяна на оператори</a>.</p>
</div>
<div class="paragraph">
<p>В <strong>Castle Game Engine</strong> сме включили модул <code>CastleGenericLists</code>, който добавя класовете <code>TGenericStructList</code> и <code>TGenericStructMap</code>. Те са подобни на <code>TFPGList</code> и <code>TFPGMap</code>, но не изискват дефиниране на оператори за сравнение за съответните типове (вместо това, те сравняват съдържанието на паметта, което е често подходящо за записи или указатели). Но от версия 6.3 модула <code>CastleGenericLists</code> е маркиран като отживял (<em>deprecated</em>) и препоръчваме използването на <code>Generics.Collections</code> вместо него.</p>
</div>
<div class="paragraph">
<p>Ако искате да научите повече за генериците, вижте <a href="#Generics">Генерици</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_клониране_tpersistent_assign">7.3. Клониране: TPersistent.Assign</h3>
<div class="paragraph">
<p>Копирането на екземплярите на клас чрез прост оператор за присвояване <code>:=</code> копира единствено <strong>препратката</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  X, Y: TMyObject;
<span class="keyword">begin</span>
  X := TMyObject.Create;
  Y := X;
  <span class="comment">// X и Y сега са два указателя към една и съща инстанция</span>
  Y.MyField := <span class="integer">123</span>; <span class="comment">// ще се промени също и X.MyField</span>
  FreeAndNil(X);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>За да копирате <strong>съдържанието на екземпляр</strong> от някакъв клас, стандартния подход е да наследите класа от <code>TPersistent</code>, и да подмените неговия метод <code>Assign</code>. След като той бъде коректно написан за <code>TMyObject</code>, той може да се използва по следния начин:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">var</span>
  X, Y: TMyObject;
<span class="keyword">begin</span>
  X := TMyObject.Create;
  Y := TMyObject.Create;
  Y.Assign(X);
  Y.MyField := <span class="integer">123</span>; <span class="comment">// това не променя X.MyField</span>
  FreeAndNil(X);
  FreeAndNil(Y);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>За да работи правилно, кодът в тялото на метода <code>Assign</code> трябва да копира стойностите на необходимите полета. Трябва внимателно да кодирате <code>Assign</code>, за да копирате от класове, който може да са наследници на текущия клас.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils, Classes;

<span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>(TPersistent)
  <span class="directive">public</span>
    MyInt: Integer;
    <span class="keyword">procedure</span> Assign(Source: TPersistent); <span class="directive">override</span>;
  <span class="keyword">end</span>;

  TMyClassDescendant = <span class="keyword">class</span>(TMyClass)
  <span class="directive">public</span>
    MyString: <span class="keyword">string</span>;
    <span class="keyword">procedure</span> Assign(Source: TPersistent); <span class="directive">override</span>;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.Assign(Source: TPersistent);
<span class="keyword">var</span>
  SourceMyClass: TMyClass;
<span class="keyword">begin</span>
  <span class="keyword">if</span> Source <span class="keyword">is</span> TMyClass <span class="keyword">then</span>
  <span class="keyword">begin</span>
    SourceMyClass := TMyClass(Source);
    MyInt := SourceMyClass.MyInt;
    <span class="comment">// Xxx := SourceMyClass.Xxx; // копирайте още полета ако е необходимо ...</span>
  <span class="keyword">end</span> <span class="keyword">else</span>
    <span class="comment">{ Поради това, че TMyClass е директен наследник на TPersistent,
      той извиква inherited САМО когато не знае как да обработи Source.
      Виж кометарите по-долу. }</span>
    <span class="keyword">inherited</span> Assign(Source);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClassDescendant.Assign(Source: TPersistent);
<span class="keyword">var</span>
  SourceMyClassDescendant: TMyClassDescendant;
<span class="keyword">begin</span>
  <span class="keyword">if</span> Source <span class="keyword">is</span> TMyClassDescendant <span class="keyword">then</span>
  <span class="keyword">begin</span>
    SourceMyClassDescendant := TMyClassDescendant(Source);
    MyString := SourceMyClassDescendant.MyString;
    <span class="comment">// Xxx := SourceMyClassDescendant.Xxx; // копирайте още полета ако е необходимо ...</span>
  <span class="keyword">end</span>;

  <span class="comment">{ Поради това, че TMyClassDescendant има предшественик, който вече е 
    заменил Assign (in TMyClass.Assign), той извиква inherited ВИНАГИ,
    за да позволи TMyClass.Assign да копира останалите полета.
    Виж кометарите по-долу за детайлно обяснение. }</span>
  <span class="keyword">inherited</span> Assign(Source);
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C1, C2: TMyClass;
  CD1, CD2: TMyClassDescendant;
<span class="keyword">begin</span>
  <span class="comment">// тест TMyClass.Assign</span>
  C1 := TMyClass.Create;
  C2 := TMyClass.Create;
  <span class="keyword">try</span>
    C1.MyInt := <span class="integer">666</span>;
    C2.Assign(C1);
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">C2 state: </span><span class="delimiter">'</span></span>, C2.MyInt);
  <span class="keyword">finally</span>
    FreeAndNil(C1);
    FreeAndNil(C2);
  <span class="keyword">end</span>;

  <span class="comment">// тест TMyClassDescendant.Assign</span>
  CD1 := TMyClassDescendant.Create;
  CD2 := TMyClassDescendant.Create;
  <span class="keyword">try</span>
    CD1.MyInt := <span class="integer">44</span>;
    CD1.MyString := <span class="string"><span class="delimiter">'</span><span class="content">blah</span><span class="delimiter">'</span></span>;
    CD2.Assign(CD1);
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">CD2 state: </span><span class="delimiter">'</span></span>, CD2.MyInt, <span class="char"><span class="delimiter">'</span><span class="content"> </span><span class="delimiter">'</span></span>, CD2.MyString);
  <span class="keyword">finally</span>
    FreeAndNil(CD1);
    FreeAndNil(CD2);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Понякога е по-удобно да замените метода <code>AssignTo</code> в класa източник, вместо да замените метода <code>Assign</code> в класa, на който се присвоява.</p>
</div>
<div class="paragraph">
<p>Бъдете внимателни, когато извиквате <code>inherited</code> в подменения <code>Assign</code>. Има две ситуации:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Вашият клас е пряк наследник на класа <code>TPersistent</code>. (Или не е пряк наследник на <code>TPersistent</code>, но нито един предшественик не е заменил метода <code>Assign</code>.)</dt>
<dd>
<p>В този случай вашият клас трябва да използва ключовата дума <code>inherited</code> (за извикване на <code>TPersistent.Assign</code>) <em>само ако не можете да се справите с присвояването във вашия код</em>.</p>
</dd>
<dt class="hdlist1">Вашият клас произлиза от клас, който вече е заменил метода <code>Assign</code>.</dt>
<dd>
<p>В този случай вашият клас трябва <em>винаги</em> да използва ключовата дума <code>inherited</code> (за да извика наследения <code>Assign</code>). Като цяло извикването на <code>inherited</code> в подменени методи <em>обикновено</em> е добра идея.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>За да разберете причината зад горното правило (кога трябва и кога <em>не трябва</em> да извикате <code>inherited</code> от имплементацията <code>Assign</code>) и как това е свързано с метода <code>AssignTo</code>, нека да разгледаме <code>TPersistent.Assign</code> и <code>TPersistent.AssignTo</code> реализации:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">procedure</span> TPersistent.Assign(Source: TPersistent);
<span class="keyword">begin</span>
  <span class="keyword">if</span> Source &lt;&gt; <span class="keyword">nil</span> <span class="keyword">then</span>
    Source.AssignTo(Self)
  <span class="keyword">else</span>
    <span class="keyword">raise</span> EConvertError...
end;

<span class="keyword">procedure</span> TPersistent.AssignTo(Destination: TPersistent);
<span class="keyword">begin</span>
  <span class="keyword">raise</span> EConvertError...
end;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
Това не е <strong>точната</strong> реализация в <code>TPersistent</code>. Копиран е кода на стандартната FPC библиотека, но след това е опростен, за да се скрият маловажни подробности относно съобщението за изключение.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Изводите, които можете да направите от горното са:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Ако нито <code>Assign</code>, нито <code>AssignTo</code> не са заменени</em>, извикването им ще доведе до изключение.</p>
</li>
<li>
<p>Също така имайте предвид, че <em>няма</em> код в изпълнението на <code>TPersistent</code>, който автоматично да копира всички полета (или всички публикувани полета) на класовете. Ето защо трябва да направите това сами, като замените <code>Assign</code> във всички класове. Можете да използвате RTTI (информация за тип на изпълнение) за това, но за прости случаи вероятно просто ще копирате полетата ръчно.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Когато имате клас като <code>TApple</code>, вашата реализация <code>TApple.Assign</code> обикновено ще се занимава с копиране на полета, които са специфични само за класа <code>TApple</code> (не за предшественика на <code>TApple</code>, като <code>TFruit</code>). И така, изпълнението на <code>TApple.Assign</code> обикновено проверява дали <code>Source is TApple</code> в началото, преди да копира полета, свързани с ябълка. След това извиква <code>inherited</code>, за да позволи на <code>TFruit</code> да обработва останалите полета.</p>
</div>
<div class="paragraph">
<p>Ако приемем, че сте написали <code>TFruit.Assign</code> и <code>TApple.Assign</code> по описания начин, тогава ефектът ще е следният:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ако подадете екземпляр <code>TApple</code> на <code>TApple.Assign</code>, той ще копира всички полета.</p>
</li>
<li>
<p>Ако подадете екземпляр <code>TOrange</code> на <code>TApple.Assign</code>, той ще копира само общите полета на <code>TOrange</code> и <code>TApple</code>. С други думи - ще копира полетата дефинирани в <code>TFruit</code>.</p>
</li>
<li>
<p>Ако подадете екземпляр <code>TWerewolf</code> на <code>TApple.Assign</code>, той ще предизвика изключение (защото <code>TApple.Assign</code> ще извика <code>TFruit.Assign</code>, който ще извика <code>TPersistent.Assign</code>, който ще предизвика изключение).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
Запомнете, че когато наследявате <code>TPersistent</code>, по подразбиране <em>спецификатора за видимост</em> е <code>published</code>, за да се позволи сериализиране на наследниците на <code>TPersistent</code>. Не всички типове на полета и свойства са разрешени в секция <code>published</code>. Ако поради това получите грешки и не ви е грижа за сериализацията, просто променете видимостта на <code>public</code>. Вижте <a href="#_нива_на_видимост">Нива на видимост</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_разни_възможности_на_езика">8. Разни възможности на езика</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_локални_вложени_подпрограми">8.1. Локални (вложени) подпрограми</h3>
<div class="paragraph">
<p>Вътре в по-голяма <em>подпрограма</em> (функция, процедура, метод) може да се дефинира друга, помощна подпрограма.</p>
</div>
<div class="paragraph">
<p>Вложената подпрограма може свободно да достъпва (чете и записва) всички параметри подадени на външната, <em>както и всички нейни локални променливи</em>. Това е много мощно средство, което позволява да се разбие голяма подпрограма в няколко по-малки без да е необходимо голямо усилие (тъй като не е нужно да предавате цялата необходима информация в параметрите). Внимавайте да не прекалите&#8201;&#8212;&#8201;ако много вложени подпрограми използват (и дори променят) една и съща променлива на външната подпрограма, кодът може да стане труден за разчитане.</p>
</div>
<div class="paragraph">
<p>Долните два примера са еквивалентни:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">function</span> SumOfSquares(<span class="keyword">const</span> N: Integer): Integer;

  <span class="keyword">function</span> Square(<span class="keyword">const</span> Value: Integer): Integer;
  <span class="keyword">begin</span>
    Result := Value * Value;
  <span class="keyword">end</span>;

<span class="keyword">var</span>
  I: Integer;
<span class="keyword">begin</span>
  Result := <span class="integer">0</span>;
  <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> N <span class="keyword">do</span>
    Result := Result + Square(I);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Друга версия, в която локалната функция <code>Square</code> осъществява директен достъп до <code>I</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">function</span> SumOfSquares(<span class="keyword">const</span> N: Integer): Integer;
<span class="keyword">var</span>
  I: Integer;

  <span class="keyword">function</span> Square: Integer;
  <span class="keyword">begin</span>
    Result := I * I;
  <span class="keyword">end</span>;

<span class="keyword">begin</span>
  Result := <span class="integer">0</span>;
  <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> N <span class="keyword">do</span>
    Result := Result + Square;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Локалните процедури могат да достигнат всякаква дълбочина&#8201;&#8212;&#8201;което означава, че можете да дефинирате локална процедура в друга локална процедура. Така че можете да се развихрите (но моля, не ставайте <em>прекалено диви</em>, или кодът ще стане нечетлив:).</p>
</div>
</div>
<div class="sect2">
<h3 id="Callbacks">8.2. Callbacks (познати като <em>Събития</em>, също като <em>Указатели към функции</em>, също като <em>Процедурни променливи</em>)</h3>
<div class="paragraph">
<p>Позволяват индиректно извикване на подпрограми чрез променлива. Променливата може да бъде присвоена по време на изпълнение, за да сочи към всяка функция <em>със съвпадащи типове параметри и връщани типове</em>.</p>
</div>
<div class="paragraph">
<p>Callback-ът може да бъде:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Нормален, което означава, че може да сочи към всяка обикновена подпрограма (без методи и вложени подпрограми).</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>

<span class="keyword">function</span> Add(<span class="keyword">const</span> A, B: Integer): Integer;
<span class="keyword">begin</span>
  Result := A + B;
<span class="keyword">end</span>;

<span class="keyword">function</span> Multiply(<span class="keyword">const</span> A, B: Integer): Integer;
<span class="keyword">begin</span>
  Result := A * B;
<span class="keyword">end</span>;

<span class="keyword">type</span>
  TMyFunction = <span class="keyword">function</span> (<span class="keyword">const</span> A, B: Integer): Integer;

<span class="keyword">function</span> ProcessTheList(<span class="keyword">const</span> F: TMyFunction): Integer;
<span class="keyword">var</span>
  I: Integer;
<span class="keyword">begin</span>
  Result := <span class="integer">1</span>;
  <span class="keyword">for</span> I := <span class="integer">2</span> <span class="keyword">to</span> <span class="integer">10</span> <span class="keyword">do</span>
    Result := F(Result, I);
<span class="keyword">end</span>;

<span class="keyword">var</span>
  SomeFunction: TMyFunction;
<span class="keyword">begin</span>
  SomeFunction := @Add;
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">1 + 2 + 3 ... + 10 = </span><span class="delimiter">'</span></span>, ProcessTheList(SomeFunction));

  SomeFunction := @Multiply;
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">1 * 2 * 3 ... * 10 = </span><span class="delimiter">'</span></span>, ProcessTheList(SomeFunction));
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</li>
<li>
<p>Метод: декларира се с <code>of object</code> накрая.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  TMyMethod = <span class="keyword">procedure</span> (<span class="keyword">const</span> A: Integer) <span class="keyword">of</span> <span class="keyword">object</span>;

  TMyClass = <span class="keyword">class</span>
    CurrentValue: Integer;
    <span class="keyword">procedure</span> Add(<span class="keyword">const</span> A: Integer);
    <span class="keyword">procedure</span> Multiply(<span class="keyword">const</span> A: Integer);
    <span class="keyword">procedure</span> ProcessTheList(<span class="keyword">const</span> M: TMyMethod);
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.Add(<span class="keyword">const</span> A: Integer);
<span class="keyword">begin</span>
  CurrentValue := CurrentValue + A;
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.Multiply(<span class="keyword">const</span> A: Integer);
<span class="keyword">begin</span>
  CurrentValue := CurrentValue * A;
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.ProcessTheList(<span class="keyword">const</span> M: TMyMethod);
<span class="keyword">var</span>
  I: Integer;
<span class="keyword">begin</span>
  CurrentValue := <span class="integer">1</span>;
  <span class="keyword">for</span> I := <span class="integer">2</span> <span class="keyword">to</span> <span class="integer">10</span> <span class="keyword">do</span>
    M(I);
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C: TMyClass;
<span class="keyword">begin</span>
  C := TMyClass.Create;
  <span class="keyword">try</span>
    C.ProcessTheList(@C.Add);
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">1 + 2 + 3 ... + 10 = </span><span class="delimiter">'</span></span>, C.CurrentValue);

    C.ProcessTheList(@C.Multiply);
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">1 * 2 * 3 ... * 10 = </span><span class="delimiter">'</span></span>, C.CurrentValue);
  <span class="keyword">finally</span>
    FreeAndNil(C);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Имайте предвид, че <em>не можете</em> да предавате глобални процедури / функции като методи. Те не са съвместими. Ако ви трябва <code>of object</code> callback, но не искате да създавате екземпляр от фиктивен клас, можете да използвате <a href="#_методи_на_класа">Методи на класа</a> за целта.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMyMethod = <span class="keyword">function</span> (<span class="keyword">const</span> A, B: Integer): Integer <span class="keyword">of</span> <span class="keyword">object</span>;

  TMyClass = <span class="keyword">class</span>
    <span class="keyword">class</span> <span class="keyword">function</span> Add(<span class="keyword">const</span> A, B: Integer): Integer;
    <span class="keyword">class</span> <span class="keyword">function</span> Multiply(<span class="keyword">const</span> A, B: Integer): Integer;
  <span class="keyword">end</span>;

<span class="keyword">var</span>
  M: TMyMethod;
<span class="keyword">begin</span>
  M := @TMyClass(<span class="keyword">nil</span>).Add;
  M := @TMyClass(<span class="keyword">nil</span>).Multiply;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>За съжаление, ще трябва да изпишете грозното <code>@TMyClass(nil).Add</code> вместо просто <code>@TMyClass.Add</code>.</p>
</div>
</li>
<li>
<p>(Евентуално) локална подпрограма: декларирайте с <code>is nested</code> в края и се уверете, че използвате директивата <code>{$modeswitch nestedprocvars}</code>. Те вървят ръка за ръка с <a href="#_локални_вложени_подпрограми">Локални (вложени) подпрограми</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="Generics">8.3. Генерици</h3>
<div class="paragraph">
<p>Генериците са мощно средство във всеки съвременен език. Дефиницията на нещо (обикновено клас) може да бъде параметризирана с друг тип. Най-типичният пример е, когато трябва да създадете контейнер (списък, речник, дърво, граф&#8230;&#8203;): тогава може да дефинирате <em>списък елементи от тип  T</em>, и после <em>да го специализирате</em> за да получите незабавно <em>списък от цели числа</em>, <em>списък от низове</em>, <em>списък инстанции от клас TMyRecord</em> и т.н.</p>
</div>
<div class="paragraph">
<p>Генериците в Pascal работят подобно на генериците в C++. Което означава, че те се <em>"разширяват"</em> по време на специализацията, <em>подобно</em> на макроси (но са много по-безопасни от тях; например идентификаторите се откриват по време на дефиницията, а не при специализацията, така че не можете да "инжектирате" някакво неочаквано поведение при специализация). На практика това означава, че те са много бързи (могат да бъдат оптимизирани за всеки отделен тип) и работят с типове от всякакъв размер. Когато специализирате генеричен тип можете да използвате примитивен тип (цяло число, float), както запис, така и клас.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  generic TMyCalculator&lt;T&gt; = <span class="keyword">class</span>
    Value: T;
    <span class="keyword">procedure</span> Add(<span class="keyword">const</span> A: T);
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyCalculator.Add(<span class="keyword">const</span> A: T);
<span class="keyword">begin</span>
  Value := Value + A;
<span class="keyword">end</span>;

<span class="keyword">type</span>
  TMyFloatCalculator = specialize TMyCalculator&lt;Single&gt;;
  TMyStringCalculator = specialize TMyCalculator&lt;<span class="keyword">string</span>&gt;;

<span class="keyword">var</span>
  FloatCalc: TMyFloatCalculator;
  StringCalc: TMyStringCalculator;
<span class="keyword">begin</span>
  FloatCalc := TMyFloatCalculator.Create;
  <span class="keyword">try</span>
    FloatCalc.Add(<span class="float">3.14</span>);
    FloatCalc.Add(<span class="integer">1</span>);
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">FloatCalc: </span><span class="delimiter">'</span></span>, FloatCalc.Value:<span class="integer">1</span>:<span class="integer">2</span>);
  <span class="keyword">finally</span>
    FreeAndNil(FloatCalc);
  <span class="keyword">end</span>;

  StringCalc := TMyStringCalculator.Create;
  <span class="keyword">try</span>
    StringCalc.Add(<span class="string"><span class="delimiter">'</span><span class="content">something</span><span class="delimiter">'</span></span>);
    StringCalc.Add(<span class="string"><span class="delimiter">'</span><span class="content"> more</span><span class="delimiter">'</span></span>);
    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">StringCalc: </span><span class="delimiter">'</span></span>, StringCalc.Value);
  <span class="keyword">finally</span>
    FreeAndNil(StringCalc);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Генериците не се ограничават до класове, можете да имате също генерични функции и процедури:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils;

<span class="comment">{ Note: this example requires FPC 3.1.1 (will not compile with FPC 3.0.0 or older). }</span>

generic <span class="keyword">function</span> Min&lt;T&gt;(<span class="keyword">const</span> A, B: T): T;
<span class="keyword">begin</span>
  <span class="keyword">if</span> A &lt; B <span class="keyword">then</span>
    Result := A <span class="keyword">else</span>
    Result := B;
<span class="keyword">end</span>;

<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Min (1, 0): </span><span class="delimiter">'</span></span>, specialize Min&lt;Integer&gt;(<span class="integer">1</span>, <span class="integer">0</span>));
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Min (3.14, 5): </span><span class="delimiter">'</span></span>, specialize Min&lt;Single&gt;(<span class="float">3.14</span>, <span class="integer">5</span>):<span class="integer">1</span>:<span class="integer">2</span>);
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Min (</span><span class="char">''</span><span class="content">a</span><span class="char">''</span><span class="content">, </span><span class="char">''</span><span class="content">b</span><span class="char">''</span><span class="content">): </span><span class="delimiter">'</span></span>, specialize Min&lt;<span class="keyword">string</span>&gt;(<span class="char"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>, <span class="char"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>));
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вижте също <a href="#generic-containers-section">Контейнери (списъци, речници), използващи генерици</a> относно важните стандартни класове, използващи генерици.</p>
</div>
</div>
<div class="sect2">
<h3 id="_overloading">8.4. Overloading</h3>
<div class="paragraph">
<p>Позволени са методи (също и глобални функции и процедури) с едно и също име, стига да имат различни параметри. По време на компилиране компилаторът открива кой вариант искате да използвате, като узнае параметрите, които подавате.</p>
</div>
<div class="paragraph">
<p>По подразбиране overloading-ът използва FPC подхода, което означава, че всички методи в дадено пространство от имена (клас или unit) са равнопоставени и закриват другите методи в пространства от имена с по-малък приоритет. Например, ако дефинирате клас с методи <code>Foo(Integer)</code> и <code>Foo(string)</code> и той наследява клас с метод <code>Foo(Float)</code>, тогава потребителите на вашия нов клас няма да имат достъп до метод <code>Foo(Float)</code> толкова лесно (те все още могат --- ако преобразуват класа към неговия тип-предшественик). За да преодолеете това, използвайте ключовата дума <code>overload</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_препроцесор">8.5. Препроцесор</h3>
<div class="paragraph">
<p>Можете да използвате прости препроцесорни директиви за:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>условна компилация (код зависим от платформата или други ръчно зададени параметри),</p>
</li>
<li>
<p>да включите един файл в друг,</p>
</li>
<li>
<p>да дефинирате макроси без параметри.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Имайте предвид, че макроси с параметри не се поддържат. Като цяло трябва да избягвате използването на препроцесорните директиви&#8230;&#8203; освен ако наистина не се налага. Предварителната обработка се прави преди компилатора да извърши анализа на кода, което означава, че можете да "нарушите" нормалния синтаксис на езика Pascal. Това е мощна, но и донякъде "нечиста" функция.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">unit</span> PreprocessorStuff;
<span class="keyword">interface</span>

<span class="preprocessor">{$ifdef FPC}</span>
<span class="comment">{ Това е дефинирано само ако се компилира с FPC, не с други компилатори (напр. Delphi). }</span>
<span class="keyword">procedure</span> Foo;
<span class="preprocessor">{$endif}</span>

<span class="comment">{ Дефиниране на константата NewLine. Тук може да видите как нормалния синтаксис на Паскал
  се &quot;чупи&quot; с препроцесорните директиви. Когато компилирате за Unix
  (вкл. Linux, Android, Mac OS X), компилатора вижда това:

    const NewLine = #10;

  Когато компилирате за Windows, компилатора вижда това:

    const NewLine = #13#10;

  За други операционни системи, кодът няма да се компилира,
  защото компилатора вижда това:

    const NewLine = ;

  *Хубаво е*, че компилирането се проваля в този случай -- така ако трябва да
  пригодите програмата към ОС, която не е Unix или Windows, компилатора ще ви
  припомни да изберете конвенция за нов ред (newline) за тази система. }</span>

<span class="keyword">const</span>
  NewLine =
    <span class="preprocessor">{$ifdef UNIX}</span> <span class="char">#10</span> <span class="preprocessor">{$endif}</span>
    <span class="preprocessor">{$ifdef MSWINDOWS}</span> <span class="char">#13</span><span class="char">#10</span> <span class="preprocessor">{$endif}</span> ;

<span class="preprocessor">{$define MY_SYMBOL}</span>

<span class="preprocessor">{$ifdef MY_SYMBOL}</span>
<span class="keyword">procedure</span> Bar;
<span class="preprocessor">{$endif}</span>

<span class="preprocessor">{$define CallingConventionMacro := unknown}</span>
<span class="preprocessor">{$ifdef UNIX}</span>
  <span class="preprocessor">{$define CallingConventionMacro := cdecl}</span>
<span class="preprocessor">{$endif}</span>
<span class="preprocessor">{$ifdef MSWINDOWS}</span>
  <span class="preprocessor">{$define CallingConventionMacro := stdcall}</span>
<span class="preprocessor">{$endif}</span>
<span class="keyword">procedure</span> RealProcedureName; CallingConventionMacro; <span class="directive">external</span> <span class="string"><span class="delimiter">'</span><span class="content">some_external_library</span><span class="delimiter">'</span></span>;

<span class="keyword">implementation</span>

<span class="preprocessor">{$include some_file.inc}</span>
<span class="comment">// $I е съкращение за $include</span>
<span class="preprocessor">{$I some_other_file.inc}</span>

<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Включваните файлове обикновено имат разширение <code>.inc</code> и се използват за две цели:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Включеният файл може да съдържа само други директиви на компилатора, които "конфигурират" вашия изходен код. Например можете да създадете файл <code>myconfig.inc</code> със следното съдържание:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span>
<span class="preprocessor">{$H+}</span>
<span class="preprocessor">{$J-}</span>
<span class="preprocessor">{$modeswitch advancedrecords}</span>
<span class="preprocessor">{$ifndef VER3}</span>
  <span class="preprocessor">{$error Този код може да се компилира само с FPC версия 3.x. или по-висока}</span>
<span class="preprocessor">{$endif}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега можете да включите този файл с помощта на <code>{$I myconfig.inc}</code> във всички ваши изходни файлове.</p>
</div>
</li>
<li>
<p>Друга цел е да се раздели голям unit на много файлове, като същевременно се запази като един unit относно езиковите правила. Не прекалявайте с тази техника - първият ви инстинкт трябва да бъде да разделите един unit на множество unit-и, а не да разделяте един unit на множество включени файлове. Все пак това е полезна техника. Позволява да се избегне "експлозията" на броя на unit-ите, като същевременно поддържа вашите файлове с изходен код кратки. Например, може да е по-добре да имате единичен unit с <em>"често използвани UI контроли"</em> отколкото да създавате <em>по един unit за всеки UI контролен клас</em>, тъй като последното би направило клаузата <code>uses</code> дълга (тъй като обикновено UI ще зависи от няколко UI класа). Но поставянето на всички тези UI класове в един файл <code>myunit.pas</code> би го направило също така дълъг и неудобен за навигация, така че разделянето му на множество включени файлове може да има смисъл.</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Позволява лесно да имате междуплатформен интерфейс на unit с платформено-зависима реализация. По принцип можете да направите:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$ifdef UNIX}</span> <span class="preprocessor">{$I my_unix_implementation.inc}</span> <span class="preprocessor">{$endif}</span>
<span class="preprocessor">{$ifdef MSWINDOWS}</span> <span class="preprocessor">{$I my_windows_implementation.inc}</span> <span class="preprocessor">{$endif}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Понякога това е по-добре от писането на дълъг код с много <code>{$ifdef UNIX}</code>, <code>{$ifdef MSWINDOWS}</code>, примесени с нормален код (декларации на променливи, тела на подпрограми). По този начин кодът става по-четлив. Можете дори да използвате тази техника по-агресивно, като използвате опцията на командния ред <code>-Fi</code> на FPC, за да включите някои поддиректории само за определени платформи. Тогава можете да имате много версии на включения файл <code>{$I my_platform_specific_implementation.inc}</code> и просто да ги включвате, позволявайки на компилатора да намери правилната версия.</p>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_записи">8.6. Записи</h3>
<div class="paragraph">
<p><em>Record</em> е просто контейнер за други променливи. Това е като много, много опростен <em>class</em>: няма наследяване или виртуални методи. Това е като <em>struct</em> в C-подобните езици.</p>
</div>
<div class="paragraph">
<p>Ако използвате директивата <code>{$modeswitch advancedrecords}</code>, записите <strong>могат</strong> да имат методи и спецификатори за видимост. Като цяло, тогава са възможни езикови функции, които са налични за класове и <em>не нарушават простото предвидимо разпределение на паметта на запис</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="preprocessor">{$modeswitch advancedrecords}</span>
<span class="keyword">type</span>
  TMyRecord = <span class="keyword">record</span>
  <span class="directive">public</span>
    I, Square: Integer;
    <span class="keyword">procedure</span> WriteLnDescription;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyRecord.WriteLnDescription;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Square of </span><span class="delimiter">'</span></span>, I, <span class="string"><span class="delimiter">'</span><span class="content"> is </span><span class="delimiter">'</span></span>, Square);
<span class="keyword">end</span>;

<span class="keyword">var</span>
  A: <span class="keyword">array</span> [<span class="integer">0</span>..<span class="integer">9</span>] <span class="keyword">of</span> TMyRecord;
  R: TMyRecord;
  I: Integer;
<span class="keyword">begin</span>
  <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> <span class="integer">9</span> <span class="keyword">do</span>
  <span class="keyword">begin</span>
    A[I].I := I;
    A[I].Square := I * I;
  <span class="keyword">end</span>;

  <span class="keyword">for</span> R <span class="keyword">in</span> A <span class="keyword">do</span>
    R.WriteLnDescription;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>В съвременния Обектен Паскал първият ви мисъл трябва да бъде да проектирате "клас", а не "запис"&#8201;&#8212;&#8201;защото класовете са пълни с полезни функции, като конструктори и наследяване.</p>
</div>
<div class="paragraph">
<p>Но записите все още са много полезни, когато имате нужда от скорост или предвидимо разпределение на паметта:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Записите нямат конструктор или деструктор. Вие просто дефинирате променлива от тип запис. Има недефинирано съдържание (боклук от паметта) в началото (с изключение на автоматично управлявани типове, като низове; гарантирано е, че те ще бъдат инициализирани, така че да бъдат празни, и финализирани, за да освободят броя на препратките). Така че трябва да сте по-внимателни, когато работите със записи. Те обаче ви дават известно предимство в скоростта.</p>
</li>
<li>
<p>Масивите от записи са добре линеаризирани в паметта, така че са удобни за кеширане.</p>
</li>
<li>
<p>Разпределението на паметта при записите (размер, празнини между полетата) е ясно дефинирано в някои ситуации: когато поискате <em>C layout</em> или когато използвате <code>packed record</code>. Това е полезно:</p>
<div class="ulist">
<ul>
<li>
<p>за комуникация с библиотеки, написани на други езици за програмиране, когато предоставят API, базиран на записи,</p>
</li>
<li>
<p>за четене и запис на двоични файлове,</p>
</li>
<li>
<p>да правят мръсни трикове на ниско ниво (като нерестриктирано конвертиране на типове от един тип към друг, когато сте наясно с тяхното представяне в паметта).</p>
</li>
</ul>
</div>
</li>
<li>
<p>Записите също могат да имат <code>case</code> варианти, които работят като <em>unions</em> в C-подобните езици. Те позволяват да се третира една и съща част от паметта като различен тип, в зависимост от вашите нужди. Това позволява по-добро използване на паметта в някои случаи. И позволява повече <em>мръсни, опасни трикове на ниско ниво</em>:)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_обекти_стар_стил">8.7. Обекти, стар стил</h3>
<div class="paragraph">
<p>Преди време Turbo Pascal въведе друг синтаксис за функционалност, подобна на клас, използвайки ключовата дума <code>object</code>. Това е донякъде смесица между концепцията за "запис" и модерната за "клас".</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Старите обекти могат да се създават / освобождават и по време на тези операции можете да извикате техния конструктор / деструктор.</p>
</li>
<li>
<p>Но те също могат да и да бъдат просто декларирани и използвани, като обикновени записи. Простият тип "запис" или "обект" не е препратка (указател) към нещо друго, това са просто данни. Това ги прави удобни за малки обеми от данни, където многократното създаване и освобождаване не винаги е оправдано.</p>
</li>
<li>
<p>Старите обекти предлагат наследяване и виртуални методи, макар и с малки разлики от съвременните класове. Бъдете внимателни&#8201;&#8212;&#8201;<em>лоши неща</em> могат да се случат, ако се опитате да използвате обект с виртуални методи, без да извикате неговия конструктор.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В повечето случаи не се препоръчва използването на обекти от стария вид. Съвременните <em>класове</em> предоставят много повече функционалност. Когато е необходимо да се повиши скоростта на изпълнение, могат да се използват записи (вкл. <em>разширени записи</em>). Този подход е по-добър от използването на стари обекти.</p>
</div>
</div>
<div class="sect2">
<h3 id="_указатели">8.8. Указатели</h3>
<div class="paragraph">
<p>Можете да създадете <em>указател</em> към всеки тип данни. Указателят към типа <code>TMyRecord</code> се декларира като <code>^TMyRecord</code> и по конвенция се нарича <code>PMyRecord</code>. По-долу е показан традиционен пример за свързан списък от цели числа, използващи записи:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  PMyRecord = ^TMyRecord;
  TMyRecord = <span class="keyword">record</span>
    Value: Integer;
    Next: PMyRecord;
  <span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обърнете внимание, че дефиницията е рекурсивна (тип <code>PMyRecord</code> се дефинира с помощта на тип <code>TMyRecord</code>, докато <code>TMyRecord</code> се дефинира с помощта на <code>PMyRecord</code>). Позволено е да се дефинира тип указател към <em>все още недефиниран тип</em>, стига той да бъде дефиниран в рамките на същия раздел <code>type</code>.</p>
</div>
<div class="paragraph">
<p>Можете да заемате и освобождавате памет за указателите с помоща на методите <code>New</code> и <code>Dispose</code> или (на по-ниско ниво, типово необезопасено) методите <code>GetMem</code> и <code>FreeMem</code>. За да достъпите данните, които указателите сочат, следва да добавите оператора <code>^ (например `MyInteger := MyPointerToInteger^</code>). За да направите обратната операция, която е <em>получаване на указател към съществуваща променлива</em>, трябва да използвате префикс-оператора <code>@</code> (например <code>MyPointerToInteger := @MyInteger</code>).</p>
</div>
<div class="paragraph">
<p>Има и нетипизиран тип <code>Pointer</code>, подобен на <code>void*</code> в C-подобните езици. Той е напълно типово необезопасен и може да бъде преобразуван във всеки друг тип указател.</p>
</div>
<div class="paragraph">
<p>Не забравяйте, че <em>екземплярът на class</em> всъщност е указател, въпреки че не изисква оператори <code>^</code> или <code>@</code>, за да го използвате.
Възможно е да се направи свързан списък, използващ класове, той би бил следният:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
    Value: Integer;
    Next: TMyClass;
  <span class="keyword">end</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_замяна_на_оператори">8.9. Замяна на оператори</h3>
<div class="paragraph">
<p>Можете да замените значението на много от езиковите оператори, за да позволите например събиране и умножение във вашите потребителски типове. Като например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  StrUtils;

operator* (<span class="keyword">const</span> S: <span class="keyword">string</span>; <span class="keyword">const</span> A: Integer): <span class="keyword">string</span>;
<span class="keyword">begin</span>
  Result := DupeString(S, A);
<span class="keyword">end</span>;

<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">bla</span><span class="delimiter">'</span></span> * <span class="integer">10</span>);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Също така можете да заменяте значението на оператори върху класове. Понеже в такива функции-оператори обикновено се създават нови екземпляри на класовете, в извикващия код трябва да се предвиди надлежното освобождаване на заетата памет.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
    MyInt: Integer;
  <span class="keyword">end</span>;

operator* (<span class="keyword">const</span> C1, C2: TMyClass): TMyClass;
<span class="keyword">begin</span>
  Result := TMyClass.Create;
  Result.MyInt := C1.MyInt * C2.MyInt;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C1, C2: TMyClass;
<span class="keyword">begin</span>
  C1 := TMyClass.Create;
  <span class="keyword">try</span>
    C1.MyInt := <span class="integer">12</span>;
    C2 := C1 * C1;
    <span class="keyword">try</span>
      WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">12 * 12 = </span><span class="delimiter">'</span></span>, C2.MyInt);
    <span class="keyword">finally</span>
      FreeAndNil(C2);
    <span class="keyword">end</span>;
  <span class="keyword">finally</span>
    FreeAndNil(C1);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Можете и да замените значението на оператори върху записи. Това е по-просто отколкото да го правите върху класове, защото няма нужда да се грижите за освобождаването на заетата памет.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  TMyRecord = <span class="keyword">record</span>
    MyInt: Integer;
  <span class="keyword">end</span>;

operator* (<span class="keyword">const</span> C1, C2: TMyRecord): TMyRecord;
<span class="keyword">begin</span>
  Result.MyInt := C1.MyInt * C2.MyInt;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  R1, R2: TMyRecord;
<span class="keyword">begin</span>
  R1.MyInt := <span class="integer">12</span>;
  R2 := R1 * R1;
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">12 * 12 = </span><span class="delimiter">'</span></span>, R2.MyInt);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>За работа със записи се препоръчва да използвате <code>{$modeswitch advancedrecords}</code> и да замените операторите като <code>class operator</code> вътре в записа. Това позволява да се използват генерични контейнери, които зависят от съществуването на някакъв оператор (като <code>TFPGList</code>, който зависи от наличието на оператор за равенство) с такива записи. В противен случай "глобалната" дефиниция на оператор (която не в записа) няма да бъде открита (защото не е налична в кода, който имплементира <code>TFPGList</code>) и няма да можете да специализирате списък със <code>specialize TFPGList&lt;TMyRecord&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="preprocessor">{$modeswitch advancedrecords}</span>
<span class="keyword">uses</span>
  SysUtils, FGL;

<span class="keyword">type</span>
  TMyRecord = <span class="keyword">record</span>
    MyInt: Integer;
    <span class="keyword">class</span> operator+ (<span class="keyword">const</span> C1, C2: TMyRecord): TMyRecord;
    <span class="keyword">class</span> operator= (<span class="keyword">const</span> C1, C2: TMyRecord): boolean;
  <span class="keyword">end</span>;

<span class="keyword">class</span> operator TMyRecord.+ (<span class="keyword">const</span> C1, C2: TMyRecord): TMyRecord;
<span class="keyword">begin</span>
  Result.MyInt := C1.MyInt + C2.MyInt;
<span class="keyword">end</span>;

<span class="keyword">class</span> operator TMyRecord.= (<span class="keyword">const</span> C1, C2: TMyRecord): boolean;
<span class="keyword">begin</span>
  Result := C1.MyInt = C2.MyInt;
<span class="keyword">end</span>;

<span class="keyword">type</span>
  TMyRecordList = specialize TFPGList&lt;TMyRecord&gt;;

<span class="keyword">var</span>
  R, ListItem: TMyRecord;
  L: TMyRecordList;
<span class="keyword">begin</span>
  L := TMyRecordList.Create;
  <span class="keyword">try</span>
    R.MyInt := <span class="integer">1</span>;   L.Add(R);
    R.MyInt := <span class="integer">10</span>;  L.Add(R);
    R.MyInt := <span class="integer">100</span>; L.Add(R);

    R.MyInt := <span class="integer">0</span>;
    <span class="keyword">for</span> ListItem <span class="keyword">in</span> L <span class="keyword">do</span>
      R := ListItem + R;

    WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">1 + 10 + 100 = </span><span class="delimiter">'</span></span>, R.MyInt);
  <span class="keyword">finally</span>
    FreeAndNil(L);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_допълнителни_възможности_на_класовете">9. Допълнителни възможности на класовете</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_частни_и_лични_полета">9.1. Частни и лични полета</h3>
<div class="paragraph">
<p>Спецификатора <code>private</code> означава, че полето (или метода) не е достъпно извън класа, в който е декларирано. Това правило обаче позволява изключение: кодът <em>в същия модул</em> може да работи с частни полета и методи. Някой програмист на C++ би могъл да каже, че <em>всички класове в един модул са "приятели"<sup class="footnote" id="_footnote_friends">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup></em>. Това изключение често е полезно и не нарушава енкапсулацията защото в крайна сметка е в границите на един модул.</p>
</div>
<div class="paragraph">
<p>От друга страна, ако правите големи модули с много класове, които не са силно свързани един с друг, е по-безопасно да използвате спецификатора <code>strict private</code>. Той наистина ще ограничи достъпа до полето (или метода) само в рамките на класа. Без изключения.</p>
</div>
<div class="paragraph">
<p>Аналогично&#8201;&#8212;&#8201;спецификатора <code>protected</code> означава, че полето или метода е достъпен за наследниците и "приятелите" в модула, докато <code>strict protected</code>, че е достъпно само за наследниците.</p>
</div>
</div>
<div class="sect2">
<h3 id="_допълнителни_декларации_и_вложени_класове">9.2. Допълнителни декларации и вложени класове</h3>
<div class="paragraph">
<p>В един клас можете да декларирате и вложени секции за константи (<code>const</code>) или типове (<code>type</code>). По този начин може дори да се декларират и вложени класове. Спецификаторите за видимост работят както винаги, в частност вложеният клас може да бъде <code>private</code>(невидим за външния свят), което доста често е полезно.</p>
</div>
<div class="paragraph">
<p>Имайте предвид, че за да декларирате поле след константа или тип, ще трябва да започнете блок <code>var</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
  <span class="directive">private</span>
    <span class="keyword">type</span>
      TInternalClass = <span class="keyword">class</span>
        Velocity: Single;
        <span class="keyword">procedure</span> DoSomething;
      <span class="keyword">end</span>;
    <span class="keyword">var</span>
      FInternalClass: TInternalClass;
  <span class="directive">public</span>
    <span class="keyword">const</span>
      DefaultVelocity = <span class="integer">10</span><span class="float">0.0</span>;
    <span class="keyword">constructor</span> Create;
    <span class="keyword">destructor</span> Destroy; <span class="directive">override</span>;
  <span class="keyword">end</span>;

<span class="keyword">constructor</span> TMyClass.Create;
<span class="keyword">begin</span>
  <span class="keyword">inherited</span>;
  FInternalClass := TInternalClass.Create;
  FInternalClass.Velocity := DefaultVelocity;
  FInternalClass.DoSomething;
<span class="keyword">end</span>;

<span class="keyword">destructor</span> TMyClass.Destroy;
<span class="keyword">begin</span>
  FreeAndNil(FInternalClass);
  <span class="keyword">inherited</span>;
<span class="keyword">end</span>;

<span class="comment">{ забележете, че дефиницията на метода долу има префикс
  &quot;TMyClass.TInternalClass&quot;. }</span>
<span class="keyword">procedure</span> TMyClass.TInternalClass.DoSomething;
<span class="keyword">begin</span>
<span class="keyword">end</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_методи_на_класа">9.3. Методи на класа</h3>
<div class="paragraph">
<p>Това са методи, които можете да извикате с препратка към клас (<code>TMyClass</code>), не непременно към екземпляр на клас.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TEnemy = <span class="keyword">class</span>
    <span class="keyword">procedure</span> Kill;
    <span class="keyword">class</span> <span class="keyword">procedure</span> KillAll;
  <span class="keyword">end</span>;

<span class="keyword">var</span>
  E: TEnemy;
<span class="keyword">begin</span>
  E := TEnemy.Create;
  <span class="keyword">try</span>
    E.Kill;
  <span class="keyword">finally</span> FreeAndNil(E) <span class="keyword">end</span>;
  TEnemy.KillAll;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Имайте предвид, че те също могат да бъдат виртуални - това понякога е много полезно когато се комбинират с <a href="#_препратки_към_клас">Препратки към клас</a>.</p>
</div>
<div class="paragraph">
<p>Методите на клас съшо могат да бъдат ограничени с <a href="#_нива_на_видимост">Нива на видимост</a> като <code>private</code> or <code>protected</code> съвсем като обикновените методи.</p>
</div>
<div class="paragraph">
<p>Имайте предвид, че конструкторът винаги действа като метод на клас, когато се извиква по нормален начин <code>MyInstance := TMyClass.Create(&#8230;&#8203;);</code>. Въпреки, че е възможно също така да се извика конструктор в тялото на метод на самия клас и тогава той действа като обикновен метод. Това е полезна функция за "верижни" конструктори, когато един конструктор (напр. подменен за да приеме целочислен параметър) върши нещо и след това извиква друг конструктор (напр. без параметър).</p>
</div>
</div>
<div class="sect2">
<h3 id="_препратки_към_клас">9.4. Препратки към клас</h3>
<div class="paragraph">
<p><em>Препратките към клас</em> ви позволяват да изберете класа по време на изпълнение, например да извикате метод на клас или конструктор, без да знаете точния клас по време на компилация. Това е тип, деклариран като <code>class of TMyClass</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>(TComponent)
  <span class="keyword">end</span>;

  TMyClass1 = <span class="keyword">class</span>(TMyClass)
  <span class="keyword">end</span>;

  TMyClass2 = <span class="keyword">class</span>(TMyClass)
  <span class="keyword">end</span>;

  TMyClassRef = <span class="keyword">class</span> <span class="keyword">of</span> TMyClass;

<span class="keyword">var</span>
  C: TMyClass;
  ClassRef: TMyClassRef;
<span class="keyword">begin</span>
  <span class="comment">// Obviously you can do this:</span>

  C := TMyClass.Create(<span class="keyword">nil</span>); FreeAndNil(C);
  C := TMyClass1.Create(<span class="keyword">nil</span>); FreeAndNil(C);
  C := TMyClass2.Create(<span class="keyword">nil</span>); FreeAndNil(C);

  <span class="comment">// В допълнение, използвайки препратки към клас, може да направите и следното:</span>

  ClassRef := TMyClass;
  C := ClassRef.Create(<span class="keyword">nil</span>); FreeAndNil(C);

  ClassRef := TMyClass1;
  C := ClassRef.Create(<span class="keyword">nil</span>); FreeAndNil(C);

  ClassRef := TMyClass2;
  C := ClassRef.Create(<span class="keyword">nil</span>); FreeAndNil(C);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Препратките към класове могат да се комбинират с виртуални клас-методи. Това дава същия ефект както използването на класове с виртуални методи - действителният метод, който трябва да бъде извикан, се определя по време на изпълнение.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>(TComponent)
    <span class="keyword">class</span> <span class="keyword">procedure</span> DoSomething; <span class="directive">virtual</span>; <span class="directive">abstract</span>;
  <span class="keyword">end</span>;

  TMyClass1 = <span class="keyword">class</span>(TMyClass)
    <span class="keyword">class</span> <span class="keyword">procedure</span> DoSomething; <span class="directive">override</span>;
  <span class="keyword">end</span>;

  TMyClass2 = <span class="keyword">class</span>(TMyClass)
    <span class="keyword">class</span> <span class="keyword">procedure</span> DoSomething; <span class="directive">override</span>;
  <span class="keyword">end</span>;

  TMyClassRef = <span class="keyword">class</span> <span class="keyword">of</span> TMyClass;

<span class="keyword">var</span>
  C: TMyClass;
  ClassRef: TMyClassRef;
<span class="keyword">begin</span>
  ClassRef := TMyClass1;
  ClassRef.DoSomething;

  ClassRef := TMyClass2;
  ClassRef.DoSomething;

  <span class="comment">{ Това ще предизвика изключение по време на изпълнение
    защото DoSomething е абстрактен в TMyClass. }</span>
  ClassRef := TMyClass;
  ClassRef.DoSomething;
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако имате екземпляр и искате да получите препратка към неговия клас (не декларирания клас, а същинския клас използван при неговото конструиране), можете да използвате свойството <code>ClassType</code>. Типа на <code>ClassType</code> е <code>TClass</code>, който е деклариран като <code>class of TObject</code>. Често можете без проблем да го преобразувате към по-конкретен клас, ако ви е известно, че е екземплярът е нещо по-специфично от <code>TObject</code>.</p>
</div>
<div class="paragraph">
<p>Можете да използвате препратката от <code>ClassType</code> за извикване на виртуални методи, в това число виртуални конструктори. Това ви позволява да създадете метод <code>Clone</code>, който създава екземпляр от <em>точния клас на текущия обект</em>. Може да го комбинирате с <a href="#_клониране_tpersistent_assign">Клониране: TPersistent.Assign</a> за да получите метод, който връща нов "клонинг" на инстанцията от която е извикан.</p>
</div>
<div class="paragraph">
<p>Не забравяйте, че това ще работи само когато конструкторът на вашия клас е виртуален. Например, може да се използва със стандартните наследници на <code>TComponent</code>, тъй като всички те трябва да заменят виртуалния конструктор <code>TComponent.Create(AOwner: TComponent)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>(TComponent)
    <span class="keyword">procedure</span> Assign(Source: TPersistent); <span class="directive">override</span>;
    <span class="keyword">function</span> Clone(AOwner: TComponent): TMyClass;
  <span class="keyword">end</span>;

  TMyClassRef = <span class="keyword">class</span> <span class="keyword">of</span> TMyClass;

<span class="keyword">function</span> TMyClass.Clone(AOwner: TComponent): TMyClass;
<span class="keyword">begin</span>
  <span class="comment">// Това трябва винаги да създаде инстанция точно от клас TMyClass:</span>
  <span class="comment">//Result := TMyClass.Create(AOwner);</span>
  <span class="comment">// Това може потенциално да създаде инстанция от наследник на TMyClass:</span>
  Result := TMyClassRef(ClassType).Create(AOwner);
  Result.Assign(Self);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_статични_методи_на_клас">9.5. Статични методи на клас</h3>
<div class="paragraph">
<p>За да разберете <em>статичните методи на клас</em>, трябва да разберете как работят <em>нормалните методи на клас</em> (описани в предишните раздели). Вътрешно, <em>нормалните методи на клас</em> получават <em>референция</em> към своя клас (тя се предава през скрит, неявно добавен параметър на метода). Тази препратка може да се използва с помощта на ключовата дума <code>Self</code> в метода на класа. Обикновено това е полезно: тази препратка към клас ви позволява да извиквате <em>виртуалните методи на класа</em> (чрез <em>таблицата с виртуални методи</em> на класа).</p>
</div>
<div class="paragraph">
<p>Наличието на скрита препратка обаче, прави <em>методите на класа</em> несъвместими с <em>процедурните променливи</em>. Следната програма <strong>няма да може да се компилира</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">type</span>
  TMyCallback = <span class="keyword">procedure</span> (A: Integer);

  TMyClass = <span class="keyword">class</span>
    <span class="keyword">class</span> <span class="keyword">procedure</span> Foo(A: Integer);
  <span class="keyword">end</span>;

<span class="keyword">class</span> <span class="keyword">procedure</span> TMyClass.Foo(A: Integer);
<span class="keyword">begin</span>
<span class="keyword">end</span>;

<span class="keyword">var</span>
  Callback: TMyCallback;
<span class="keyword">begin</span>
  <span class="comment">// Грешка: TMyClass.Foo не е съвместим с TMyCallback</span>
  Callback := @TMyClass(<span class="keyword">nil</span>).Foo;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
<div class="paragraph">
<p>Ако сте в режим <em>Delphi</em> тогава ще можете да напишете <code>TMyClass.Foo</code> вместо грозното <code>TMyClass(nil).Foo</code> което е в горния пример. Трябва да се признае, че <code>TMyClass.Foo</code> изглежда много по-елегантно и също така се проверява по-добре от компилатора. Използването на <code>TMyClass(nil).Foo</code> е хак&#8230;&#8203; за съжаление необходим (засега) в режима <em>ObjFpc</em>, който е представен в тази книга.</p>
</div>
<div class="paragraph">
<p>Във всеки случай, присвояването на <code>TMyClass.Foo</code> на <code>Callback</code> по-горе би <em>било неуспешно</em> и в режим Delphi, поради абсолютно същите причини.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Горният пример не се компилира, защото типа на <code>Callback</code> не е съвместим с метода на класа <code>Foo</code>. Това е така, защото вътрешно методът <code>Foo</code> има този специален скрит <em>implicit</em> параметър за препратката към класа.</p>
</div>
<div class="paragraph">
<p>Един от начините да коригирате горния пример е да промените дефиницията на <code>TMyCallback</code> на следната: <code>TMyCallback = procedure (A: Integer) of object;</code>. Но понякога това не е желателно.</p>
</div>
<div class="paragraph">
<p>Другият начин е метода да се укаже като <code>static</code>. По същество такъв метод е просто глобална процедура / функция, с тази разлика, че видимостта му е ограничена вътре в класа. Той <em>няма</em> такава скрита препратка към клас (по този начин <em>не може да бъде виртуален</em> и <em>не може да извиква виртуални методи</em>). От друга страна, той е съвместим с нормалните (необектни) процедурни променливи. Така че това ще работи:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">type</span>
  TMyCallback = <span class="keyword">procedure</span> (A: Integer);

  TMyClass = <span class="keyword">class</span>
    <span class="keyword">class</span> <span class="keyword">procedure</span> Foo(A: Integer); static;
  <span class="keyword">end</span>;

<span class="keyword">class</span> <span class="keyword">procedure</span> TMyClass.Foo(A: Integer);
<span class="keyword">begin</span>
<span class="keyword">end</span>;

<span class="keyword">var</span>
  Callback: TMyCallback;
<span class="keyword">begin</span>
  Callback := @TMyClass.Foo;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_полета_и_свойства_на_клас">9.6. Полета и свойства на клас</h3>
<div class="paragraph">
<p><em>Полето на клас</em> може да се дефинира в секция <code>class var</code> вътре в класа. То е подобно на обикновеното поле но няма нужда от инстанция за да се достъпва. Като резултат, то е подобно на глобална променлива но видимостта му е ограничена само в класа, в който е дефинирано.</p>
</div>
<div class="paragraph">
<p><em>Свойството на клас</em> е такова свойство, което може да се достъпи през референция на клас и без да е необходимо да има създадена инстанция. Дефинира се с <code>class property</code> вместо само с <code>property</code> и с методи <em>getter</em> и / или <em>setter</em>, които обаче трябва да са <em>статични клас-методи</em>. Виж <a href="#_статични_методи_на_клас">Статични методи на клас</a>.</p>
</div>
<div class="paragraph">
<p>По аналогия с обикновените свойства (виж <a href="#_свойства">Свойства</a>), вместо да се укаже <em>статичен клас-метод</em>, може да се укаже и име на поле. То също трябва да бъде <em>поле на клас</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">type</span>
  TMyClass = <span class="keyword">class</span>
  strict <span class="directive">private</span>
    <span class="comment">// Alternative:</span>
    <span class="comment">// FMyProperty: Integer; static;</span>
    <span class="keyword">class</span> <span class="keyword">var</span>
      FMyProperty: Integer;
    <span class="keyword">class</span> <span class="keyword">procedure</span> SetMyProperty(<span class="keyword">const</span> Value: Integer); static;
  <span class="directive">public</span>
    <span class="keyword">class</span> <span class="keyword">property</span> MyProperty: Integer
      <span class="directive">read</span> FMyProperty <span class="directive">write</span> SetMyProperty;
  <span class="keyword">end</span>;

<span class="keyword">class</span> <span class="keyword">procedure</span> TMyClass.SetMyProperty(<span class="keyword">const</span> Value: Integer);
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">MyProperty changes!</span><span class="delimiter">'</span></span>);
  FMyProperty := Value;
<span class="keyword">end</span>;

<span class="keyword">begin</span>
  TMyClass.MyProperty := <span class="integer">123</span>;
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass.MyProperty is now </span><span class="delimiter">'</span></span>, TMyClass.MyProperty);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_помощници_за_клас">9.7. Помощници за клас</h3>
<div class="paragraph">
<p><em>Методът</em> е просто процедура или функция вътре в класa. Извън класа го извиквате със специален синтаксис <code>MyInstance.MyMethod(&#8230;&#8203;)</code>. След известно време привиквате да мислите, че <em>ако искам да извърша действие Action с инстанция X, пиша `X.Action(&#8230;&#8203;)`</em>.</p>
</div>
<div class="paragraph">
<p>Но понякога трябва да кодирате нещо, което по смисъла си е <em>действие върху инстанция от клас TMyClass</em>, но без да модифицирате изходния код на <em>TMyClass</em>. Понякога това е така, защото изходния код не е ваш и не искате да го променяте. Понякога това се дължи на някакви зависимости&#8201;&#8212;&#8201;добавянето на нов метод като <code>Render</code> към клас <code>TMy3DObject</code> изглежда проста идея, но може би базовата реализация на класа <code>TMy3DObject</code> трябва да се поддържа независима от кода за изобразяване? Би било по-добре да "подобрите" съществуващ клас и да добавите функционалност към него, без да променяте изходния му код.</p>
</div>
<div class="paragraph">
<p>Простия начин да го направите е да създадете глобална процедура, която приема екземпляр на <code>TMy3DObject</code> като свой първи параметър.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">procedure</span> Render(<span class="keyword">const</span> Obj1: TMy3DObject; <span class="keyword">const</span> Color: TColor);
<span class="keyword">var</span>
  I: Integer;
<span class="keyword">begin</span>
  <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> Obj1.ShapesCount - <span class="integer">1</span> <span class="keyword">do</span>
    RenderMesh(Obj1.Shape[I].Mesh, Color);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Това работи идеално, но недостатъкът е, че извикването изглежда малко грозно. Докато обикновено извиквате действия като <code>X.Action(&#8230;&#8203;)</code>, в този случай трябва да ги извиквате като <code>Render(X, &#8230;&#8203;)</code>. Би било добре да можете просто да напишете <code>X.Render(&#8230;&#8203;)</code>, дори когато <code>Render</code> не е имплементирано в същия модул като <code>TMy3DObject</code>.</p>
</div>
<div class="paragraph">
<p>За това са пригодени <em>помощниците за клас</em>. Те са просто начин за прилагане на процедури / функции, които работят върху даден клас и които се извикват като нормални методи, но всъщност не са такива - те са добавени отвън към дефиницията на <code>TMy3DObject</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="keyword">type</span>
  TMy3DObjectHelper = <span class="keyword">class</span> helper <span class="keyword">for</span> TMy3DObject
    <span class="keyword">procedure</span> Render(<span class="keyword">const</span> Color: TColor);
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMy3DObjectHelper.Render(<span class="keyword">const</span> Color: TColor);
<span class="keyword">var</span>
  I: Integer;
<span class="keyword">begin</span>
  <span class="comment">{ забележете, че тук достъпваме ShapesCount и Shape без да ги квалифицираме }</span>
  <span class="keyword">for</span> I := <span class="integer">0</span> <span class="keyword">to</span> ShapesCount - <span class="integer">1</span> <span class="keyword">do</span>
    RenderMesh(Shape[I].Mesh, Color);
<span class="keyword">end</span>;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
По-общото понятие е <em>"Помощник за тип"</em>. Чрез тях можете да добавяте методи дори към примитивни типове, като цели числа или enum. Можете също да добавите <em>"помощници за запис"</em> към (познахте&#8230;&#8203;) записи. Вижте <a href="http://lists.freepascal.org/fpc-announce/2013-February/000587.html" class="bare">http://lists.freepascal.org/fpc-announce/2013-February/000587.html</a> .
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_виртуални_конструктори_деструктори">9.8. Виртуални конструктори, деструктори</h3>
<div class="paragraph">
<p>Името на деструктора е винаги <code>Destroy</code>, той е виртуален (защото трябва да се извика по време на изпълнение без да е известен точния клас) и е без параметри.</p>
</div>
<div class="paragraph">
<p>По конвенция името на конструктора е <code>Create</code>.</p>
</div>
<div class="paragraph">
<p>Можете да промените това име, но бъдете внимателни&#8201;&#8212;&#8201;ако дефинирате <code>CreateMy</code>, винаги предефинирайте <code>Create</code>, в противен случай потребителят все още ще може да извика <code>Create</code> на предшественика, заобикаляйки по този начин вашия <code>CreateMy</code> конструктор.</p>
</div>
<div class="paragraph">
<p>В <code>TObject</code> той не е виртуален и когато създавате наследници, можете свободно да променяте параметрите му. Новият конструктор ще скрие конструктора в предшественика (забележка: не поставяйте <code>overload</code>, освен ако не искате да се счупи).</p>
</div>
<div class="paragraph">
<p>В наследниците на <code>TComponent</code> трябва да замените неговия <code>constructor Create(AOwner: TComponent);</code>. При сериализацията, за да създадете клас, без да знаете неговия тип по време на компилиране, наличието на виртуални конструктори е много полезно (виж <a href="#_препратки_към_клас">Препратки към клас</a> по-горе).</p>
</div>
</div>
<div class="sect2">
<h3 id="_изключение_в_конструктор">9.9. Изключение в конструктор</h3>
<div class="paragraph">
<p>Какво се случва, ако възникне изключение по време на изпълнението на конструктор? Редът:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">X := TMyClass.Create;</code></pre>
</div>
</div>
<div class="paragraph">
<p>в този случай не се изпълнява докрай, на <code>X</code> не може да се присвои стойност &#8230;&#8203; кой тогава ще почисти полусъздадената инстанция?</p>
</div>
<div class="paragraph">
<p>Решението в Object Pascal е, че в случай, че възникне изключение в рамките на конструктор, тогава се извиква деструкторът. Това е причина, поради която <em>вашият деструктор трябва да е стабилен</em>, т.е. трябва да работи при всякакви обстоятелства, дори на полусъздадена инстанция на клас. Обикновено това е лесно, ако освобождавате всичко безопасно, като например чрез <code>FreeAndNil</code>.</p>
</div>
<div class="paragraph">
<p>Ние също трябва да разчитаме в такива случаи, че <em>паметта на класа е гарантирано нулирана точно преди кодът на конструктора да бъде изпълнен</em>. Знаем, че в началото всички препратки към клас са <code>nil</code>, всички цели числа са <code>0</code> и така нататък.</p>
</div>
<div class="paragraph">
<p>Така че долното ще работи без изтичане на памет:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils;

<span class="keyword">type</span>
  TGun = <span class="keyword">class</span>
  <span class="keyword">end</span>;

  TPlayer = <span class="keyword">class</span>
    Gun1, Gun2: TGun;
    <span class="keyword">constructor</span> Create;
    <span class="keyword">destructor</span> Destroy; <span class="directive">override</span>;
  <span class="keyword">end</span>;

<span class="keyword">constructor</span> TPlayer.Create;
<span class="keyword">begin</span>
  <span class="keyword">inherited</span>;
  Gun1 := TGun.Create;
  <span class="keyword">raise</span> Exception.Create(<span class="string"><span class="delimiter">'</span><span class="content">Предизвикано изключение от конструктор!</span><span class="delimiter">'</span></span>);
  Gun2 := TGun.Create;
<span class="keyword">end</span>;

<span class="keyword">destructor</span> TPlayer.Destroy;
<span class="keyword">begin</span>
  <span class="comment">{ в случай, че конструктора крашне, бихме могли
    да имаме ситуация с Gun1 &lt;&gt; nil и Gun2 = nil. Справете се с това.
    ... Всъщност в случая FreeAndNil ще се справи без
    допълнителни усилия от наша страна, защото FreeAndNil проверява
    дали инстанцията е nil преди да извика деструктора. }</span>
  FreeAndNil(Gun1);
  FreeAndNil(Gun2);
  <span class="keyword">inherited</span>;
<span class="keyword">end</span>;

<span class="keyword">begin</span>
  <span class="keyword">try</span>
    TPlayer.Create;
  <span class="keyword">except</span>
    <span class="directive">on</span> E: Exception <span class="keyword">do</span>
      WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">Уловено </span><span class="delimiter">'</span></span> + E.ClassName + <span class="string"><span class="delimiter">'</span><span class="content">: </span><span class="delimiter">'</span></span> + E.Message);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_интерфейси">10. Интерфейси</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_голи_corba_интерфейси">10.1. Голи (CORBA) интерфейси</h3>
<div class="paragraph">
<p><em>Интерфейсът</em> декларира набор от методи (API<sup class="footnote" id="_footnote_api">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup>), по подобие на клас, но не дефинира тяхната реализация. Даден клас може да бъде наследник само на един предшестващ клас, но пък може да имплементира много интерфейси.</p>
</div>
<div class="paragraph">
<p>Може да преобразувате типово клас до всеки от интерфейсите, които той имплементира и после да <em>извикате методите през този интерфейс</em>. Това позволява по еднакъв начин да третирате класове, които не произлизат един от друг, но все пак имат някаква обща функционалност. Това е алтернативно решение на множественото наследяване в езика C++.</p>
</div>
<div class="paragraph">
<p><em>CORBA интерфейсите</em> в Обектния Паскал действат много подобно на интерфейсите в Java (<a href="https://docs.oracle.com/javase/tutorial/java/concepts/interface.html" class="bare">https://docs.oracle.com/javase/tutorial/java/concepts/interface.html</a>) или C# (<a href="https://msdn.microsoft.com/en-us/library/ms173156.aspx" class="bare">https://msdn.microsoft.com/en-us/library/ms173156.aspx</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="preprocessor">{$interfaces corba}</span> <span class="comment">// See below why we recommend CORBA interfaces</span>

<span class="keyword">uses</span>
  SysUtils, Classes;

<span class="keyword">type</span>
  IMyInterface = <span class="keyword">interface</span>
  [<span class="string"><span class="delimiter">'</span><span class="content">{79352612-668B-4E8C-910A-26975E103CAC}</span><span class="delimiter">'</span></span>]
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass1 = <span class="keyword">class</span>(IMyInterface)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass2 = <span class="keyword">class</span>(IMyInterface)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass3 = <span class="keyword">class</span>
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass1.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass1.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass2.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass2.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass3.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass3.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> UseThroughInterface(I: IMyInterface);
<span class="keyword">begin</span>
  <span class="directive">Write</span>(<span class="string"><span class="delimiter">'</span><span class="content">Shooting... </span><span class="delimiter">'</span></span>);
  I.Shoot;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C1: TMyClass1;
  C2: TMyClass2;
  C3: TMyClass3;
<span class="keyword">begin</span>
  C1 := TMyClass1.Create;
  C2 := TMyClass2.Create;
  C3 := TMyClass3.Create;
  <span class="keyword">try</span>
    <span class="keyword">if</span> C1 <span class="keyword">is</span> IMyInterface <span class="keyword">then</span>
      UseThroughInterface(C1 <span class="keyword">as</span> IMyInterface);
    <span class="keyword">if</span> C2 <span class="keyword">is</span> IMyInterface <span class="keyword">then</span>
      UseThroughInterface(C2 <span class="keyword">as</span> IMyInterface);
    <span class="comment">// The &quot;C3 is IMyInterface&quot; below is false,</span>
    <span class="comment">// so &quot;UseThroughInterface(C3 as IMyInterface)&quot; will not execute.</span>
    <span class="keyword">if</span> C3 <span class="keyword">is</span> IMyInterface <span class="keyword">then</span>
      UseThroughInterface(C3 <span class="keyword">as</span> IMyInterface);
  <span class="keyword">finally</span>
    FreeAndNil(C1);
    FreeAndNil(C2);
    FreeAndNil(C3);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_интерфейси_corba_и_com">10.2. Интерфейси CORBA и COM</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Защо представените по-горе интерфейси са наречени "CORBA"?</dt>
<dd>
<p>Името <strong>CORBA</strong> е неудачно. По-добро име би било <strong>голи интерфейси</strong>. Тези интерфейси са <em>"`изцяло езикова функционалност`"</em>. Използвайте ги когато искате да приравните различни класове, но искате де да споделят едно и също API.</p>
<div class="paragraph">
<p>Въпреки, че тези интерфейси могат да се използват заедно с <em>технологията CORBA (Common Object Request Broker Architecture)</em> (see <a href="https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture" class="bare">https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture</a>), те <em>не са</em> свързани по никакъв друг начин с нея.</p>
</div>
</dd>
<dt class="hdlist1">Необходима ли е директивата <code>{$interfaces corba}</code>?</dt>
<dd>
<p> Необходима е, защото иначе
се създават <em>COM интерфейси</em>. Това може да се укаже изрично с <code>{$interfaces com}</code>, но обикновено не е необходимо защото това е направено по подразбиране.</p>
<div class="paragraph">
<p>Не препоръчвам да се използват <em>COM интерфейси</em>, особено ако търсите нещо еквивалентно като в други езици. <em>CORBA интерфейсите</em> в Паскал са точно каквото бихте очаквали от интерфейсите в C# или Java. <em>COM интерфейсите</em> от друга страна имат допълнителни възможности, които вероятно не бихте желали в случая.</p>
</div>
<div class="paragraph">
<p>Забележете, че директивата <code>{$interfaces xxx}</code> се отразява само на интерфейсите, които нямат предшественик (само с ключовата дума <code>interface</code> а не <code>interface(ISomeAncestor)</code>, т.е. не са наследили друг интерфейс) Ако интерфейса е наследник на друг интерфейс, той ще бъде от същия тип като предшественика си, независимо от директивата <code>{$interfaces xxx}</code>.</p>
</div>
</dd>
<dt class="hdlist1">Какво е COM интерфейс?</dt>
<dd>
<p><em>COM интерфейс</em> представлява _интерфейс наследяващ специалния интерфейс <code>IUnknown</code> _. Наследяването на <code>IUnknown</code>:</p>
<div class="ulist">
<ul>
<li>
<p>Изисква вашите класове да дефинират методите <code>_AddRef</code> и <code>_ReleaseRef</code>. Правилното имплементиране на тези методи може да управлява жизнения цикъл на вашите обекти с помощта на броене на препратки (reference-counting).</p>
</li>
<li>
<p>Добавя метода <code>QueryInterface</code>.</p>
</li>
<li>
<p>Позволява взаимодействие с  <em>технологията COM (Component Object Model)</em>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Защо не препоръчвам използването на COM интерфейси?</dt>
<dd>
<p>Тъй като <em>COM интерфейсите</em> "съвместяват" две функции, които според мен не бива да са свързани (а "ортогонални"): <em>множествено наследяване</em> и <em>броене на препратки</em>. Други езици за програмиране използват отделни механизми за тези две функции.</p>
<div class="paragraph">
<p>За да бъде ясно: <strong>reference-counting</strong>, което служи за автоматично управление на паметта (в прости ситуации и без цикли), е <strong>много полезна функция</strong>. Но <strong>обвързването и с интерфейсите (вместо да се реализират ортогонално) в моите очи е много неподходящо</strong>. Определено не отговаря на моята практика.</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Понякога ми е нужно да преобразувам някои от моите (несвързани един с друг) класове към общ интерфейс.</p>
</li>
<li>
<p>Понякога ми е нужно автоматично да освобождавам паметта заета от обектите с помощта на броене на препратки.</p>
</li>
<li>
<p><em>Може би</em> някой ден ще ми се прииска да използвам  <em>технологията COM</em>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Но това са различни и несвързани изисквания. Съвместяването им в едно по мое мнение е контра-продуктивно, защото създава следните проблеми:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Ако искам да <em>преобразувам класове към общ API интерфейс</em>, но не искам автоматично да освобождавам паметта на обектите с помощта на броене на препратки (искам да го правя ръчно), тогава <em>COM интерфейсите</em> са проблем. Дори броенето на препратки да се забрани със специални <code>_AddRef</code> и <code>_ReleaseRef</code> реализации, все пак трябва да внимавате никога да не виси временна препратка към интерфейс, след като сте освободили екземпляра на класа. Повече подробности за това в следващия раздел.</p>
</li>
<li>
<p>Ако искам да имам <em>броене на препратки</em>, но нямам нужда от допълнително API към това на класа, тогава трябва да изкопирам декларациите на методи в интерфейси, т.е. да направя по един интерфейс за всеки клас.  Това е е контра-продуктивно. Бих предпочел да имам <em>умни указатели</em> (smart pointers) като отделна езикова функция, която да не е обвързана с интерфейси (тя за щастие идва:).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Ето защо съветвам да използвате <em>CORBA интерфейси</em> и директивата <code>{$interfaces corba}</code> във всички съвременни кодове, които използват интерфейси.</p>
</div>
<div class="paragraph">
<p>Delphi засега има само COM интерфейси, така че трябва да използвате COM интерфейси, ако вашият код трябва да е съвместим с Delphi.</p>
</div>
</dd>
<dt class="hdlist1">Можем ли да имаме броене на препратки с интерфейси CORBA?</dt>
<dd>
<p>Да. Просто добавете методи <code>_AddRef</code> / <code>_ReleaseRef</code>. Няма нужда да се наследява <code>IUnknown</code>. Въпреки че в повечето случаи, ако искате броене на препратки с вашите интерфейси, можете просто да използвате COM интерфейси.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_интерфейсни_guids">10.3. Интерфейсни GUIDs</h3>
<div class="paragraph">
<p>GUID са привидно произволни символни поредици <code>['{ABCD1234-&#8230;&#8203;}']</code>, които виждате поставени във всяка дефиниция на интерфейс. Да, те са случайни и за съжаление са необходими.</p>
</div>
<div class="paragraph">
<p>GUID са без значение, ако не планирате да се интегрирате с технологии като <em>COM</em> или <em>CORBA</em>. Но те са необходими за правилното изпълнение. Не се заблуждавайте от компилатора, който за съжаление ви позволява да декларирате интерфейси без GUID.</p>
</div>
<div class="paragraph">
<p>Без (уникалните) GUID, вашите интерфейси ще бъдат третирани еднакво от оператора <code>is</code>. В действителност, той ще върне <code>true</code>, ако вашият клас поддържа <em>който и да е</em> от вашите интерфейси. Магическата функция <code>Supports(ObjectInstance, IMyInterface)</code> се държи малко по-добре, тъй като отказва да бъде компилирана за интерфейси без GUID. Това важи както за интерфейсите CORBA, така и за COM, от FPC 3.0.0.</p>
</div>
<div class="paragraph">
<p>Така че, за да сте сигурни, винаги трябва да декларирате GUID за вашия интерфейс. Можете да използвате <em>Lazarus</em> генератора на GUID (натиснете <code>Ctrl + Shift + G</code> в редактора). Или можете да използвате онлайн услуга като <a href="https://www.guidgenerator.com/" class="bare">https://www.guidgenerator.com/</a> .</p>
</div>
<div class="paragraph">
<p>Или можете да напишете свой собствен инструмент за това, като използвате функциите <code>CreateGUID</code> и <code>GUIDToString</code> в RTL. Вижте примера по-долу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="keyword">uses</span>
  SysUtils;
<span class="keyword">var</span>
  MyGuid: TGUID;
<span class="keyword">begin</span>
  Randomize;
  CreateGUID(MyGuid);
  WriteLn(<span class="char"><span class="delimiter">'</span><span class="content">[</span><span class="delimiter">'</span></span><span class="string"><span class="delimiter">'</span><span class="delimiter">'</span></span> + GUIDToString(MyGuid) + <span class="string"><span class="delimiter">'</span><span class="char">''</span><span class="content">]</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_интерфейси_с_броене_на_препратки_com">10.4. Интерфейси с броене на препратки (COM)</h3>
<div class="paragraph">
<p><em>COM интерфейсите</em> добавят две допълнителни функции:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>интеграция с COM (технология от Windows, достъпна и на Unix чрез <em>XPCOM</em>, използвана от Mozilla),</p>
</li>
<li>
<p>броене на препратки (което води до автоматично унищожаване, когато всички препратки към интерфейса излязат от обхват).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Когато използвате <em>COM интерфейси</em>, трябва да сте наясно с техния механизъм за <em>автоматично унищожаване</em> и връзката им с COM технологията.</p>
</div>
<div class="paragraph">
<p>На практика това означава, че:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Вашият клас трябва да имплементира магическите методи <code>_AddRef</code>, <code>_Release</code> и <code>QueryInterface</code>. Или да наследи нещо, което вече ги е имплементирало. Конкретно изпълнение на тези методи може на практика да активира или деактивира функцията <em>reference-counting</em> на COM интерфейсите (въпреки че деактивирането й е донякъде опасно - вижте следващата точка).</p>
<div class="ulist">
<ul>
<li>
<p>Стандартният клас <code>TInterfacedObject</code> имплементира тези методи за да <em>разреши</em> преброяването на препратки.</p>
</li>
<li>
<p>Стандартният клас <code>TComponent</code> имплементира тези методи за да <em>забрани</em> преброяването на препратки. В <strong>Castle Game Engine</strong> ние ви даваме допълнителните полезни класове за наследяване <code>TNonRefCountedInterfacedObject</code> и <code>TNonRefCountedInterfacedPersistent</code> за тази цел, вижте <a href="https://github.com/castle-engine/castle-engine/blob/0519585abc13e8386cdae5f7dfef6f9659dc9b57/src/base/castleinterfaces.pas" class="bare">https://github.com/castle-engine/castle-engine/blob/0519585abc13e8386cdae5f7dfef6f9659dc9b57/src/base/castleinterfaces.pas</a> .</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="ulist">
<ul>
<li>
<p>Трябва да внимавате да не освобождавате класа, когато той може да бъде сочен от някои интерфейсни променливи. Понеже интерфейсът се освобождава с помощта на виртуален метод (тъй като <em>може да бъде reference-counted, дори и при хакнат метод _AddRef за да не се брои&#8230;&#8203;</em>), не можете да освободите основния екземпляр на обекта, докато някаква интерфейсна променлива сочи към него. Вижте <em>"7.7 Броене на препратки"</em> в ръководството на FPC (<a href="http://freepascal.org/docs-html/ref/refse47.html" class="bare">http://freepascal.org/docs-html/ref/refse47.html</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Най-безопасният подход за използване на <em>COM интерфейси</em> е:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>да приемете факта, че са reference-counted,</p>
</li>
<li>
<p>да наследите подходящите класове от <code>TInterfacedObject</code>,</p>
</li>
<li>
<p>и да избягвате използването на истинския екземпляра на класа, вместо това винаги осъществявайте достъп до екземпляра през интерфейс, оставяйки броенето на референции да извърши освобождаването.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Това е пример за използване на такъв интерфейс:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="preprocessor">{$interfaces com}</span>

<span class="keyword">uses</span>
  SysUtils, Classes;

<span class="keyword">type</span>
  IMyInterface = <span class="keyword">interface</span>
  [<span class="string"><span class="delimiter">'</span><span class="content">{3075FFCD-8EFB-4E98-B157-261448B8D92E}</span><span class="delimiter">'</span></span>]
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass1 = <span class="keyword">class</span>(TInterfacedObject, IMyInterface)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass2 = <span class="keyword">class</span>(TInterfacedObject, IMyInterface)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass3 = <span class="keyword">class</span>(TInterfacedObject)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass1.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass1.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass2.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass2.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass3.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass3.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> UseThroughInterface(I: IMyInterface);
<span class="keyword">begin</span>
  <span class="directive">Write</span>(<span class="string"><span class="delimiter">'</span><span class="content">Shooting... </span><span class="delimiter">'</span></span>);
  I.Shoot;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C1: IMyInterface;  <span class="comment">// COM се грижи за унищожаването</span>
  C2: IMyInterface;  <span class="comment">// COM се грижи за унищожаването</span>
  C3: TMyClass3;     <span class="comment">// ВИЕ трябва да се погрижите за унищожаването</span>
<span class="keyword">begin</span>
  C1 := TMyClass1.Create <span class="keyword">as</span> IMyInterface;
  C2 := TMyClass2.Create <span class="keyword">as</span> IMyInterface;
  C3 := TMyClass3.Create;
  <span class="keyword">try</span>
    UseThroughInterface(C1); <span class="comment">// няма нужда от оператор &quot;as&quot;</span>
    UseThroughInterface(C2);
    <span class="keyword">if</span> C3 <span class="keyword">is</span> IMyInterface <span class="keyword">then</span>
      UseThroughInterface(C3 <span class="keyword">as</span> IMyInterface); <span class="comment">// това няма да се изпълни</span>
  <span class="keyword">finally</span>
    <span class="comment">{ Променливи C1 и C2 излизат от обхват и тук би трябвало да се 
      унищожат автоматично.

      За разлика от тях, C3 е инстанция, която не се управлява от интерфейс
      и трябва да се унищожи ръчно. }</span>
    FreeAndNil(C3);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_използване_на_com_интерфейси_с_изключено_броене">10.5. Използване на COM интерфейси с изключено броене</h3>
<div class="paragraph">
<p>Както бе споменато в предишния раздел, вашият клас може да произхожда от <code>TComponent</code> (или подобен клас като <code>TNonRefCountedInterfacedObject</code> и <code>TNonRefCountedInterfacedPersistent</code>), който деактивира броенето на препратки за COM интерфейси. Това ви позволява да използвате тези интерфейси и въпреки това да освободите екземпляра на класа ръчно.</p>
</div>
<div class="paragraph">
<p>Трябва да внимавате в този случай да не освободите екземпляра на класа, когато някаква интерфейсна променлива сочи към него. Запомнете, че всеки typecast <code>Cx as IMyInterface</code> също създава временна интерфейсна променлива, която може да присъства дори до края на текущата процедура. Поради тази причина примерът по-долу използва процедура <code>UseInterfaces</code> и освобождава екземплярите на класа <em>извън</em> на тази процедура (когато можем да сме сигурни, че временните интерфейсни променливи са извън обхвата).</p>
</div>
<div class="paragraph">
<p>За да избегнете тази бъркотия, обикновено е по-добре да използвате CORBA интерфейси, ако не e нужно да броите препратки.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>
<span class="preprocessor">{$interfaces com}</span>

<span class="keyword">uses</span>
  SysUtils, Classes;

<span class="keyword">type</span>
  IMyInterface = <span class="keyword">interface</span>
  [<span class="string"><span class="delimiter">'</span><span class="content">{3075FFCD-8EFB-4E98-B157-261448B8D92E}</span><span class="delimiter">'</span></span>]
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass1 = <span class="keyword">class</span>(TComponent, IMyInterface)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass2 = <span class="keyword">class</span>(TComponent, IMyInterface)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

  TMyClass3 = <span class="keyword">class</span>(TComponent)
    <span class="keyword">procedure</span> Shoot;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass1.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass1.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass2.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass2.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass3.Shoot;
<span class="keyword">begin</span>
  WriteLn(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass3.Shoot</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> UseThroughInterface(I: IMyInterface);
<span class="keyword">begin</span>
  <span class="directive">Write</span>(<span class="string"><span class="delimiter">'</span><span class="content">Shooting... </span><span class="delimiter">'</span></span>);
  I.Shoot;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  C1: TMyClass1;
  C2: TMyClass2;
  C3: TMyClass3;

<span class="keyword">procedure</span> UseInterfaces;
<span class="keyword">begin</span>
  <span class="keyword">if</span> C1 <span class="keyword">is</span> IMyInterface <span class="keyword">then</span>
  <span class="comment">//if Supports(C1, IMyInterface) then // equivalent to &quot;is&quot; check above</span>
    UseThroughInterface(C1 <span class="keyword">as</span> IMyInterface);
  <span class="keyword">if</span> C2 <span class="keyword">is</span> IMyInterface <span class="keyword">then</span>
    UseThroughInterface(C2 <span class="keyword">as</span> IMyInterface);
  <span class="keyword">if</span> C3 <span class="keyword">is</span> IMyInterface <span class="keyword">then</span>
    UseThroughInterface(C3 <span class="keyword">as</span> IMyInterface);
<span class="keyword">end</span>;

<span class="keyword">begin</span>
  C1 := TMyClass1.Create(<span class="keyword">nil</span>);
  C2 := TMyClass2.Create(<span class="keyword">nil</span>);
  C3 := TMyClass3.Create(<span class="keyword">nil</span>);
  <span class="keyword">try</span>
    UseInterfaces;
  <span class="keyword">finally</span>
    FreeAndNil(C1);
    FreeAndNil(C2);
    FreeAndNil(C3);
  <span class="keyword">end</span>;
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_преобразуване_на_интерфейси">10.6. Преобразуване на интерфейси</h3>
<div class="paragraph">
<p>Този раздел се отнася както за интерфейсите <em>CORBA</em>, така и за <em>COM</em> (все пак има някои изрични изключения за CORBA).</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Прехвърлянето към тип интерфейс с помощта на оператора <code>as</code> прави проверка по време на изпълнение. Разгледайте следния код:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">UseThroughInterface(Cx <span class="keyword">as</span> IMyInterface);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Работи за всички случаи на <code>C1</code>, <code>C2</code>, <code>C3</code> в примерите в предишните раздели. Ако се изпълни, това ще доведе до грешка по време на изпълнение в случая на <code>C3</code>, който не имплементира <code>IMyInterface</code>.</p>
</div>
<div class="paragraph">
<p>Използването на оператор <code>as</code> работи правилно, независимо дали <code>Cx</code> е деклариран като екземпляр на клас (като <code>TMyClass2</code>) или интерфейс (като <code>IMyInterface2</code>).</p>
</div>
<div class="paragraph">
<p>Това обаче не е разрешено за CORBA интерфейси.</p>
</div>
</li>
<li>
<p>Вместо това можете изрично да конвертирате екземпляра до интерфейс:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">UseThroughInterface(Cx);</code></pre>
</div>
</div>
<div class="paragraph">
<p>В този случай конверсията трябва да е валидна по време на компилация. Така че това ще се компилира за <code>C1</code> и <code>C2</code> (които са декларирани като класове, които имплементират <code>IMyInterface</code>). Но няма да се компилира за <code>C3</code>.</p>
</div>
<div class="paragraph">
<p>По същество тaзи конверсия изглежда и работи точно както и за обикновени класове. Където и да е необходим екземпляр на клас <code>TMyClass</code>, винаги можете да използвате там променлива, която е декларирана с клас на <code>TMyClass</code>, <strong>или <code>TMyClass</code> потомък</strong>. Същото правило важи и за интерфейсите. Няма нужда от изрично преобразуване на типа в такива ситуации.</p>
</div>
</li>
<li>
<p>Можете също така да използвате <code>IMyInterface(Cx)</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal">UseThroughInterface(IMyInterface(Cx));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обикновено такъв синтаксис за преобразуване на типове показва <em>опасно, непроверено</em> преобразуване на типове. Ще се случат лоши неща, ако конвертирате към неправилен интерфейс. И това е вярно, ако преобразувате <em>клас към клас</em> или <em>интерфейс към интерфейс</em>, използвайки този синтаксис.</p>
</div>
<div class="paragraph">
<p>Тук има малко изключение: ако <code>Cx</code> е деклариран като клас (като <code>TMyClass2</code>), тогава това е тип, който трябва да е валиден по време на компилация. Така че прехвърлянето на <em>на клас към интерфейс</em> по този начин е безопасно, бързо (проверено по време на компилиране) преобразуване на типа.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>За да тествате всичко това, поиграйте си с този примерен код:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="pascal"><span class="preprocessor">{$mode objfpc}</span><span class="preprocessor">{$H+}</span><span class="preprocessor">{$J-}</span>

<span class="comment">// {$interfaces corba} // забележете, че &quot;as&quot; конверсии за CORBA няма да се компилират</span>

<span class="keyword">uses</span> Classes;

<span class="keyword">type</span>
  IMyInterface = <span class="keyword">interface</span>
  [<span class="string"><span class="delimiter">'</span><span class="content">{7FC754BC-9CA7-4399-B947-D37DD30BA90A}</span><span class="delimiter">'</span></span>]
    <span class="keyword">procedure</span> One;
  <span class="keyword">end</span>;

  IMyInterface2 = <span class="keyword">interface</span>(IMyInterface)
  [<span class="string"><span class="delimiter">'</span><span class="content">{A72B7008-3F90-45C1-8F4C-E77C4302AA3E}</span><span class="delimiter">'</span></span>]
    <span class="keyword">procedure</span> Two;
  <span class="keyword">end</span>;

  IMyInterface3 = <span class="keyword">interface</span>(IMyInterface2)
  [<span class="string"><span class="delimiter">'</span><span class="content">{924BFB98-B049-4945-AF17-1DB08DB1C0C5}</span><span class="delimiter">'</span></span>]
    <span class="keyword">procedure</span> Three;
  <span class="keyword">end</span>;

  TMyClass = <span class="keyword">class</span>(TComponent, IMyInterface)
    <span class="keyword">procedure</span> One;
  <span class="keyword">end</span>;

  TMyClass2 = <span class="keyword">class</span>(TMyClass, IMyInterface, IMyInterface2)
    <span class="keyword">procedure</span> One;
    <span class="keyword">procedure</span> Two;
  <span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass.One;
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass.One</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass2.One;
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass2.One</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> TMyClass2.Two;
<span class="keyword">begin</span>
  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">TMyClass2.Two</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>;

<span class="keyword">procedure</span> UseInterface2(<span class="keyword">const</span> I: IMyInterface2);
<span class="keyword">begin</span>
  I.One;
  I.Two;
<span class="keyword">end</span>;

<span class="keyword">procedure</span> UseInterface3(<span class="keyword">const</span> I: IMyInterface3);
<span class="keyword">begin</span>
  I.One;
  I.Two;
  I.Three;
<span class="keyword">end</span>;

<span class="keyword">var</span>
  My: IMyInterface;
  MyClass: TMyClass;
<span class="keyword">begin</span>
  My := TMyClass2.Create(<span class="keyword">nil</span>);
  MyClass := TMyClass2.Create(<span class="keyword">nil</span>);

  <span class="comment">// Това не може да с компилира, не е известно дали My е IMyInterface2.</span>
  <span class="comment">// UseInterface2(My);</span>
  <span class="comment">// UseInterface2(MyClass);</span>

  <span class="comment">// Това се компилира и работи.</span>
  UseInterface2(IMyInterface2(My));
  <span class="comment">// Това не може да с компилира. Преобразуването InterfaceType(ClassType) се проверява при компилация.</span>
  <span class="comment">// UseInterface2(IMyInterface2(MyClass));</span>

  <span class="comment">// Това се компилира и работи.</span>
  UseInterface2(My <span class="keyword">as</span> IMyInterface2);
  <span class="comment">// Това се компилира и работи.</span>
  UseInterface2(MyClass <span class="keyword">as</span> IMyInterface2);

  <span class="comment">// Това се компилира но не работи при изпълнение, с грозно &quot;Access violation&quot;.</span>
  <span class="comment">// UseInterface3(IMyInterface3(My));</span>
  <span class="comment">// Това не може да с компилира. Преобразуването InterfaceType(ClassType) се проверява при компилация.</span>
  <span class="comment">// UseInterface3(IMyInterface3(MyClass));</span>

  <span class="comment">// Това се компилира но не работи при изпълнение, с хубаво &quot;EInvalidCast: Invalid type cast&quot;.</span>
  <span class="comment">// UseInterface3(My as IMyInterface3);</span>
  <span class="comment">// Това се компилира но не работи при изпълнение, с хубаво &quot;EInvalidCast: Invalid type cast&quot;.</span>
  <span class="comment">// UseInterface3(MyClass as IMyInterface3);</span>

  Writeln(<span class="string"><span class="delimiter">'</span><span class="content">Край</span><span class="delimiter">'</span></span>);
<span class="keyword">end</span>.</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_относно_този_документ">11. Относно този документ</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Copyright Michalis Kamburelis.</p>
</div>
<div class="paragraph">
<p>Изходният код на този документ е във формат AsciiDoc на <a href="https://github.com/michaliskambi/modern-pascal-introduction" class="bare">https://github.com/michaliskambi/modern-pascal-introduction</a>. Предложения за корекции и допълнения, кръпки и заявки за изтегляне са винаги добре дошли:) Можете да се свържете с мен чрез GitHub или да изпратите имейл на <a href="mailto:michalis@castle-engine.io">michalis@castle-engine.io</a>. Моята WEB страница е <a href="https://michalis.xyz/" class="bare">https://michalis.xyz/</a>. Този документ е свързан в секция <em>Documentation</em> на <em>Castle Game Engine</em> website <a href="https://castle-engine.io/" class="bare">https://castle-engine.io/</a>.</p>
</div>
<div class="paragraph">
<p>Можете да разпространявате и дори да променяте този документ свободно, под същите лицензи като Wikipedia <a href="https://en.wikipedia.org/wiki/Wikipedia:Copyrights" class="bare">https://en.wikipedia.org/wiki/Wikipedia:Copyrights</a> :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Creative Commons Attribution-ShareAlike 3.0 Unported License (CC BY-SA)</em></p>
</li>
<li>
<p>or the <em>GNU Free Documentation License (GFDL) (unversioned, with no invariant sections, front-cover texts, or back-cover texts)</em> .</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Thank you for reading!</p>
</div>
<div class="paragraph">
<p>Превод на Български език:
Юлиян Иванов, 2023</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. модул = Unit
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. генерици = Generics
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. интерфейс = Interface
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. "опаковъчни" функции = wrappers
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. речник = Dictionary, a.k.a. Associative array
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. приятели = friends
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. API = Application Program Interface
</div>
</div>
<div id="footer">
<div id="footer-text">
Последно обновен 2024-07-30 11:58:08 +0200
</div>
</div>
<!-- Google analytics -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-6792759-1");
pageTracker._trackPageview();
} catch(err) {}</script>

<!-- Piwik -->
<a href="http://piwik.org" title="Web analytics" onclick="window.open(this.href);return(false);">
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://michalis.xyz/piwik/" : "http://michalis.xyz/piwik/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
piwik_action_name = '';
piwik_idsite = 1;
piwik_url = pkBaseURL + "piwik.php";
piwik_log(piwik_action_name, piwik_idsite, piwik_url);
</script>
<object><noscript><p>Web analytics <img src="http://michalis.xyz/piwik/piwik.php?idsite=1" style="border:0" alt=""/></p></noscript></object></a>
<!-- End Piwik Tag -->
</body>
</html>