# User Interface
include::common.adoc[]

## Introduction

_Castle Game Engine_ features a number of user interface (2D) controls. You can build a complete user interface in the _CGE editor_, you can also build and modify the whole UI using our Pascal API. Our UI controls have parents, anchoring, UI scaling. If you set the anchors right, our UI will _"just work"_ at various screen resolutions, aspect ratios and platforms, and can seamlessly adjust to any desktop or mobile screen.

As an example, take a look at this design that is used for our inspector (see the https://www.youtube.com/watch?v=5jBdPdj75yk[Inspector invoked by F8] movie). Coupled with the right code, this design implements a non-trivial UI with toggable panels, scrollable list box, minimal scrollable object inspector, custom-drawn profiler and more.

cgeimg::block[inspector_design.png|Inspector UI,inspector_running.png|Inspector visible at runtime]

## Usage

The basic usage of UI controls inside the _CGE editor_ is explained in the chapter link:manual_state_events.php[Designing user interface and handling events (press, update) within the state]. It shows how to use cgeref:TCastleImageControl[] -- but the workflow shown there applies to all other UI controls too. It comes down to:

- Using _"Add User Interface"_ menu item in the _CGE editor_ to choose a component. It will be added to the state. It's usually most comfortable to use _"Add User Interface"_ by right-clicking on the parent component in the editor hierarchy.

- After adding, you want to adjust basic component properties, like `Name`, position and size.

- To access the component from code, you add to your state `Start` method a line like `MyLabel := DesignedComponent('MyLabel') as TCastleLabel` and at any other place you can modify this component, like `MyLabel.Caption := 'something'`.

## Available user interface controls

In general, all the descendants of cgeref:TCastleUserInterface[] defined in the engine are UI controls. This page lists the most important ones.

See the https://github.com/castle-engine/castle-engine/tree/master/examples/component_gallery[component_gallery] demo for a showcase of our most important components. You can run that example and explore its UI designs in _CGE editor_.

### Empty Rectangle (base TCastleUserInterface)

cgeref:TCastleUserInterface[] is a base UI class. It is an ancestor of all other UI classes, and as such implements common features like anchors and borders. It can be used directly too -- will serve as a good parent, to organize a number of children controls or surround them with a visual frame.

cgeimg::block[ui_empty_rectangle.png|Empty rectangles]

### Color Rectangles

cgeref:TCastleRectangleControl[] is a rectangle filled with simple RGBA color. Its most important property is cgeref:TCastleRectangleControl.Color[].

cgeimg::block[ui_color_rectangle.png|Color rectangles]

### Label

cgeref:TCastleLabel[] is the simplest way to display text in our engine. Its most important property is cgeref:TCastleLabel.Caption[] (or, if you want access the multi-line string list, cgeref:TCastleLabel.Text[]).

cgeimg::block[ui_label.png|Labels]

### Button

cgeref:TCastleButton[] is a clickable UI element. The look can be incredibly customized to match the style of your game. Its most important properties are cgeref:TCastleButton.Caption[] and (assign here your event, in code) cgeref:TCastleButton.OnClick[].

cgeimg::block[ui_button_1.png|Buttons,ui_button_2.png|Buttons]

### Image

cgeref:TCastleImageControl[] displays an image. It can be scaled, preserving the aspect ratio or ignoring the aspect ratio, if needed. Its most important property is cgeref:TCastleImageControl.URL[].

### Checkbox

cgeref:TCastleCheckbox[] allows user to check/uncheck a checkbox, to make a Boolean choice. Its most important properties are cgeref:TCastleCheckbox.Caption[] and (assign here your event, in code) cgeref:TCastleCheckbox.Checked[].

### Edit (text, integer, float)

cgeref:TCastleEdit[] allows to edit a single-line text. Its most important property is cgeref:TCastleEdit.Text[].

It has simple descendants cgeref:TCastleIntegerEdit[] and cgeref:TCastleFloatEdit[] to edit numbers. Their most important properties are, respectively, cgeref:TCastleIntegerEdit.Value[] and cgeref:TCastleFloatEdit.Value[].

### Group (horizontal, vertical)

cgeref:TCastleHorizontalGroup[] and cgeref:TCastleVerticalGroup[] automatically layout their controls in a horizontal and vertical fashion.

### Scroll view

cgeref:TCastleScrollView[] allows to scroll a large (tall) area with a vertical scrollbar. Its most important property is cgeref:TCastleScrollView.ScrollArea[], this is where you should add children that should scroll.

### Shape

cgeref:TCastleShape[] displays since shapes, like circles.


////
TODO

<?php
require_once 'castle_engine_functions.php';
castle_header('User interface, standard controls, viewports', array(
  'social_share_image' => 'zombie_fighter_0.png',
));

$toc = new TableOfContents(
  array(
    new TocItem('Introduction', 'introduction'),
    new TocItem('Using the 2D controls', 'usage'),
    new TocItem('Parents and anchors', 'parents_and_anchors'),
    new TocItem('User-interface scaling (Container.UIScaling)', 'scaling'),
    new TocItem('Query sizes', 'sizes'),
    new TocItem('Adjust theme', 'theme'),
    new TocItem('Adjust loading image', 'loading_image', 1),
    new TocItem('Taking control of the viewport', 'viewport'),
    new TocItem('Insert animation (in a viewport) into a button', 'button_with_viewport', 1),
    new TocItem('Wrapping it up (in a custom TCastleUserInterface descendant)', 'wrapping'),
  )
);
?>

<p>Using our engine you can create nice user-interface for your applications.
The look and behavior of everything is very customizable,
as you often want a special-looking UI in your games.
Our user-interface is rendered inside a container like
<?php api_link('TCastleWindowBase', 'CastleWindow.TCastleWindowBase.html'); ?> or
<?php api_link('TCastleControlBase', 'CastleControl.TCastleControlBase.html'); ?>,
and of course works without any modifications on all the platforms
we support &mdash; desktop, mobile...

<!-- It's appearance and behavior is very customizable,
as you often want a custom-looking UI in your games. -->

<p><b>A complete program using the concepts shown here is in the engine
examples</b>, in the <code>examples/user_interface/zombie_fighter/</code>
directory.</p>

<?php
echo castle_thumbs(array(
  array('filename' => 'zombie_fighter_0.png', 'titlealt' => 'Dialog box composed from simple UI elements'),
  //array('filename' => 'two_viewports.png', 'titlealt' => 'Two viewports'),
  //array('filename' => 'view3dscene_viewports.png', 'titlealt' => 'Multiple viewports with a DOOM level in view3dscene'),
  array('filename' => 'button_with_2d_scene_manager.png', 'titlealt' => '2D animated scene inside a button'),
  //array('filename' => 'zombie_fighter_1.png', 'titlealt' => 'Multiple viewports and basic game UI'),
  array('filename' => 'zombie_fighter_2.png', 'titlealt' => 'UI dialog, in a state over the game UI'),
), 'auto', 'left');
?>

<?php echo $toc->html_toc(); ?>

<?php echo $toc->html_section(); ?>

<p>Our game window is covered by <i>2D user-interface controls</i>.
All of the classes representing a user-interface control descend from
the <?php api_link('TCastleUserInterface', 'CastleUIControls.TCastleUserInterface.html'); ?> class.
They can render, they can handle inputs, they can perform any time-dependent task, and much more.

<p>All of the currently used controls are added to the list of
<?php api_link('TCastleWindowBase.Controls', 'CastleWindow.TCastleWindowBase.html#Controls'); ?>
 (if you use <?php api_link('TCastleWindowBase', 'CastleWindow.TCastleWindowBase.html'); ?>) or
<?php api_link('TCastleControlBase.Controls', 'CastleControl.TCastleControlBase.html#Controls'); ?>
 (if you use Lazarus forms with <?php api_link('TCastleControlBase', 'CastleControl.TCastleControlBase.html'); ?>).
The controls on this list are ordered from the back to front. But usually you don't need to remember that,
as you add them using the aptly-named methods
<?php api_link('InsertFront', 'CastleUIControls.TChildrenControls.html#InsertFront'); ?> or
<?php api_link('InsertBack', 'CastleUIControls.TChildrenControls.html#InsertBack'); ?>,
indicating the visual "front" (<i>in front of other controls</i>) or "back".
The <?php api_link('TCastleUserInterface', 'CastleUIControls.TCastleUserInterface.html'); ?> can be arranged
 in hierarchy: one instance of <?php api_link('TCastleUserInterface', 'CastleUIControls.TCastleUserInterface.html'); ?>
 can be a child of another, which makes it visually "contained" inside the parent,
and moved along with parent.

<p>Note that you can also render and handle inputs using the
<?php api_link('TCastleWindowBase', 'CastleWindow.TCastleWindowBase.html'); ?> or
<?php api_link('TCastleControlBase', 'CastleControl.TCastleControlBase.html'); ?> callbacks,
like <?php api_link('Window.OnRender', 'CastleWindow.TCastleWindowBase.html#OnRender'); ?>,
<?php api_link('Window.OnPress', 'CastleWindow.TCastleWindowBase.html#OnPress'); ?> and
<?php api_link('Window.OnUpdate', 'CastleWindow.TCastleWindowBase.html#OnUpdate'); ?>.
But usually most of your rendering and input handling should be done inside some
<?php api_link('TCastleUserInterface', 'CastleUIControls.TCastleUserInterface.html'); ?>
 descendant, most importantly inside
 <?php api_link('TIUState', 'CastleUIState.TUIState.html'); ?> descendant
 (<code>TUIState</code> descends from <code>TCastleUserInterface</code>).

<p>Note that <?php api_link('TCastleViewport', 'CastleViewport.TCastleViewport.html'); ?>
 is also a descendant of <?php api_link('TCastleUserInterface', 'CastleUIControls.TCastleUserInterface.html'); ?>.
 So the organization follows what you see:
 inside a 2D window, you create a 2D viewport, that allows to view the 3D world inside.
So, almost everything is "inside" some <?php api_link('TCastleUserInterface', 'CastleUIControls.TCastleUserInterface.html'); ?>
 in our engine.<!--, and we advice you to follow this approach when creating your own games.-->

<p>While <?php api_link('TCastleUserInterface', 'CastleUIControls.TCastleUserInterface.html'); ?> is basically
 a way to render <i>anything</i>, in this chapter we will focus on the most traditional
use of this class: to create simple 2D user interfaces. Our engine includes a large number of
<?php api_link('TCastleUserInterface', 'CastleUIControls.TCastleUserInterface.html'); ?> descendants for this. The most
often used controls are:

<ul>
  <li><?php api_link('TCastleLabel', 'CastleControls.TCastleLabel.html'); ?> - Label with text. As with all our text controls, the font family and size is customizable (see <a href="manual_text.php">chapter about text</a>). May have a frame. May be multiline. May contain some <?php api_link('HTML tags', 'CastleControls.TCastleLabel.html#Html'); ?>.</li>

  <li><?php api_link('TCastleButton', 'CastleControls.TCastleButton.html'); ?> - Clickable button. The look is highly configurable with custom images and tint colors. May contain an icon inside (actually, by inserting other UI controls as children, it may contain <i>anything</i> inside). The size may be automatically adjusted to the inside caption (and icon), or may be explicitly given.</li>

  <li><?php api_link('TCastleImageControl', 'CastleControls.TCastleImageControl.html'); ?> - Image. May stretch the content, or adjust to the content size. Image may be partially transparent, with blending or alpha-testing. Image can be rotated or clipped by an arbitrary line. Image may be "tinted" (multiplied) by given color. Underneath, the image is a full-featured <?php api_link('TCastleImage', 'CastleImages.TCastleImage.html'); ?>, so you can process it in a myriad of ways.<!--, and load from a myriad sources (e.g. you can load here a dynamically generated <a href="">screenshot, not only an image file).--></li>

  <li><?php api_link('TCastleRectangleControl', 'CastleControls.TCastleRectangleControl.html'); ?> - Rectangle filled with solid color. Good for a general-purpose background. The color may be partially transparent, in which case the content underneath is still visible.</li>

  <li><?php api_link('TCastleUserInterface', 'CastleUIControls.TCastleUserInterface.html'); ?> itself is also very useful - General-purpose container (or ancestor) for other UI controls. Does not do or show anything by itself, but it has a configurable position and size.</li>
</ul>

<p>These are just the basic UI classes. Find the <code>TCastleUserInterface</code> in our <?php api_link('class hierarchy', 'ClassHierarchy.html'); ?> diagram and look at all it's descendants to discover more:)

<?php echo $toc->html_section(); ?>

<p>You simply create an instance of any class you like, and add it as a children
of <?php api_link('Window.Controls', 'CastleWindow.TCastleWindowBase.html#Controls'); ?>,
 <?php api_link('CastleControl.Controls', 'CastleControl.TCastleControlBase.html#Controls'); ?>
 or another (parent) <?php api_link('TCastleUserInterface', 'CastleUIControls.TCastleUserInterface.html'); ?>.
 Note that <?php api_link('TCastleUserInterface', 'CastleUIControls.TCastleUserInterface.html'); ?> is a descendant
 of the standard <code>TComponent</code> property, so you can use the standard "ownership"
mechanism to take care of freeing the UI control. In simple cases, you can make the <code>Application</code>
or <code>Window</code> a parent of your UI control.

<p>An example below shows a simple button and a label:

<?php echo pascal_highlight_file('code-samples/standard_2d_ui.lpr'); ?>

<p>Remember that at any time, you can add and remove the controls.
You can also make a control temporarily "not existing"
(not visible, not handling inputs and so on &mdash;
just like it would not be present on the controls list at all) by flipping it's
<?php api_link('Exists', 'CastleUIControls.TCastleUserInterface.html#Exists'); ?>
 property.

<p>Here's the previous example expanded, showing how to handle button click,
to toggle the visibility of a rectangle:

<?php echo pascal_highlight_file('code-samples/standard_2d_ui_toggle_exists.lpr'); ?>

<?php echo $toc->html_section(); ?>

<?php
echo castle_thumbs(array(
  array('filename' => 'zombie_fighter_0.png', 'titlealt' => 'Dialog box composed from simple UI elements'),
));
?>

<p>Every UI control may have children, which are positioned relative to their parent.
The children are always drawn on top of their parent.
(Although the parent has an additional chance to draw over the children in it's
<?php api_link('RenderOverChildren', 'CastleUIControls.TCastleUserInterface.html#RenderOverChildren'); ?> method, but that's rarely used.)

<ul>
  <li><p>The <b>children receive input events (key and mouse presses) before their parent</b>.
    So the innermost children get the first chance to process an event
    (like a click), and only if they do not handle it (their
    <?php api_link('Press', 'CastleUIControls.TInputListener.html#Press'); ?> method will return <code>false</code>)
    then the event is passed to the parent. If no UI control processes a press event,
    it is passed to the
    <?php api_link('TCastleWindowBase.OnPress', 'CastleWindow.TCastleWindowBase.html#OnPress'); ?> or
    <?php api_link('TCastleControlBase.OnPress', 'CastleControl.TCastleControlBase.html#OnPress'); ?>.

    <p>Note that the <b>input events are only send to the controls under the pointer</b>
    (mouse or touch position). Although this is configurable using
    the <?php api_link('CapturesEventsAtPosition', 'CastleUIControls.TCastleUserInterface.html#CapturesEventsAtPosition'); ?>
     method, but usually it's saner to leave it at default.
    A useful trick to capture the events from the whole window is to use a
    <?php api_link('TCastleUserInterface', 'CastleUIControls.TCastleUserInterface.html'); ?>
     with
    <?php api_link('FullSize', 'CastleUIControls.TCastleUserInterface.html#FullSize'); ?>
     = <code>true</code>, this will capture mouse clicks and key presses from everything.

  <li><p><b>Any control can be a parent</b>. For example, you can insert arbitrary images and labels
    inside a <?php api_link('TCastleButton', 'CastleControls.TCastleButton.html'); ?>, to make it's content look in any way you want.
    If you want to group a couple of controls, but don't have a natural "parent" control,
    it's often a good idea to use a new instance of an
    <?php api_link('TCastleUserInterface', 'CastleUIControls.TCastleUserInterface.html'); ?>
     as a parent.

  <li><p><b>Controls are positioned relative to the parent</b>, using just the
    <?php api_link('Left', 'CastleUIControls.TCastleUserInterface.html#Left'); ?> and
    <?php api_link('Bottom', 'CastleUIControls.TCastleUserInterface.html#Bottom'); ?> properties
    by default. Remember that our engine in 2D uses a coordinate system
    where the Y grows from zero (bottom) to maximum height (at the top).
    This is contrary to a convention of various GUI libraries that designate <code>Top</code> as zero,
    and make Y grow downward. We decided to follow the convention <i>Y grows up</i>
    for a couple of reasons, mostly because it naturally matches the 3D situation too
    (in 3D, our engine also follows the convention that <i>Y grows up</i> by default;
    so in 3D you get <i>one additional dimension</i>, Z, going "outside" of the screen,
    while X and Y axes are oriented the same in 2D and 3D).

    <p>Usually, instead of assigning the positions using the
    <?php api_link('Left', 'CastleUIControls.TCastleUserInterface.html#Left'); ?> and
    <?php api_link('Bottom', 'CastleUIControls.TCastleUserInterface.html#Bottom'); ?> properties,
    it's better to <b>use <i>anchors</i></b>. Anchors specify the position of some border (or center)
    of the control, relative to some border (or center) of it's parent.
    When the parent control is resized (e.g. when user resizes the window),
    children are automatically repositioned correctly.
    This usually avoids the need to react to window size changes in callbacks like
     <?php api_link('Window.OnResize', 'CastleWindow.TCastleWindowBase.html#OnResize'); ?>
     or <?php api_link('TCastleUserInterface.Resize', 'CastleUIControls.TInputListener.html#Resize'); ?> implementations.</p>
  </li>

  <li><p>Note that <b>the parent does not clip the visibility of the children</b>.
    That is, we assume that you will set the size of children small enough to make them fit
    within the parent. If you don't, the result will be a little unintuitive: the overflowing
    contents of children will be drawn outside of the rectangle of the parent, but they will
    not receive input (like mouse clicks). For this reason, it's best to make children actually fit
    within the parent.

    <p>If you actually want to clip the children, set the
    <?php api_link('ClipChildren', 'CastleUIControls.TCastleUserInterface.html#ClipChildren'); ?> to <code>true</code>.
  </li>
</ul>

<p>With all this knowledge about parents and anchors, let's make a simple dialog box,
showing off what we learned, and something extra (note the use of <code>TCastleLabel.Html</code>
and <code>HexToColor</code> below).
Below are the contents of the <code>ApplicationInitialize</code> procedure,
you can just use this code to setup UI in the main program block
(like in the simple examples above on the same page),
or you can set it as the <code>Application.OnInitialize</code> callback following the
<a href="manual_cross_platform.php">chapter about developing cross-platform applications</a>.

<p>If in doubt, <b>take a look at the <a href="https://github.com/castle-engine/castle-engine/tree/master/examples/user_interface/zombie_fighter">examples/user_interface/zombie_fighter/</a>
code that contains the final application we will make in this manual!</b>
It uses the <code>ApplicationInitialize</code> procedure.</p>

<?php echo pascal_highlight('uses SysUtils, CastleControls, CastleUtils, CastleFilesUtils,
  CastleColors, CastleUIControls;

var
  Rect: TCastleRectangleControl;
  InsideRect: TCastleRectangleControl;
  Image: TCastleImageControl;
  LabelStats: TCastleLabel;
  ButtonRun, ButtonFight: TCastleButton;

procedure ApplicationInitialize;
begin
  Rect := TCastleRectangleControl.Create(Application);
  Rect.Width := 400;
  Rect.Height := 500;
  Rect.Color := HexToColor(\'5f3939\'); // equivalent: Vector4(95/255, 57/255, 57/255, 1.0);
  Rect.Anchor(hpMiddle);
  Rect.Anchor(vpMiddle);
  Window.Controls.InsertFront(Rect);

  InsideRect := TCastleRectangleControl.Create(Application);
  InsideRect.Width := Rect.EffectiveWidth - 10;
  InsideRect.Height := Rect.EffectiveHeight - 10;
  InsideRect.Color := Silver;
  InsideRect.Anchor(hpMiddle);
  InsideRect.Anchor(vpMiddle);
  Rect.InsertFront(InsideRect);

  Image := TCastleImageControl.Create(Application);
  Image.URL := \'castle-data:/Female-Zombie-300px.png\';
  Image.Anchor(hpMiddle);
  Image.Anchor(vpTop, -10);
  InsideRect.InsertFront(Image);

  LabelStats := TCastleLabel.Create(Application);
  LabelStats.Color := Black;
  LabelStats.Html := true;
  { anything, just to show off the HTML :) }
  LabelStats.Caption := \'Statistics:\' + NL +
    \'Life: <font color="#ff0000">12%</font>\' + NL +
    \'Stamina: <font color="#ffff00">34%</font>\' + NL +
    \'Mana: <font color="#0000ff">56%</font>\';
  LabelStats.Anchor(hpMiddle);
  LabelStats.Anchor(vpBottom, 100);
  InsideRect.InsertFront(LabelStats);

  ButtonRun := TCastleButton.Create(Application);
  ButtonRun.Caption := \'Run\';
  ButtonRun.Anchor(hpLeft, 10);
  ButtonRun.Anchor(vpBottom, 10);
  ButtonRun.PaddingHorizontal := 40;
  InsideRect.InsertFront(ButtonRun);

  ButtonFight := TCastleButton.Create(Application);
  ButtonFight.Caption := \'Fight\';
  ButtonFight.Anchor(hpRight, -10);
  ButtonFight.Anchor(vpBottom, 10);
  ButtonFight.PaddingHorizontal := 40;
  InsideRect.InsertFront(ButtonFight);
end;'); ?>

<p>Note that <a href="manual_editor.php">we have a visual designer for UI</a>.
It is described in the separate chapter.

<?php echo $toc->html_section(); ?>

<p>We advise using the <b>user interface scaling</b> to automatically adjust all the user interface controls, depending on the window size of the final application. Underneath it scales the UI coordinates (and then renders using the final coordinates, so all rendering remains crisp), adjusting to your "target" resolution but keeping the aspect ratio of the current window. It relies on properly set anchors to make everything look good on all aspect ratios.

<p><b>If this description sounds complicated, just try it</b>. It is easy to realize what happens visually, all <a href="manual_editor.php">"New Project" templates created by editor</a> use it automatically.

<p>It is advised to activate it by creating a file called <code>CastleSettings.xml</code> in the
<a href="manual_data_directory.php"><code>data</code> subdirectory of your project</a>.
The sample <code>CastleSettings.xml</code> contents look like this:

<?php echo xml_full_highlight('<?xml version="1.0" encoding="utf-8"?>
<castle_settings>
  <ui_scaling
    mode="EncloseReferenceSize"
    reference_width="1024"
    reference_height="768"
  />
</castle_settings>'); ?>

<p>Then in your <code>Application.OnInitialize</code> callback just call
<code>Window.Container.LoadSettings('castle-data:/CastleSettings.xml');</code>.
This will set <code>UIScaling</code>.
Remember that <a href="manual_editor.php">"New Project" templates created by editor</a> already do it by default.

<p>The advantage of using the <code>CastleSettings.xml</code> file is that
the <a href="manual_editor.php">editor</a> reads this file too,
and can apply the same scaling, default font and so on when you edit the UI.
Read <a href="manual_castle_settings.php">more about the <code>CastleSettings.xml</code> file here.</a>

<p>An alternative way to activate UI scaling is without the <code>CastleSettings.xml</code> file. Do this:

<?php echo pascal_highlight('Window.Container.UIReferenceWidth := 1024;
Window.Container.UIReferenceHeight := 768;
Window.Container.UIScaling := usEncloseReferenceSize;'); ?>

<p>Using UI scaling is incredibly important if you want your game to work on
various window sizes. Which is especially important on mobile devices,
where the sizes of the screen (in pixels) vary wildly.

<p>This means that the whole user interface will be scaled, by the
same ratio as if we would try to fit a <code>1024 x 768</code> area
inside the user's window. The proportions will not be distorted, but
things will get smaller or larger as necessary to accommodate to the
larger window size. If you use anchors correctly, things will
accommodate nicely to the various aspect ratios too.

<p>The fact that things are scaled is largely hidden from you. You get and set
the
 <?php api_link('Left', 'CastleUIControls.TCastleUserInterface.html#Left'); ?>,
 <?php api_link('Bottom', 'CastleUIControls.TCastleUserInterface.html#Bottom'); ?>,
 <?php api_link('Anchor', 'CastleUIControls.TCastleUserInterface.html#Anchor'); ?>,
 <?php api_link('EffectiveWidth', 'CastleUIControls.TCastleUserInterface.html#EffectiveWidth'); ?>,
 <?php api_link('EffectiveHeight', 'CastleUIControls.TCastleUserInterface.html#EffectiveHeight'); ?>,
 <?php api_link('EffectiveRect', 'CastleUIControls.TCastleUserInterface.html#EffectiveRect'); ?>,
 <?php api_link('FontSize', 'CastleControls.TCastleUserInterfaceFont.html#FontSize'); ?>
 and many other properties in the <i>unscaled</i> pixels. Which
basically means that you can hardcode them, and they will still look
right everywhere. Only a few properties uncover the final (<i>real</i>
or <i>scaled</i>) control size. In particular the
<?php api_link('RenderRect', 'CastleUIControls.TCastleUserInterface.html#RenderRect'); ?>
 method (very useful for custom drawing) returns the control rectangle
in the real device pixels (and with the anchors and parent
transformations already applied). More about this in the
<a href="manual_2d_ui_custom_drawn.php">chapter about custom-drawn UI controls</a>.

<?php echo $toc->html_section(); ?>

<p>You can check the resulting size of the control
with <?php api_link('EffectiveWidth', 'CastleUIControls.TCastleUserInterface.html#EffectiveWidth'); ?>
 and <?php api_link('EffectiveHeight', 'CastleUIControls.TCastleUserInterface.html#EffectiveHeight'); ?>.

<p>Beware: Many controls,
like <?php api_link('TCastleButton', 'CastleControls.TCastleButton.html'); ?>, expose also properties
called <?php api_link('Width', 'CastleControls.TCastleButton.html#Width'); ?> and
 <?php api_link('Height', 'CastleControls.TCastleButton.html#Height'); ?>, but they are only to set
an <i>explicit</i> size of the control (if you have disabled
auto-sizing using <?php api_link('TCastleButton.AutoSize', 'CastleControls.TCastleButton.html#AutoSize'); ?>
 or <?php api_link('TCastleButton.AutoSizeWidth', 'CastleControls.TCastleButton.html#AutoSizeWidth'); ?>
 or such). They will not be updated when the control auto-sizing mechanism calculates the actual
size. So <i>do not use <code>Width</code> or <code>Height</code> properties to query the size of a button.
Always use the <code>EffectiveWidth</code> or <code>EffectiveHeight</code> properties instead.</i>

<p>You can also use the <?php api_link('EffectiveRect', 'CastleUIControls.TCastleUserInterface.html#EffectiveRect'); ?>
 property, it contains the control position and size. But note that it's
valid only after the control, and all it's parents, is part of a window that already
received a <code>Resize</code> event. So you may need to wait for the <code>Resize</code> event
to actually use this value.</p>

<?php echo $toc->html_section(); ?>

<!--li><p>You can use <a>KeepInFront</a> to force a control to be in
front of other controls, even the ones added with <a>InsertFront</a>
(unless they will also have KeepInFront = true...)</p>
</li-->

<p>To adjust the look of some controls, you can adjust the theme.
All of the standard 2D controls are drawn using theme images.
This way the look of your game is defined by a set of images,
that can be easily customized.

<!-- Note that each button has already highly configurable look,
even without using the theme, by it's custom images.</p-->

<p>Use the <code>Theme</code> global variable
(instance of <?php api_link('TCastleTheme', 'CastleControls.TCastleTheme.html'); ?>).
For example, image type <code>tiButtonNormal</code> is the normal
(not pressed or disabled) button look.

<p>You can change it to one of your own images. Like this:

<?php echo pascal_highlight(
'Theme.ImagesPersistent[tiButtonNormal].Url := \'castle-data:/custom_button_normal.png\';
Theme.ImagesPersistent[tiButtonNormal].ProtectedSides.AllSides := 1;'); ?>

<p>Note that we also adjust the <code>ProtectedSides</code> above.
This way image will be drawn stretched, using the
<?php api_link('Draw3x3', 'CastleGLImages.TDrawableImage.html#Draw3x3'); ?> technique
 (often called <a href="https://en.wikipedia.org/wiki/9-slice_scaling">9-slice scaling</a>)
 to intelligently stretch, taking the sides into account.</p>

<p>You can see the default images used in the engine sources, in <code>src/ui/opengl/gui-images/</code>
subdirectory. Feel free to base your images on them.</p>

<p>If you prefer to embed the image inside your application
executable, you can do it using the <code>image-to-pascal</code>
tool (compile it from the engine sources in <code>tools/image-to-pascal/</code>).
You can then assign new image like this:

<?php echo pascal_highlight(
'Theme.ImagesPersistent[tiButtonNormal].Image := CustomButtonNormal;
Theme.ImagesPersistent[tiButtonNormal].OwnsImage := false;
Theme.ImagesPersistent[tiButtonNormal].ProtectedSides.AllSides := 1;'); ?>

<p>Note that we set <code>OwnsImage</code> to <code>false</code>.
The instance of <code>CustomButtonNormal</code>
will be automatically freed in the <code>finalization</code>
section of the unit generated by the <code>image-to-pascal</code>.

<!--?php echo pascal_highlight(
'Theme.Draw(Rectangle(10, 10, 100, 100), tiActiveFrame);'); ?-->

<?php echo $toc->html_section(); ?>

<p>To adjust the initial <i>"Loading"</i> image (visible when you open
the application window) you want to adjust the <code>Theme.ImagesPersistent[tiLoading].Image</code>.

<p>This should be done in the <code>initialization</code> section of some unit (more specifically, it should happen before window is opened). As such, you cannot load image from disk at this moment (as on Android, you cannot read from disk from <code>initialization</code> sections of units). So you want to process this image first with <code>image-to-pascal</code> tool, to make an embedded image in a Pascal unit.

<p>In summary, this is what you should do:

<ol>
  <li>
    <p>Run <code>image2pascal GameEmbeddedImages my_loading.png</code> (it will generate <code>gameembeddedimages.pas</code> unit).

<li>
    <p>Add (and use, e.g. from main <code>GameInitialization</code>) a unit that does this:

<?php echo pascal_highlight(
'unit GameAdjustLoadingScreen;

interface

uses CastleColors, CastleControls, GameEmbeddedImages;

implementation

initialization
  // Theme.LoadingBackgroundColor := Black; // adjust as needed
  // Theme.LoadingColor := White; // adjust as needed
  Theme.ImagesPersistent[tiLoading].Image := My_Loading;
  Theme.ImagesPersistent[tiLoading].OwnsImage := false;
end.'); ?>
</ol>

Notes:

<ul>
  <li>
    <p>The <code>Theme.LoadingBackgroundColor</code> determines the background underneath the "loading" image. You usually want to adjust <code>Theme.LoadingBackgroundColor</code> to match your <code>my_loading.png</code> background.

  <li>
    <p>The <code>Theme.LoadingColor</code> is a color applied to the loading image. It multiplies the color of image <code>my_loading.png</code>. Usually you don't need to adjust <code>Theme.LoadingColor</code> if you're already customizing the <code>Theme.ImagesPersistent[tiLoading]</code> image to your own.

  <li>
    <p>Note that by default loading image is displayed with UI scaling that adjusts to reference size 1600x900. You can customize
    <a href="https://castle-engine.io/apidoc-unstable/html/CastleControls.TCastleTheme.html#LoadingUIScaling">Theme.LoadingUIScaling</a>,
    <a href="https://castle-engine.io/apidoc-unstable/html/CastleControls.TCastleTheme.html#LoadingUIReferenceWidth">Theme.LoadingUIReferenceWidth</a>,
    <a href="https://castle-engine.io/apidoc-unstable/html/CastleControls.TCastleTheme.html#LoadingUIReferenceHeight">Theme.LoadingUIReferenceHeight</a>
    to tweak it.
</ul>

<?php echo $toc->html_section(); ?>

<?php
echo castle_thumbs(array(
  array('filename' => 'button_with_2d_scene_manager.png', 'titlealt' => '2D animated scene inside a button'),
));
?>

<p>As the viewport may contain a <?php api_link('TCastleScene', 'CastleScene.TCastleScene.html'); ?>
 with animation, and a viewport
is just a 2D user-interface control,<!-- that can be children of other controls,-->
you can mix user-interface with animations freely.
For example, you can design an animation in Spine, load it to <?php api_link('TCastleScene', 'CastleScene.TCastleScene.html'); ?>,
insert it to <?php api_link('TCastleViewport', 'CastleViewport.TCastleViewport.html'); ?>, which you can then insert inside a
<?php api_link('TCastleButton', 'CastleControls.TCastleButton.html'); ?>. Thus you can have a button
 with any crazy animation inside:)

<?php echo pascal_highlight_file('code-samples/button_with_viewport.lpr'); ?>
////
