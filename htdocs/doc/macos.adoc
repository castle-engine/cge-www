# macOS
include::common.adoc[]
:source-highlighter: rouge

cgeimg::block[
  mac_editor_1.png|CGE editor on macOS,
  mac_view3dscene_2.png|view3dscene on macOS
]

## Installation on macOS

### Xcode with command-line tools

We need https://developer.apple.com/xcode/[Xcode] with the _Xcode command-line developer tools_ installed.

- Install _Xcode_ from the macOS _App Store_.

- Install _Xcode command-line tools_ and accept their license.
//We need them, FPC also needs them.
To install them, open the terminal (in Finder, run _/Applications/Utilities/Terminal_) and execute:
+
```shell
xcode-select --install
```
+
Confirm the installation in the dialog that appears and wait for it to finish. Then make sure the tools work, which also means the license is accepted. First run may require you to accept a license, and be done using `sudo`:
+
```shell
# First run: this will ask to type "agree" to accept license
sudo xcrun --show-sdk-path

# Test: now it should work without sudo
xcrun --show-sdk-path
```

### Castle Game Engine itself

Download the official binary release from link:/[Castle Game Engine main page]. The editor and various tools are inside the `bin/` subdirectory.

#### Allow running non-notarized Unix applications (remove quarantine bit)

Although our macOS applications are now https://github.com/castle-engine/castle-build-ci/tree/master/apple[codesigned and notarized], this is not enough for modern macOS versions. Unix applications outside of an "app bundle" are not trusted, and we ship with some (like `fpc` and our build tool `castle-engine`).

To fix it, use `xattr` to remove the quarantine bit from the Unix applications in our distribution.

```shell
cd ~/Downloads/castle_game_engine/
xattr -cr tools/ \
          bin/castle-curves \
          bin/castle-engine \
          bin/image-to-pascal \
          bin/pasls \
          bin/texture-font-to-pascal \
          bin/to-data-uri
```

[NOTE]
====
If you are in an ssh session, you can use a simpler command:

```
xattr -cr ~/Downloads/castle_game_engine/
```

However, this will fail if executed inside macOS _Terminal_. For some reason, _Terminal_ is not allowed to change files in application bundles, so the above attempt will fail with errors like this:

```
xattr: [Errno 1] Operation not permitted: '/Users/administrator/Downloads/castle_game_engine/bin/castle-editor.app`
```

So better use the longer version of the `xattr ...` command, showed earlier. It works everywhere, both through ssh and when pasted in the _Terminal_.
====

////
NOTE: In the example commands above we pass the whole `castle_game_engine` directory to `xattr -cr`, this will recursively remove the quarantine bit from all applications inside, including the editor and other engine tools in `bin/` and the bundled FPC compiler in `tools/contrib/fpc/`.
////

#### Run the editor and check paths are correct

Once you have performed the above steps, you can run the editor. Just double-click the `castle-editor` application inside the `bin` subdirectory of the unpacked engine.

Before using the editor further, we recommend to check that the engine and compiler (FPC) have been properly detected. Open the editor _"Preferences"_ and make sure that:

- _Castle Game Engine_ path is set correctly (in the _"General"_ tab).
+
This should be correct now out-of-the-box, since our editor is https://github.com/castle-engine/castle-build-ci/tree/master/apple[codesigned and notarized] so Apple _"translocation"_ mechanism
//(that internally executes the application from a random place on disk, if it was part of a zip downloaded from the Internet)
doesn't apply.
//Unfortunately, CGE editor cannot detect CGE own location, even though from user's perspective you run the editor right inside CGE directory.

- FPC path and version has been detected correctly (in the _"FPC and Lazarus"_ tab). If FPC version is detected, it also implies that FPC binaries are properly trusted.
+
FPC path and version should be correct out-of-the-box.

- Note: link:lazarus[Lazarus] path in (in the _"FPC and Lazarus"_ tab) may be not detected.
+
Ignore it if you don't plan to use _Lazarus_ as an IDE. Our games can be build without having _Lazarus_.
+
Or if you want to use _Lazarus_ as an IDE, you need to link:https://www.lazarus-ide.org/[install it] yourself and point (in the _"FPC and Lazarus"_ tab) to its location. This will make engine features like _"Open Project In Code Editor"_ work with _Lazarus_.

### Optional: Add an alternative FPC version and Lazarus

Doing this step is not necessary, as our macOS downloads (for both _x86_64_ and _Aarch64_) already contain the latest stable version of https://www.freepascal.org/[Free Pascal Compiler (FPC)]. So you don't need to install anything more, building and running projects will "just work" out-of-the-box.

However, you can install your own FPC version, if you want, e.g. to add _cross-compilers_ that you need. You can also install _Lazarus_, a Pascal IDE.

* Follow download links from link:http://www.lazarus.freepascal.org/[the official Lazarus webpage] to download Lazarus and FPC for macOS. You should download and install all 3 dmg files (Lazarus, FPC, FPC sources).

* *Alternatively (if you use a package manager like Homebrew)*: You can also install FPC and Lazarus using your favorite package manager like
+
[role="compact"]
--
* link:https://brew.sh/[Homebrew] - see https://formulae.brew.sh/formula/fpc[FPC in Homebrew], https://formulae.brew.sh/cask/lazarus[Lazarus in Homebrew],
+
NOTE: While `brew install fpc` works great, the Lazarus IDE formulae is deprecated and indeed may fail on latest macOS/Aarch64.

* link:https://www.macports.org/[MacPorts],

* link:http://www.finkproject.org/[Fink].
--

* *Alternatively (FpcUpDeluxe)*: You can also install FPC and Lazarus using https://castle-engine.io/fpcupdeluxe[fpcupdeluxe]. While the UI may be a bit overwhelming, in the end you just hit the big button _"Install FPC + Lazarus"_ and it reliably installs the specified FPC + Lazarus version. And it allows to easily add cross-compilers.

* *Alternatively (our castle-fpc)*: You can also install FPC and Lazarus from our builds, that are used also for link:ci[CI] jobs:
+
--
- https://github.com/castle-engine/castle-fpc[our recommended FPC version].
- https://github.com/castle-engine/castle-lazarus[our recommended Lazarus version].
--

////
The latest macOS doesn't include gdb (a debugger, user underneath by Lazarus) by default. Lazarus will warn you about this on the 1st run. You can install GDB e.g. using link:https://brew.sh/[HomeBrew], just execute `brew install gdb`.

(Lazarus now uses LLDB on macOS by default.)
////

More information:

- link:https://wiki.freepascal.org/Mac_Installation_FAQ[FPC Mac Installation FAQ]
- link:https://wiki.freepascal.org/Installing_Lazarus_on_MacOS_X[Installing Lazarus on MacOS X]

## Using TCastleWindow

Using cgeref:TCastleWindow[] on macOS is completely standard. Just run the application as usual, using _"Compile And Run"_ menu item (key shortcut is `F9`) from the editor. Alternatively, you can use `castle-engine run` on the command-line.

When creating new project in CGE editor, it will use cgeref:TCastleWindow[] by default to display a window where the engine will render.

By default, cgeref:TCastleWindow[] on macOS uses https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/WhatIsCocoa/WhatIsCocoa.html[Cocoa] with https://developer.apple.com/documentation/appkit?language=objc[AppKit] library, coded using https://www.freepascal.org/docs-html/current/ref/refse71.html#x132-15600011.1[Objective-Pascal]. This makes it a completely native application on macOS. See link:castlewindow_backends#_cocoa_castle_window_cocoa[Cocoa backend (CASTLE_WINDOW_COCOA)] overview for the features we support on macOS.

## Using TCastleControl

Using link:control_on_form[TCastleControl] on macOS is also completely standard. Just drop cgeref:TCastleControl[] on LCL form.

Note that cgeref:TCastleWindow[] is more advised, as a standard way to create a window where _Castle Game Engine_ can work.

## Other libraries

OpenAL (sound):: On macOS >= 10.4, OpenAL comes already preinstalled. So sound will work automatically.

VorbisFile (reading OggVorbis):: It may be installed using link:https://www.macports.org/[MacPorts], link:https://brew.sh/[Homebrew] or link:http://www.finkproject.org/[Fink].

LibPng:: If you want to use _LibPng library_ in your programs, to read PNG faster, you can install it using link:https://www.macports.org/[MacPorts], link:https://brew.sh/[Homebrew] or  link:http://www.finkproject.org/[Fink].
+
Note that *this is not necessary*. If we don't find LibPng, we will fallback to reading PNG using _Vampyre Imaging Library_, which works too.

FreeType (reading font files):: It is available in package managers like link:https://brew.sh/[Homebrew] (install using `brew install freetype`). As a fallback we will also try to use FreeType version installed by your X11, in `/usr/X11/lib/` .

## macOS application bundles

To run a GUI application on macOS we use _macOS application bundles_. The _application bundle_ is actually just a directory with name like `MyApplication.app` and some standard organization for executable, icons, data.

_When running the application during development_ we create a temporary application bundle, using symlinks to actual files (so it will be created lighting fast, even if you have large game data, as we will not copy data -- only symlink to it). This applies to running application from CGE editor, or when using `castle-engine run` on the command-line.

_When packaging the application_ we also create an application bundle, this time by really copying the files/dirs into proper places. This gives you `MyApplication.app` that is ready to be distributed to users. This applies when packaging from CGE editor, or when using `castle-engine package` from the command-line. You can also request the application bundle format explicitly, using CGE editor menu item _"Run -> Package -> macOS App Bundle (APP) zip"_, or on command-line `castle-engine package --package-format=mac-app-bundle-zip`.

NOTE: You can disable using _application bundle_ by setting `mac_app_bundle="false"` in the link:project_manifest[CastleEngineManifest.xml]. Disabling it makes sense for command-line (not GUI) applications.

Behavior of the link:data[data directory] (`castle-data:` protocol) on macOS, if the application detects it is being run through the "application bundle":

- We expect the data to be found inside `MyApplication.app/Contents/Resources/data` subdirectory. This way user can move around `MyApplication.app` to move, install and uninstall the application.
+
When creating application bundle, we (CGE editor and CGE build tool) make sure to make project data actually present there, so things should _Just Work_ and you don't need to do anything.

- If the `MyApplication.app/Contents/Resources/data` subdirectory is not found, we will use the `data` subdirectory that is sibling to `MyApplication.app`. This feature is intended to be used only *during development with Lazarus*. This way things work "out of the box" if you run through Lazarus, with checkbox _“Use Application Bundle for running and debugging”_ in Lazarus project options.

## macOS packaging to zip and dmg

- By default we put the application bundle in a zip file. If you only want the bundle (`MyApplication.app` directory), use the menu item _"Run -> Package -> macOS App Bundle (APP)"_, or on command-line `castle-engine package --package-format=mac-app-bundle`.

- Alternative often used distribution method on macOS is a `.dmg` file. It's just a _disk image_ that can contain anything, like `MyApplication.app`. See link:http://el-tramo.be/guides/fancy-dmg/[Building Fancy DMG Images on macOS] for nice description how to make the directories inside dmg look pretty, so you can visually suggest user to drag your application in the _Applications_ folder.
+
link:https://daringfireball.net/2009/09/how_should_mac_apps_be_distributed[There are convincing arguments that using ZIP is actually more user-friendly than DMG] (users can just double-click to unpack, and they have the application; they don't need to understand how "disk image" works). See also link:https://stackoverflow.com/questions/3954506/dmg-or-zip-file-for-distribution-to-macs[here] for discussion. And making zip is definitely simpler. So that's why we do ZIP, not DMG, by default now.
////
+
Alternative method of distribution macOS applications is the  link:http://wiki.freepascal.org/Deploying_Your_Application#Using_PackageMaker_on_Mac_OS_X[package manager (.pkg)]. For normal applications (like games) the simpler `.dmg` or `.zip` are a better choice.
////

- If you need, you can add additional dynamic libraries to the bundle. If you link to them dynamically (e.g. using our `TDynLib.Load`), you should load them from a path relative to `BundlePath`, like `BundlePath + 'Contents/MacOS/libpng.dylib'`.
+
See link:http://wiki.freepascal.org/OS_X_Programming_Tips#Mac_OS_X_Libraries[macOS Libraries on FPC wiki] for general instructions how to include library inside a bundle.

## FAQ

### Apple says that OpenGL(ES) is deprecated. What happens if they remove OpenGL(ES) from macOS and iOS?

_Short answer:_ We will integrate seamlessly with https://github.com/google/angle[ANGLE, that has a complete OpenGL ES 3.0 support, on top of Metal API].

_Full answer:_

First of all, I (_Michalis_) hope that Apple will not go with the removal of OpenGL(ES) from their devices. Or that they will add https://www.vulkan.org/[Vulkan] support as a 1st-class citizen on Apple devices, in exchange. I hope they will not make https://developer.apple.com/metal/[Metal] the only API to access GPU on macOS / iOS.

_Reason:_ Open technologies, including cross-platform open standards (like OpenGL and Vulkan), are what allows us to innovate and ultimately enjoy technology. The world seems to agree -- as it stands, all platforms supported by CGE have _OpenGL or OpenGLES_ support, and many have _Vulkan_ support. Unless your software is only for Apple devices, it's hard to be enthusiastic for https://developer.apple.com/metal/[Metal], an Apple-specific technology that ultimately solves a similar problem that https://www.vulkan.org/[Vulkan] does on all other platforms.

As of now, OpenGL is still fully supported on latest macOS (including on Apple _Silicon_ architecture) and OpenGLES is still fully supported on iOS (iPhone, iPad).

If however Apple will really remove OpenGL(ES) from future devices, and make https://developer.apple.com/metal/[Metal] the only officially supported API for GPU access, we have a number of options. And we will be in a good company, a lot of projects will be in a similar spot -- including Apple's own _Safari web browser_ that in the end has to support WebGL (an API much like OpenGLES, but available for web page developers from JS) translating it in an efficient way to something available on Apple devices.

1. Our first course of action will be using https://github.com/google/angle[ANGLE] that allows to effectively use OpenGLES API (and GLSL shaders) from CGE, and have them translated to _Metal_ under the hood.
+
It's efficient, it's complete: full OpenGL ES 3.0 support.
+
It's been in development for a long time, is supported by some big companies, it has multiple backends (not just Metal).
+
Apple itself contributes to it (see notes from https://github.com/kakashidinho/metalangle#differences-between-metalangle-and-googles-angle[MetalANGLE], fork where initial work has happened to support OpenGLES 2.0 and 90% of OpenGL ES 3.0 on top of Metal).

2. In the future, CGE will definitely have an alternative renderer:
+
--
- https://github.com/bkaradzic/bgfx[BGFX] is right now attractive option for us.
+
This in turn has various backends, including _Metal_, _Vulkan_, various _OpenGL (ES)_ and _Direct3D_ versions.

- Direct https://www.vulkan.org/[Vulkan] renderer. _Vulkan_ is a new API, harder to use, more low-level, but with possibilities to deliver amazing performance and also scale better to multiple cores.
+
At that point, using https://moltengl.com/moltenvk/[MoltenVK] will become an option to. It exposes Vulkan API and uses Metal underneath.
--

3. Finally, there is an option of developing another renderer in CGE on top of https://developer.apple.com/metal/[Metal].
+
We know we will have extensible architecture in CGE for multiple renderers. I have been playing with idea to implement a Vulkan renderer (see https://github.com/castle-engine/castle-engine/tree/master/examples/research_special_rendering_methods/new_renderer_skeleton[new_renderer_skeleton]) and, beyond some initial fun, of course it will imply the need for a pluggable architecture to implement many possible renderers. OpenGL(ES) will remain one, Vulkan will most likely become another, and it is possible that Metal will become yet another one.
+
However, please note -- this (Metal renderer in CGE) is not an option that will happen fast. Making a new renderer _"production-ready"_ (that is, making it more feature-packed / efficient than just using abstraction layer like Angle + existing OpenGLES renderer) is a _lot_ of work. Moreover, CGE is a cross-platform game engine, and it's hard to prioritize big work on something that only benefits Apple platforms. That being said, I would be very happy to see a dedicated contributor interested in adding Metal support. Or if you want to find and sponsor such contributor, that can be arranged (https://castle-engine.io/talk.php[talk with us]).

## Known Issues

### Mouse hiding is untested

We have code in place doing mouse hiding (used e.g. during _"mouse look"_ navigation), but we cannot guarantee it works. It was tested so far only over remote connection to macOS (using _Team Viewer_ and _VNC_), which override mouse cursor appearance, so we cannot really see the hiding / showing of the real mouse cursor.

Any help with testing is welcome!

### Linking for macOS/Silicon (Aarch64) produces warnings

Building any application for macOS/Silicon (Aarch64) produces a number of warnings like this:

```
ld: warning: object file (xxx.o) was built for newer 'macOS' version (11.0) than being linked (10.15)
```

We hide these warnings in most cases (our link:build_tool[build tool] filters them out). But sometimes you may still see them, e.g. during the link:compiling_from_source[compilation of the build tool itself (if you do this)] or if you compile using link:lazarus[Lazarus IDE].

For now, we don't have a solution that really solves these warnings. You can simply ignore them.

Some details:

- Both FPC 3.2.3 built with link:fpcupdeluxe[] and built with https://github.com/castle-engine/castle-fpc[our castle-fpc script] produce this warning.

- This is likely related to `-macos_version_min XXX` options to the linker and `-WMxxx` options to the compiler.
+
FPC seems to pass to `ld` already a necessary version (which can be inferred from the warning `-macosx_version_min has been renamed to -macos_version_min` :) ).
+
We right now pass `-WM10.15` to the compiler which is indeed not good for _Aarch64_. Since _Aarch64_ is supported only since https://en.wikipedia.org/wiki/MacOS_Big_Sur[macOS 11.0 (Big Sur)], it should be at least `-WM11.0`.
+
However, trying to build with `-WM11.0` results in linker errors: `ld: malformed method list atom 'l_OBJC_CLASS_RO_$_TCocoaMenuItem' (.../aarch64-darwin/castlewindow.o), fixups found beyond the number of method entries` .

- We didn't find a combination of flags that makes linking work without any errors and warnings. Perhaps future FPC version will have this fixed.
