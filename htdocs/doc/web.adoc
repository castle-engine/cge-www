# Web Target
include::common.adoc[]
:description: Upcoming support for web development in CGE.
:cge-social-share-image: web_1_vivaldi.png

== Introduction

[WARNING]
====
This feature is in development now. You can compile for WebAssembly, but the resulting application is not functional yet. Stay tuned!
====

The goal of the _web target_ in _Castle Game Engine_ is to allow you to recompile more-or-less any application you wrote using _Castle Game Engine_ (using cgeref:TCastleWindow[]) to the web. So you can put your application on a website, as part of a regular HTML webpage, and users can play it instantly, without the need to download / install any native application or browser plugin.

cgeimg::block[
  web_1_firefox.png|Castle Game Engine in Firefox,
  web_1_vivaldi.png|Castle Game Engine in Vivaldi
]

== How it works (or will work)

=== Already working

- We're using FPC https://wiki.freepascal.org/WebAssembly[WebAssembly] target.
+
Huge thank you go to the whole FPC team for making it possible! For general documentation (unrelated to CGE), see https://www.freepascal.org/~michael/articles/fpcwasm1/fpcwasm1.pdf[this article by Michael Van Canneyt].

- To run the _WebAssembly_ in a web browser, there is additional "glue" code, which we also write in Pascal and compile using https://getpas2js.freepascal.org/[Pas2js].
+
The integration between https://getpas2js.freepascal.org/[Pas2js] and _FPC + WebAssembly_ is extremely easy, again thanks to the work of everyone involved!

- For development purposes, we can run a simple webserver on the localhost. link:https://getpas2js.freepascal.org/[Pas2js] features a ready `compileserver`, we just use it.
+
NOTE: https://wiki.lazarus.freepascal.org/fcl-web[FpWeb] also can instantiate a https://wiki.lazarus.freepascal.org/fphttpserver[standalone HTTP server] in just a few lines of code. But it seems we don't need even this, `compileserver` is all that we need.

- Our link:build_tool[build tool] takes care of everything. You usually want to execute 2 commands:
+
--
1. `castle-engine compile --target=web  --mode=debug`
+
This command:
+
- generates web-specific files (in `castle-engine-output/web/`),
- compiles the glue code using Pas2js,
- compiles the application code using FPC for WebAssembly.
2. `castle-engine run --target=web`
+
This command:
+
- runs web server (`compileserver`) on `http://localhost:3000/` to serve `castle-engine-output/web/dist/`,
- runs web browser (default web browser on your system, logic using our cgeref:OpenUrl[]) to open `http://localhost:3000/`.
--
+
[NOTE]
====
It is also possible to just compile using FPC + WebAssembly to a `.wasm` file. This does a subset of work performed by `castle-engine compile --target=web`. To do this, just execute:

```shell
castle-engine compile --os=wasi --cpu=wasm32
```

You likely don't need to use above options, unless you have your own idea how to deploy the `.wasm` file. The `--target=web` does everything for you.
====


=== Plans (TODOs)

- TODO: Our link:editor[] also does the above steps, just change the platform using _"Run -> Platform -> Web"_ menu item and hit _"Build and Run"_ (F9).

- TODO: We render using https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API[WebGL 1.0], with optional WebGL 2.0 features. This is very similar to current rendering on mobile, where we use https://castle-engine.io/wp/2023/03/12/mobile-opengles-rendering-upgrades-occlusion-query-anisotropic-filtering-3d-textures-shadows-plus-new-occlusion-query-demo/[OpenGL ES 2.0, with optional OpenGL ES 3.0 features].
+
The WebGL API is available in the browser to https://getpas2js.freepascal.org/[Pas2js] (that is, any _JavaScript_ code in the browser). We can expose this API for the WebAssembly, following the https://www.freepascal.org/~michael/pas2js-demos/wasienv/canvas/[canvas example] described in the 2nd part of https://www.freepascal.org/~michael/articles/fpcwasm1/fpcwasm1.pdf[this article].

- TODO: For audio, we will add a new sound backend using https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API[WebAudio]. This will be the default sound backend on the web (like the https://castle-engine.io/openal[OpenAL] is now the default backend on non-web platforms).
+
It is also possible our https://castle-engine.io/fmod[FMOD] sound backend will also be ported to web, as https://www.fmod.com/docs/2.02/api/platforms-html5.html[FMOD supports HTML5]. This would make FMOD a truly cross-platform sound backend, working on every platform we support in CGE.
+
NOTE: About https://castle-engine.io/x3d_implementation_sound.php#section_x3d4[WebAudio in the context of X3D 4.0]. Supporting advanced X3D 4.0 audio nodes is not our priority, but since WebAudio will happen anyway, on the web... they will open this possibility. There is also https://github.com/LabSound/LabSound[LabSound] that provides WebAudio-like API on non-web platforms, and in principle it could one day replace OpenAL, making web and non-web audio handling closer.

- TODO: For data delivery, we know we'll have to invent a simple format to carry our game data as one big binary blob. The simple plan is to just pack game data into zip.
+
Both FPC and Delphi have built-in support for ZIP handling, we even https://github.com/castle-engine/castle-engine/blob/master/examples/network/custom_url_handler/code/gameunzip.pas[use it in one example], we'll likely create a more full-featured wrapper that works on both FPC and Delphi.
+
Packing resources into ZIP is beneficial over just placing all data files separately in the webserver directory. It allows to download the ZIP once (at application load) and then our WebAssembly code can load data from it synchronously, thus it can work similarly to how a non-web game data is loaded. Naturally we also want to have cgeref:TCastleDownload[] working and being able to load things asynchronously (see our https://castle-engine.io/manual_network.php[network docs]).

- Possibly throw in additional compression of data and/or wasm executable?
+
So far, file-size tests are promising. Compilation of https://github.com/castle-engine/castle-engine/tree/webassm_platformer_test/examples/platformer[examples/platformer], which practically uses 100% of CGE units, yields a binary `platformer.wasm` that has 16 MB. Gzipped it has 3.4 MB.
+
The gzipped size is really what matters &mdash; both web browsers and servers support gzip-(de)compression on the fly, you can also just put ready-gzipped version on the server and tell the browser to just decompress. So in all practical cases, users will download 3.4 MB, not 16 MB.
+
Note that above is for a _release_ build. The _debug_ build weights 51 MB, and gzipped 12 MB. How is the debug build actually useful on the web &mdash; I am not certain now :)
+
We could also use https://en.wikipedia.org/wiki/Brotli[Brotli], a newer compression method also commonly supported by web browsers and servers.

== Prerequisites

- *link:https://getpas2js.freepascal.org/[Pas2js]*.
+
You can get it along with https://www.freepascal.org/[FPC] or install it separately from link:https://getpas2js.freepascal.org/[here]. We don't have any special version requirements, just get the latest stable version.
+
_Test that it works._ Create the following simple program, save it as `hello_pas2js.lpr`:
+
[source,pascal]
----
begin
  Writeln('Hello from pas2js!');
end.
----
+
If everything is installed and configured OK, then you should be able to compile it using this from the command-line:
+
```
pas2js -Jc -Jirtl.js -Tbrowser hello_pas2js.lpr
```
+
If everything went well, you should get a file `hello_pas2js.js` in the same directory.

- *compileserver* from *link:https://getpas2js.freepascal.org/[Pas2js]*.
+
This is a very useful tool distributed along with link:https://getpas2js.freepascal.org/[Pas2js]. Make sure you got it, test it by executing on the  command-line this:
+
```
compileserver
```
+
Leave it running and access `http://localhost:3000/` in a web browser.
+
Kill it by _Ctrl+C_ in the terminal.
+
Why is this useful? Most dynamic webpages should be tested through a webserver running on your system (like `compileserver`, though you can also spin a full https://httpd.apache.org/[Apache] or https://nginx.org/[Nginx]) that serves the HTML, JS, WASM and other files. You view them using a `http://localhost:.../` URL, which means you access the webserver on your own system. In contrast, just opening the HTML files in a web browser (which results in URLs like `file:///.../index.html`) will usually not work, because of security: JavaScript code on such pages will not be able to load extra resources (like WASM files). It's possible to configure your browser to circumvent this (disable CORS checking) but it's a hassle. Using a "temporary webserver" like `compileserver` is the easiest way to test your applications.

- *link:https://www.freepascal.org/[FPC] with link:https://wiki.freepascal.org/WebAssembly[WebAssembly] support.*
+
In our opinion, it's easiest to get this using link:fpcupdeluxe[]: install FPC _"trunk"_ version, then install FPC cross-compiler for OS=`Wasi` and CPU=`Wasm32`. You can also just get it from GIT and compile manually, following link:https://wiki.freepascal.org/WebAssembly[FPC wiki about WebAssembly].
+
_Test that it works._ Create the following simple program, saved as `hello_wasm.lpr`:
+
```delphi
begin
  Writeln('Hello from WebAssembly!');
end.
```
+
If everything is installed and configured OK, then you should be able to compile it using this command:
+
```
fpc -Twasi -Pwasm32 hello_wasm.lpr
```
+
If everything went well, you should get `hello_wasm.wasm` in the same directory.

== How to test what we have now

Branch https://github.com/castle-engine/castle-engine/tree/webassm_platformer_test[webassm_platformer_test] in CGE contains the work on WebAssembly. To test it:

1. Get the https://github.com/castle-engine/castle-engine/tree/webassm_platformer_test[webassm_platformer_test] branch of CGE.

2. Follow link:compiling_from_source.php[compiling from source] docs to compile at least new CGE build tool from this CGE branch.

3. Enter any CGE project and compile and run it for WebAssembly. For example, to compile the `examples/platformer` project:
+
[source,shell]
----
castle-engine compile --target=web --mode=debug
castle-engine run --target=web
----

Currently, the project executes, printing logs (using our cgeref:CastleLog[]) to the browser console. The rendering is not yet working.

== TODO: How to continue

- Investigate next `Exception class:  object , message: indirect call to null` from `platformer.wasm` error cause.
- Then make the rendering work, by routing calls to WebGL on the web.
+
--
- We could use WebGL from Pasj2s (see `pas2js/packages/rtl/src/webgl.pas` and pasj2s demos using it). We can make these calls available to our WebAssembly code (using canvas example from Pas2js and explanation from https://www.freepascal.org/~michael/articles/fpcwasm1/fpcwasm1.pdf how to expose JS functionality to WebAssembly).

- ... but actually it seems unnecessary: FPC includes a unit `job_web` with `TJSWebGL2RenderingContext`. It does seem that the hard work is done for us, it should allow to expose WebGL API from Pas2js to WebAssembly. Learn how to use it. See wiki, https://wiki.freepascal.org/WebAssembly/DOM .

- Define `CastleWebGL` unit, exposing these calls in a flat way, to be similar to OpenGLES, and add macro `CastleGLES:=CastleWebGL` in `castleconf.conf`.

- Test rendering first on some simple application without any data, just do some `DrawRectangle` from CGE in `TCastleUserInterface.Draw`. Hack any CGE example for this.

- Once we got this rendering, we need to pass resources, from our data, to web application -- preferably as one big zip, to allow synchronous reading of it in WebAssembly. See "How" plans.
--

- Then finish the plans in "How" section above: data from zip, sound, automatic webserver, etc.
- _Trung Le (Kagamma)_ has been doing lots of work with CGE + FPC WebAssembly. His fork contains a branch https://github.com/Kagamma/castle-engine/tree/wasm32-wasi-port[wasm32-wasi-port]. Merge and/or cherry-pick this work to CGE as needed. Thank you!

== Thank you

I want to thank everyone involved in this and let's push forward! Web target is a really cool feature, from my talks I know it's an important feature for many CGE users, and I feel we have it in our reach. Let's keep coding and enjoy making games :)
