# Roadmap
include::common.adoc[]

## Introduction

Don't see the feature you need? link:talk.php[Tell us on the forum or Discord].

If you would like to see some feature implemented sooner, please link:https://www.patreon.com/castleengine[support the engine development on Patreon!]

## VR and AR

VR: link:wp/2022/01/16/oculus-quest-2-developer-mode-for-castle-game-engine-enabled/[Michalis has access to Oculus Quest since the beginning of 2022]. Port most likely using link:https://www.khronos.org/OpenXR/[OpenXR] (to include the widest possible range of devices using a single cross-platform API).

cgeimg::block[oculus.png|Oculus Quest 2: Developer Mode for Castle Game Engine enabled!]

AR: most likely using Android / iOS built-in frameworks, as these make AR widely available on modern phones.

[#materials]
## (planned for 7.0) New material components (allowing also material editing in the editor)

We want to allow you to edit materials in the CGE editor,

- e.g. to modify (or completely override) materials from TCastleScene (like glTF),

- to have full control over primitives (like `TCastleSphere` or `TCastleImageTransform` look),

- to enable you to use cool CGE features like link:x3d_extensions_mirror_plane.php[mirrors], link:compositing_shaders.php[shader effects] easier.

This also means exposing new set of Pascal components to manage materials easier.

See https://github.com/castle-engine/castle-engine/files/10324944/new-material-components.txt for rough plans.

[#delphi_platforms]
## More Delphi platforms

See link:supported_compilers.php[about existing Delphi compatibility]. We plan to support more platforms with Delphi: Android, Linux, iOS...

[#gltf_efficient]
## Load and animate glTF more efficiently

We should read meshes in a way that keeps binary layout of data in glTF, so that it is ultra-fast to load, and it is loaded almost straight from glTF to GPU.

Some modifications to CGE may be required here (CastleGeometryArrays will have to be made more flexible for this). New X3D nodes should be introduced, like `BufferGeometry` (same as X3DOM?).

We should also perform skinning fully on GPU, avoiding `CoordinateInterpolator` done on CPU.

[#gltf_material_features]
## Support new glTF material extensions

- https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md[Clearcoat]
- https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md[Transmission]
- https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen/README.md[Sheen]
- https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md[IOR (index of refraction)]
- https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md[Volume]
- https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md[Specular]

See:

- https://www.khronos.org/news/press/khronos-releases-wave-of-new-gltf-pbr-3d-material-capabilities[Khronos Releases Wave of New glTF PBR 3D Material Capabilities]
- https://www.khronos.org/news/press/new-gltf-extensions-raise-the-bar-on-3d-asset-visual-realism[New glTF Extensions Raise the Bar on 3D Asset Visual Realism]
- https://www.khronos.org/blog/using-the-new-gltf-extensions-volume-index-of-refraction-and-specular[Using the New glTF Extensions: Volume, Index of Refraction, and Specular]

## More physics

- cgeref:TCastleWalkNavigation[] should support physics out-of-the-box.
+
*In progress:* We have completely new navigation components in https://github.com/castle-engine/castle-engine/pull/533 . They achieve a few things: more universal (suitable for 1st person 3D, 3rd person 3D, 2D cases), more configurable inputs, also from editor (expose new "axis" paradigm), more flexible (functionality split into a few components, easier to pick a subset of functionality you want, easier to write extensions), and honor the physics engine.
+
It will take some time (to test, merge and document new approach from PR above) but eventually cgeref:TCastleWalkNavigation[] will be deprecated. Don't worry, the deprecated cgeref:TCastleWalkNavigation[] will still be available for quite a while -- we're aware that many projects use it, since (as of today) we actually advise using cgeref:TCastleWalkNavigation[], as it's very easy to use and flexible enough for many situations.

- Older physics based on octrees should be phased out.
+
*In progress:* We're slowly already doing it. If you want to get ahead, you can already use physical colliders (link:physics[see physics manual]) and use queries like `PhysicsRayCast` instead of `WorldRay`.

- cgeref:TCastleSceneCore.ExposeTransforms[] should work both ways, to allow to attach bodies and colliders to parts of the scene. This will enable e.g. ragdolls.

- More physics backends, not only _Kraft_.
+
We're looking to add another physics engine that relies on some big, well-known and open-source engine. Our current considerations are either https://developer.nvidia.com/physx-sdk[PhysX] or https://pybullet.org/wordpress/[Bullet].
+
As as result of this, more physics engines can also be added more easily in the future.

- See more in link:physics#_future_plans_todos[manual about physics, subsection "TODO"].

[#web]
## (IN PROGRESS) Web platform (rendering using WebGL) support

Using https://www.freepascal.org/[FPC] support for the _WebAssembly_:

- https://wiki.freepascal.org/WebAssembly
- https://wiki.freepascal.org/WebAssembly/Compiler
- https://wiki.freepascal.org/WebAssembly/Roadmap

Some "glue" may also be done using https://wiki.freepascal.org/pas2js[pas2js]. This is a nice solution to expose to our WebAssembly code the JS API we need, like WebGL. Alternatively, we could just do it in plain JS.

_This is already in-progress by Trung Le (Kagamma), Andrzej Kilijański and Michalis._

I wrote a longer post about plans and status of this here: https://castle-engine.io/wp/2023/04/08/web-target-progress-and-plans/ .

[#particles]
## (IN PROGRESS) Particle systems

With a designer. Example usage: blood, snow, rain, fire, smoke... 2D, 3D.

_This is already in-progress by Trung Le (Kagamma). Use link:https://github.com/Kagamma/cge-3d-particle-emitter[cge-3d-particle-emitter] or link:https://github.com/Kagamma/cge-effekseer[Effekseer Integration]. See link:additional_components.php[CGE components]._

[#steam]
## (IN REVIEW) Steam integration, and engine available as Steam app

Official Steam integration in CGE, see https://trello.com/c/RNDjQhqe/71-steam-headers . We already used it for The Unholy Society, we want to either “just publish that approach” or propose a new, improved (without an intermediate “wrapper” library) approach.

We should also upload CGE as app to Steam.

_This is already in-progress by Eugene Loza (branch: https://github.com/castle-engine/castle-engine/commits/castle-steam , PR: https://github.com/castle-engine/castle-engine/pull/471 ), we also have a draft application on Steam for CGE :)_.

## Release mobile view3dscene (as Android and iOS application)

link:https://github.com/castle-engine/view3dscene-mobile[This is almost done, thanks to Jan Adamec.] We need to release it :)

Associated with glTF, X3D and other formats that the view3dscene (and _Castle Game Engine_) handles. Available in the App Store / Google Play Store. For free or for 1 USD (not sure yet; but definitely without ads, I really dislike ads).

[#terrain]
## Terrain designer

Easily design a height map (X3D cgeref:TElevationGridNode[] node, with trees, rocks, grass). Saved and loaded as an X3D file.

Implementing this feature will most likely be split into a couple of small releases:

- Edit the heights.
- Edit the grass and trees and rocks.
- Efficiently render huge amounts of grass and trees and rocks.

Implement nice shaders to show it, like link:https://www.getlazarus.org/videos/bareterrain/#learning_resources[this BareGame example].

_What we have now:_ The engine includes a unit `CastleTerrain` to generate terrains in various ways (most notably, from smoothed random noise). We have `examples/terrain/` demo to play around with it. We have the link:https://github.com/castle-engine/wyrd-forest["Wyrd Forest"] game that also uses `CastleTerrain`, and also includes a simple editor of terrain settings.

_What we need:_ Visual, interactive editor for the `ElevationGrid` (the thing you get from `TTerrain.Node` call). To make hills, valleys in a comfortable way. And comfortably plant there stuff (rocks, grass, trees...).

[#vulkan]
## Vulkan renderer

Add a https://www.vulkan.org/[Vulkan] renderer.

* API:
+
Almost all public CGE API will remain unchanged. For a long time now, we design our API to be independent from OpenGL, and all rendering (e.g. done by cgeref:TCastleScene[], cgeref:TCastleViewport[], cgeref:TCastleUserInterface[], cgeref:TDrawableImage[]) is driven by a renderer-neutral API.
+
Shaders will continue to be available using https://en.wikipedia.org/wiki/OpenGL_Shading_Language[GLSL]. There will be possibility to precompile them to https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation[SPIR-V] before usage (for both Vulkan and new OpenGL, as new OpenGL also supports SPIR-V).
+
Underneath, we will create a "pluggable" architecture for renderers. In theory we could implement a lot of renderers (e.g. also Metal or Direct3D) but given the limited resources, realistically we will focus on 2 renderers: Vulkan and OpenGL ("OpenGL" here meaning really a family OpenGL + OpenGLES + WebGL).

* Approach:
+
We have a simple example code that shows how you can start a new renderer: see link:https://github.com/castle-engine/castle-engine/blob/master/examples/research_special_rendering_methods/new_renderer_skeleton/[new_renderer_skeleton example]. This is great for testing initial implementation, before we have a "pluggable" architecture.

* Header:
+
I was playing with https://github.com/BeRo1985/pasvulkan[PasVulkan] from which we could use a Vulkan API header. See https://castle-engine.io/wp/2022/03/27/web3d-webinar-this-tuesday-steam-deck-test-documentation-updates-pasvulkan-tests/[news about PasVulkan].
+
We could also get Vulkan header from https://gen.glad.sh/[GLAD 2] if only we port it to Pascal (we plan this already).

* Platforms:
+
Not all platforms support Vulkan, in particular it's uncertain whether Apple with ever support it (they want to push Apple-specific Metal API). CGE will most likely use https://moltengl.com/moltenvk/[MoltenVK] to render using Vulkan on Apple, see https://castle-engine.io/macos#_apple_says_that_opengles_is_deprecated_what_happens_if_they_remove_opengles_from_macos_and_ios[plans regarding macOS / iOS and OpenGL, Vulkan].

////
## (Optional) Make TCastleScene, TCastleTranform and friends to be special X3D nodes

This would make the whole TCastleViewport.Items a single graph of X3D nodes, allowing for more sharing in code. The TCastleTranform would be just like TTransformNode, but a little diferently optimized (but it would become toggable at runtime).

It's unsure now whether this is really needed. Using cgeref:TCastleSceneCore.ExposeTransforms[] and making it better (synchronizing both ways) will fill the most important use-case of this.
////

[#bgfx]
## BGFX renderer

- https://github.com/bkaradzic/bgfx

- Docs: https://bkaradzic.github.io/bgfx/bgfx.html

- Pascal bindings: https://github.com/Akira13641/PasBGFX/ . Though reported as having issues: https://discord.com/channels/389676745957310465/468902667003887646/1173371248596762674 , we shall investigate.

Look great:

- open-source,
- packed with features,
- actively developed,
- open for bindings from any language, any game engine (it is explicitly made as renderer useful for various game engines),
- properly documented,
- very good platform and renderer suport.

This *may* be even better than direct Vulkan port. We shall see. On one hand, this provides more possibilities than just Vulkan (e.g. direct Metal renderer). And it may be easier to use than Vulkan. OTOH, it will not allow to squeeze "every last bit of performance from Vulkan" (though we really don't need that in CGE in the first place; there are lots of optimizations on the table in CGE before it's worth even thinking about low-level Vulkan optimizations).

[#distance_field_fonts]
## (IN REVIEW) Distance field fonts

See link:https://libgdx.com/wiki/graphics/2d/fonts/distance-field-fonts[about Distance field fonts]. See code from link:https://github.com/neurolabusc/OpenGLCoreTutorials[Chris Rorden] showing how to do it in Lazarus.

In review: PR: https://github.com/castle-engine/castle-engine/pull/504 .

## Mobile

### Wireframe on OpenGLES

Since `glPolygonMode` is not available at all on OpenGLES, we need to be able to generate wireframe geometry arrays on CPU, adding a "wireframe" option to `CastleArraysGenerator` that will generate a different (line) primitive for TGeometryArrays. Then the renderer can use such TGeometryArrays for OpenGLES.

This is started now, by having `Shape.shading = "WIREFRAME"` option, see https://castle-engine.io/x3d_implementation_shape_extensions.php#section_ext_shading[Shape.shading field]. We need to

* make it available for _all_ geometry shapes
* make this feature more flexible, so that the renderer can switch between wireframe/non-wireframe rendering without any cost.
* And then we can implement Attribute.WireframeEffect on OpenGLES correctly,
* and allow to set Wireframe on specific viewports (so that some viewports may view wireframe, independent of others) on OpenGLES.

### On-screen keyboard on iOS (done on Android)

### TGLImage.GetContents on OpenGLES

TGLImage.GetContents is not available on OpenGLES, as it doesn't support `glGetTexImage`. Fixing it is a matter of implementing alternative way that draws texture to FBO and grabs using SaveScreenGL (using glReadPixels internally).

One has to use TGLRenderToTexture to render quad with a texture (making sure the framebuffer size, quad size, and texture size match, and  without filtering) and then use glReadPixels to get the pixels from FBO. This will work on mobile (and also on desktops, although it will be less optimal alternative to glGetTexImage).

## macOS: Package engine as one big application bundle

This will:

- be simpler to users, as the engine will be "one single application" for macOS users.

- avoid troubles resulting from Apple translocation. It right now prevents the CGE editor from detecting CGE path.

- avoid current duplication of `castle-editor/data` in distributed package, thus making it smaller by ~60 MB.

See link:macos[macOS].

## macOS: Have signed app bundle for the editor

This will allow to run CGE editor on macOS by just double-clicking it, out-of-the-box.

See link:macos[macOS].

We should also enable developers to easily sign their own applications packaged with CGE build tool.

## (IN PROGRESS) fps_game should be redesigned using editor, CreatureCreatures / CastleResources / CastleLevels / CastleItems / CastlePlayer should be replaced with a better API

**In progress. See https://castle-engine.io/wp/2022/10/21/concept-art-teaser-huge-graphical-and-functional-upgrade-to-our-fps-game-is-coming/[news post]. On branch https://github.com/castle-engine/castle-engine/tree/fps-game-upgrade[fps-game-upgrade].**

These 5 units (CreatureCreatures / CastleResources / CastleLevels / CastleItems / CastlePlayer) expose a high-level API, that sits on top on existing classes (like TCastleScene and TCastleTransform). But I am not 100% happy with their API. Reasons:

- The API is too specialized at some points (3D games with creatures / items pickable),

- It is confusing how it maps to API underneath (e.g. TPlayer somewhat controls the TCastleNavigation).

Gradually I will want to express their features in different ways, in ways that are more closely and obviously connected with TCastleScene / TCastleViewport / TCastleNavigation. Basically, I'm very happy with current API of TCastleScene and TCastleTransform, and I want to make it more obvious how it is related to creatures/placeholders and other concepts introduced in CastleLevels and CastleCreatures and CastkeResources. Currently they use TCastleScene and TCastleTransform inside, but the relationship is non-obvious.

It's not going to happen any time soon, but it will happen gradually, over the course of next 1 or more years. That is, some of the features of the 5 units mentioned above will become available in other ways too (more flexible, and more obviously connected to TCastleScene).

I know this sounds vague, because I have not yet clarified these plans in my head:) These 5 units *are* useful, they provide various features on top of TCastleScene. I'm not going to just "ditch" them or even deprecate them, before I made a better API that also has these features. For example:

- New TCastleScene.Load should be able to take a callback (or some class instance) to easily perform the "placeholders" functionality of `TLevel.Load` in a flexible manner (user can decide what to replace with what).

- There will be TCastleSceneView that provides part of the functionality of T3DResource (multiple TCastleSceneView share a single TCastleScene but can show different animation frame of it), but without some often-unnecessary "baggage" from T3DResource (like refcounting of T3DResource, and it's special Prepare/Release methods).

- It should be possible to add an A.I. (like TWalkAttackLogic) to any TCastleTransform instance.

I know I want to go in this direction. Based on the questions (including on Discord) I see that the API of these 5 units is not clear to people. It wraps TCastleScene / TCastleViewport / TCastleNavigation, but in ways that are not obvious, and that is something I want to improve.

Again, bear in mind that it will not happen any time soon :) You can safely and happily use these units, probably for a few years to come.

But it is something I think about for the future, and it may explain some of my decisions. E.g. that is why I don't plan special integration of TCastleCreature with castle-editor. Instead I want to enable you to add future TWalkAttackLogic to any TCastleTransform one day. And thus we will have "easy creatures" in CGE but with more flexible API.

## Bridge TDrawableImage with TCastleScene, enable drawing UI into TCastleScene, to have UI rotated in 3D with perspective.

link:how_to_render_2d[See also here.]

## MDL and/or MaterialX integration

- MDL, https://developer.nvidia.com/rendering-technologies/mdl-sdk

- MaterialX, https://materialx.org/

We can make 3D modeling of realistically-looking stuff much easier by reusing libraries of realistic materials.

## USD – Universal Scene Description support

Explore possibility to support https://graphics.pixar.com/usd/release/index.html[USD – Universal Scene Description] format as a first-class citizen, alongside glTF and X3D, in CGE.

## Integration with Nakama (scalable server for social and real-time games and apps)

Integration with https://heroiclabs.com/docs/nakama/getting-started/index.html[Nakama]:

Nakama is an open-source server and client library/API that provide networking capabilities typically needed in games.

- The server is written in Go (see link:https://github.com/heroiclabs/nakama[source code]) and can be extended using Lua, JS, or Go modules. See https://heroiclabs.com/docs/nakama/server-framework/introduction/index.html[server framework].

- It supports out-of-the-box stuff like user accounts, matchmaking (connect people into rooms where the game happens), leaderboards, chat, etc. There's infrastructure to synchronize data between players in a multi-player game.

- Client library can be used from link:https://heroiclabs.com/docs/nakama/client-libraries/[various game engines and languages] so we're confident it can be used from CGE too.

- You can host the server yourself or pay to get ready hosting.

- As you can see in above links, it seems really well documented, and actively maintained. These are naturally critical qualities for our dependencies.

I think Nakama may give CGE networking capabilities comparable with some popular solutions known from other game engines :)

### Related: Ready components to replicate data over the Internet

Allowing to trivially get multi-player functionality in your games.

## Project settings editable using GUI

We will expose both current `CastleEngineManifest.xml` and `data/CastleSettings.xml` as something you can edit yourself with GUI.

But we *don't want* to create and maintain a custom GUI for them, instead the plan is to:

* Create Pascal components with published properties representing their data.
* Make the project settings files just "JSON design files" for the editor.

So you'll have a file like `project.castle-project` and using editor menu item like _"Project Build Settings"_ will really just open a design `project.castle-project` (JSON) in the editor, and it will be just a serialized `TCastleProject` component. Same for _"Project Runtime Settings"_ which edits `data/settings.castle-project-settings`.

Bonus: we'll associate `*.castle-project` with the system, to open when you double-click it e.g. from Windows installer.

Bonus: you can add non-visual components to `data/settings.castle-project-settings` and load them using `Container.DesignedComponent('xxx')`. This is great e.g. to add sounds or fonts or other data that you want to later load in CGE, from any view.

There are a few details that have to be ironed out here:

* how should the new equivalent of `CastleEngineManifest.xml` and `data/CastleSettings.xml` interact. We will likely keep 2 files, `project.castle-project` and `data/settings.castle-project-settings`, as
+
--
- Some information doesn't need to be packed into data, part of it could even be considered "somewhat secret" (e.g. SDK IDs for Android analytics should *not* be present anywhere in the non-Android builds).
- Some information should be packed into data automatically, by default, everything. To enable that _Bonus: you can add non-visual components_ feature.
--

* most intuitive names for all the things above (menu item names, component names, extensions etc.) :)

[#anims]
## Creating animations in CGE editor, for UI and transforms

Allow designing and testing animations in CGE editor.

The features cover animating typical UI/transform things that you see in CGE editor directly: e.g. UI stuff (like `TCastleUserIterface.Translation`, `TCastleImageControl.Color`), 3D stuff (`TCastleTransform.Translation`, `TCastleTransform.Rotation` etc.).

NOTE: Animating everything in CGE is already possible right now _using code_. You can update any values you want in `Update` method of your link:views[view] and change any value you need (like `MyControl.Translation`) using routines like `Lerp` or `SmoothStep`.

The point of this feature is to allow to design and see simple animations from editor. Code will then be able to just play them (e.g. using simple method `MyAnimation.Play`) whenever needed.

Features:

- Make it possible to animate (at least!) any property of cgeref:TCastleUserInterface[] and cgeref:TCastleTransform[]. Access the property using RTTI, and at design-time in editor allow to choose `TargetObject` and `TargetProperty` with suitable type.
+
Bonus: allow to animate any property of any `TComponent`.

- It should allow to animate at least any `Single/Double`, `TVector2/3/4` properties (this includes also colors, as `TCastleColor[RGB]` is just alias for `TVector3/4`; this includes also rotations, that is just `TVector4` but can use slerp for interpolation).
+
Bonus: allow to animate other property types. E.g. animating discrete (like boolean) actually makes sense -- to hide stuff by animation, by changing `Exists` at specific point in time.

- It should use `TCastleBehaviorBase` that will allow to attach it to any `TCastleUserInterface` and `TCastleTransform`. See talk about it in https://github.com/castle-engine/castle-engine/issues/473 .

- Each such animation should define:
+
--
- key-frames
- key-values
- configurable target component (TComponent)
- configurable target property (string? and get/set property using RTTI)
- easing (e.g. to make "bouncing" effect at the end of animation), https://easings.net/ https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function . Bonus: easing code and enums could be also used to acceleration/deceleration of `TCastleInputAxis`.
--

- Bonus: Group animations, so that from code you can fire like `MyUserInterfaceAppear.Play` and it runs a number of animations at once -- e.g. something "slides in" (translation changes), something appears (Exists changes), something fades in (Color.alpha changes)

See also:

- PR https://github.com/castle-engine/castle-engine/issues/473 and animation-player branch in this fork https://github.com/Freedomax/castle-engine/tree/animation-player
- Nice lean tweening code, independent from engine: https://github.com/glhrmfrts/wetween

[#screen_effects]
## Screen effects - expose as nicer components

Address a few shortcomings of our  (see `examples/screen_effects_demo/`, link:x3d_extensions_screen_effects.php[screen effects]):

- Change terminology. "Screen effect" is non-standard, "post-processing effects" are better.

- Expose as components some standard effects, like blur, changing colors in HSV, grayscale. They should have easy Pascal properties, serializable to JSON, and wrap the related X3D nodes underneath.

- Expose as component a customizable shader effect allowing you to provide GLSL code in a text box (TStringList editor) in CGE editor.

- This depends on making a more generic link:#component_list[TCastleComponentList] to expose `TCastleScreenEffects.ScreenEffects` list nicely.

## Export any TCastleTransform hierarchy to X3D

Currently you can only export `TCastleScene` to X3D.

## Export TCastleScene, or any TCastleTransform hierarchy, to glTF

Currently you can only export `TCastleScene` to X3D.

This will likely also imply rename of `tovrmlx3d` to `castle-convert`.

## Allow animating selected node graph properties, without changing the graph, to be able to reuse graphs

Right now our X3D graph usage is similar to HTML DOM usage from typical web applications: we modify the graph at runtime, everything that changes stuff (like animations) just changes the graph. This is simple to use, it nicely allows to animate _everything_ in X3D and gives developers an easy way to modify everything at runtime.

The downside is that we waste significant memory, and loading time, in some cases. If you want to play different animations on each cgeref:TCastleScene[], then they need to have a different graph even though they are loaded from the same `URL`. Hence using e.g. cgeref:TCastleScene.Clone[] or cgeref:TCastleSceneCore.Cache[] really internally makes multiple copies of the graph. This could be more optimal in the future. E.g. assuming your model only uses glTF skinned animation or animates simple transformation position/rotation/scale, we could make the graph read-only, and only maintain small "diff" information at each instance.

[#fmod_studio]
## FMOD Studio support

Right now our link:fmod[FMOD backend] uses only _"FMOD Core API"_.

We want to enable using higher-level FMOD events that drive the _sound banks_ exported from "FMOD Studio".

[#wwise]
## Wwise backend

Allow using https://www.audiokinetic.com/[AudioKinetic's Wwise] as sound backend, and as a middleware to design sounds.

[#async]
## Asynchronous loading of assets

As described in https://castle-engine.io/threads[threads], we want to allow loading assets *asynchronously*. This means that you use CGE API from one thread, but some operations are not "blocking" and CGE can internally use threads to finish their work, while your code continues to calculate, CGE events like `Update` continue to be processed etc.

For example:

[source,pascal]
----
TCastleScene.LoadAsync(const Url: String; const OnFinish: TNotifyEvent);

TCastleScene.PrepareResourcesAsynchronously;

TCastleTerrain.UpdateDataAsync(const NewData: TCastleTerrainData; const OnFinish: TNotifyEvent);
----

We already use such approach e.g. with cgeref:TCastleDownload[]. Internally it can download in a thread, but you don't need to worry about inherent "hard" issues with threads (synchronizing communication between threads, being careful who/when touches the shared variables). This approach results in:

- Really comfortable API. You handle everything from one thread, you get simple callbacks when things are done, you can simply watch (e.g. in some `Update`) status of something, display progress bars, interrupt the operation etc.

- Flexible implementation underneath. It can use Pascal threads underneath, or it can delegate work to another asynchronous API (e.g. to download using Java classes on Android), it can even fallback to synchronous if threads are not possible on some platform.

And it is possible to load OpenGL things in a thread: by having separate OpenGL context for the background thread, that shares resources (like VBO).

The ultimate demo is to implement exploring a huge city and loading neighboring pieces of the city asynchronously.

I mentioned this in the bottom part of https://castle-engine.io/wp/2022/10/12/slides-movies-and-thoughts-from-my-gic-2022-presentation/[Slides, movies and thoughts from my GIC 2022 presentation] .

## Merge TCastleImagePersistent and TDrawableImage

One less image class (we have too many image classes, see https://castle-engine.io/using_images ).

And it will avoid current counterintuive fact:

```
ImageControl.DrawableImage.CustomShader := Xxx;
```

The above is ignored, because `ImageControl.CustomShader` (equal to `ImageControl.Content.CustomShader`) overrides `TDrawableImage.CustomShader`. Similarly a few other drawable image properties, as `TCastleImagePersistent.Draw` does now:

[source,pascal]
----
 { All the DrawableImage properties must be set here,
    in case muliple TCastleImagePersistent refer to the same
    DrawableImage instance through the cache.
    Fortunately, almost all TDrawableImage properties have zero cost
    of change. }
  DrawableImage.SmoothScaling := FSmoothScaling;
  DrawableImage.Clip := FClip;
  DrawableImage.ClipLine := FClipLine;
  DrawableImage.Rotation := FRotation;
  DrawableImage.RotationCenter := FRotationCenter;
  DrawableImage.Alpha := FAlphaChannel;
  DrawableImage.Color := FColor;
  DrawableImage.CustomShader := FCustomShader;
----

## (IN PROGRESS) Gamepads (joysticks) support

Goal: Support modern gamepads (joysticks) with a nice API.

Note: We *have* support for gamepads (joysticks) already, see `CastleJoysticks` and `examples/joysticks/` . But it is not easy to use -- I'd like to improve the API, and improve it to handle various gamepad types in a more "seamless" fashion.

Features:

- It should support at least the most popular controller, which _X-box compatible controller_, out-of-the-box.
+
It seems we can easily support much more, using joysticks database: https://trello.com/c/483EsTNX/12-use-database-of-joysticks-to-better-understand-their-buttons-axis . But I make it explicit: the critical feature is support for the most common _X-box compatible controller_. Support for, potentially, every gamepad that exists in the world is secondary :)

- Should support at least Windows, Linux, and link:nintendo_switch[Nintendo Switch]. Switch support in this case is justified -- because we already support Switch gamepads, but we'll want to upgrade it to new API.
+
Of course support for more platforms is desired. macOS, and maybe even mobile (it does seem one can connect gamepad to Android through at least Bluetooth, it actually works). But these are secondary. The platforms mentioned above are primary for this feature.

- Should support multiple gamepads.

- API should be nice. Current `CastleJoysticks` is complicated. This means:
+
--
- `TInputPressRelease` structure, as send to `TCastleUserInterface.Press` (so in particular, `TCastleView.Press`) should have a type like `GamePadButton` (alternative to key on keyboard, or mouse botton) that occurs when user presses / releases the button. It should say which gamepad was used to press it (to support multiple joysticks connected to system). And it should report a button.
+
Buttons should have agnostic names, like _North_, _East_ etc. Avoid using names like ABXY that are in different places on different gamepad models (Xbox, PS, Nintendo...). Maybe we can also have names like _Accept_, _Cancel_ to follow conventions (e.g. on Xbox controller, A corresponds to "Accept" by convention, B corresponds to "Cancel").

- `TCastleInputAxis` (that is also already in progress) should allow to observe chosen gamepad axis (based on gamepad index, and choice horizontal/vertical, also choice of gamepad axis -- typical gamepads now have 2 axis). This is already a nice API to observe input that we want to have.
--

## Smart Tasks

Allow to define tasks that should occur regularly, but do not have to be done every frame. The engine should then automatically execute the tasks based on their need and current workload.

E.g. animation task may say "I want to update the model every frame, but actually I don't have to -- if under heavy workload it's enough to only update 30 times per second or such". This would be a better (more general, smarter -- activated automatically) way of optimizing it than current `TCastleScene.AnimationSkipTicks`.

[NOTE]
====
The API (terminology) and implementation have to play nicely with Delphi existing concept of "tasks" from Delphi _Parallel Programming Library_. Delphi already has a "task" meaning "a unit of work that can be executed in auto-created thread (using pool of threads underneath)", see

- https://docwiki.embarcadero.com/RADStudio/Sydney/en/Tutorial:_Using_Tasks_from_the_Parallel_Programming_Library[Tutorial: Using Tasks from the Parallel Programming Library]

- https://docwiki.embarcadero.com/RADStudio/Sydney/en/Using_TTask_from_the_Parallel_Programming_Library[Using TTask from the Parallel Programming Library]

- https://docwiki.embarcadero.com/Libraries/Sydney/en/System.Threading.TTask[TTask]

- https://blog.marcocantu.com/blog/2017-november-explaining-tasks-ppl-too-many.html[Explaining Tasks in Delphi Parallel Library... by Creating too Many Tasks]

So:

1. Our tasks, that are mainly to execute tasks in the main thread but with some delay ("execute this when convenient, I don't need it done right now") should be clearly something different. To avoid confusing API for people that know Delphi tasks.

2. When using threads, then we should use Delphi tasks (on Delphi), where possible. Only for FPC we'll need to duplicate subset of it (unless FPC will get the compatible implementation).
====

## Improve automatic reloading of files (in editor) when they changed

Automatic reloading (`CastleInternalFileMonitor`) now:

* Doesn't capture changes to secondary files, e.g. to textures used in glTF file. We only watch the file indicated by TCastleScene.Url now.

* When TCastleScene.Cache, the file will not be reloaded from disk correctly.

* Not all components implement necessary watching logic. For now only TCastleSceneCore. All components should eventually do it, e.g. TCastleTiledMap, TCastleImageTransform, TCastleImageControl.

[#ktx2]
## KTX 2.0 support

https://www.khronos.org/api/index_2017/ktx

A great format, by Khronos. Enables managing compressed textures much better. (than our existing solution: https://castle-engine.io/creating_data_auto_generated_textures.php )

[#expose_to_code]
## Expose component name for Pascal code

Right now to access a component set up in the design, you have to manually add it to the `published` section of the design, addign a declaration like `MyViewport: TCastleViewport`.

The goal is to make it more automated. A bit like Lazarus or Delphi IDE when exposing components to code -- but with some twist.

It would be easy to just expose *all* named components from the design in the `published` section of the view (this would be experience quite like when Delphi/Lazarus do) but, since typical game designs (we've seen it in Unity games in CAG) can contain thousands of components easily, and most of them are not supposed to be accessed from code, we want to go one step further:

- Add a button "Expose To Code" (available on single component, or selection of components).

- Once used, the component will be added to the `published` section of the view (`name: type`), and will be updated there (on rename/delete of this component, or change of it's class).

- This is also means we'll edit the `uses` clause of unit to make sure all used component classes are registered, and declared, so that declarations in `published` section work. This is also something Delphi/Lazarus do. We know the unit of each component, so it should be easy.

It is possible we'll add markers `{$region 'Castle ...'}` to help organize this. See the current markers in `gameinitialize.pas`.

[#design_overrides]
## Allow to override design properties when instantiated using TCastleDesign, TCastleTransformDesign

Allow to customize the hierachy instantiated through cgeref:TCastleDesign[] or cgeref:TCastleTransformDesign[].

In Unity, this is called _"prefab overrides"_. In Delphi/Lazarus, _frames_ also offer this functionality.

The idea is that, in the "outer" design, we can save only the differences from your original design to the customized version.

See link:custom_components[Custom components] documentation, and the section _"Using designs to visually set up default state of your component"_.

[#shadow_maps]
## Make shadow maps available by a trivial property on light sources

Right now, activating https://castle-engine.io/x3d_extensions_shadow_maps.php[shadow maps] is more involved. You need to setup special X3D nodes, and they only https://github.com/castle-engine/castle-engine/issues/284[work within a single scene].

This is in contrast to https://castle-engine.io/shadow_volumes[shadow volumes] that are trivial to activate: you literally just toggle one checkbox `Shadows` on our light components (`TCastleXxxLight`).

We want to have both these shadow approaches be trivial to enable. Light source should just have a property like `ShadowsMethod` to choose shadows algorithm..

NOTE: Alternative, rejected, API idea was to turn `Shadows` into an enum with a possible "none" value, like `Shadows: (None, Volumes, Maps)`. Separate Boolean to choose whether shadows are enabled at all, separate from choosing shadows algorithm, seems more natural.

[#component_list]
## Component list class, to easily expose serialized list of components in editor

We want to have a component list class, that

- Maps to a subtree in the "Hierarchy" in CGE editor,

- Can be used to express current (this will make some code in editor and `CastleInternalInspector` simpler):
+
--
- `TCastleTransform` children of `TCastleTransform`,
- `TCastleBehavior` children of `TCastleTransform`,
- `TCastleUserInterface` children of `TCastleUserInterface`
--

- Can be used to express future things:
+
--
- Screen (post-processing) effects list, see link:#screen_effects[Screen effects - expose as nicer components],
- Materials, textures, effects, see link:#materials[New material components]
- Tiled map layers, see link:#tiled_layers[New API for Tiled layers]
--

- Is generic, so we can be safe at compile-time about what is allowed to be inserted. That's why we don't want to just use standard `TComponentList`.

- Would allow CGE editor to easily hide some lists, while not hiding others. E.g. whether to expand `TCastleBehavior` in the hierarchy -- can be just UI choice.
+
Conceptually, when Unity has hierarchy (of `GameObject`) on left and list of components (_components_ in Unity sense, i.e. pieces of `GameObject`) on right, we instead have a tree of components (_components_ in Pascal and CGE sense, i.e. `TComponent`). It is just editor UI decision -- which levels are shown in the tree (hierarchy), which are not (e.g. behaviors could be hidden, or shown in some different way, in editor -- and it shall be unrelated to the Pascal classes organzation).

Idea:

`TCastleBaseComponentList = class(TComponent)`

- Internally uses `TComponentList` for storage because we want items to auto-disappear when they are freed wherever.
- Do not inherit from `TComponentList`, to not expose everything, limit access to our methods/properties. So only use it as a private field.
- Non-generic, editor can use it as a base class for all nested lists.
- Editor operations like move up/down, remove, add, should use this class.

`TCastleComponent.GetComponentLists` method: Query all `TCastleBaseComponentList`. Maybe it should just use RTTI to query all `TCastleComponentList<T>` on given object, from them extract `TCastleBaseComponentList` and return them. This is crucial for editor to show hierarchy. One of the lists should be "default" to show it without intermediate item in hierarchy (e.g. TCastleTransform children are `Children: TCastleComponentList<TCastleTransform>` but we don't display `Children` intermediate item in hierarchy).

`TCastleComponentList<T> = class(TComponent)`

- Generic, safe to use from code.
- internally uses `InternalBaseList: TCastleBaseComponentList` to store items, as private filed. (Do not inherit, to not expose everything non-generic.)

Another phrasing of this (equivalent, mostly):

Unify the processing of both visual children of TCastleTransform, and visual children of TCastleUserInterface, and NonVisualComponents -- by new `TCastleComponentList<T>`. This will be backward compatible, and will guarantee that all these iterations really use the same mechanism (right now these iterations are ~consistent just because they have been manually made to look siimlar each time).

So we'll have

```pascal
TCastleComponent = class(TComponent)
  NonVisualComponents: TCastleComponentList<TCastleComponent>;
end;

TCastleUserInterface = class(TCastleComponent)
  Children: TCastleComponentList<TCastleUserInterface>;
end;

TCastleTransform =  = class(TCastleComponent)
  Children: TCastleComponentList<TCastleTransform>;
  Behaviors: TCastleComponentList<TCastleBehavior>;
end;
```

and iterating with  `for .. in ... ` will be always equivalent to iterating over `Children`.

So

`for C in MyTransform do`

will be equivalent to

`for C in MyTransform.Children do`

Same

`for C in MyUserInterface do`

will be equivalent to

`for C in MyUserInterface.Children do`

And you can also do

`for C in MyTransform.Behaviors do...`

`for C in MyTransform.NonVisualComponents do...`

Right now... it's already mostly like that, but due to the fact that I declared a few things manually in the same way. The new `TCastleComponentList<T>` should force it to be consistent, and also make some code easier for editor.

[#tiled_layers]
## New API for Tiled layers

- New class `TCastleTiledMap.TLayer = class(TCastleComponent)`
+
TODO: Make sure it can be serialized OK. Fallback on `TCastleTiledMapLayer` if necessary. But we prefer `TCastleTiledMap.TLayer`.

- New published property `Layers:TCastleComponentList<TLayer>` inside `TCastleTiledMap`.
+
Depends on link:#component_list[TCastleComponentList] plans. We want to serialize the properties of layers this way.

- Remove existing `Layers` set from `TCastleTiledMap`.
+
Write code in `TCastleTiledMap.CustomSerialization(const SerializationProcess: TSerializationProcess);` to upgrade existing designs to new API.
+
Pascal code using old `Layers` will just be broken and have to be upgraded, acceptable.

- `Exists` should be in `TCastleTiledMap.TLayer`, and not in `TCastleTiledMapData.TLayer`.
+
Should toggling it toggle also `TCastleTiledMapData.TLayer.Visible`? Or let `TCastleTiledMapData.TLayer.Visible` stay as "initial value"? Undecided, not really very important.

- The long-term goal is to have nice components for layers and maybe more (tiles), inside `TCastleTiledMap`, with published properties, that can be designed in CGE editor, and that are serialized using existing system to JSON.
+
It should be possible to design layers (and maybe more, like tiles) in CGE editor.
+
This way we can go, step by step, to having own Tiled-like editor in CGE, like Godot or Unity.
+
At the same time, we want to support https://www.mapeditor.org/[Tiled] (as external application for map editing) and support it fully, because Tiled is great! and it may take us long time to actually have fully useful tile editor in CGE editor. The road should be that `Data` stuff, and everything in `TCastleTiledMapData`, becomes less and less useful. It's an internal detail whether our public `TCastleTiledMap.TLayer` has a reference like `Data:TCastleTiledMapData.TLayer` or not.
